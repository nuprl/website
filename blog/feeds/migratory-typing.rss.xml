<?xml version="1.0" encoding="utf-8"?> 
<rss version="2.0">
 <channel>
  <title>PRL Blog: Posts tagged 'migratory typing'</title>
  <description>PRL Blog: Posts tagged 'migratory typing'</description>
  <link>http://prl.ccs.neu.edu/blog/tags/migratory-typing.html</link>
  <lastBuildDate>Wed, 23 Dec 2020 18:21:55 UT</lastBuildDate>
  <pubDate>Wed, 23 Dec 2020 18:21:55 UT</pubDate>
  <ttl>1800</ttl>
  <item>
   <title>Deep and Shallow Types</title>
   <link>http://prl.ccs.neu.edu/blog/2020/12/23/deep-and-shallow-types/?utm_source=migratory-typing&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2020-12-23-deep-and-shallow-types</guid>
   <pubDate>Wed, 23 Dec 2020 18:21:55 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;I successfully defended my Ph.D. dissertation. You can find the document, a talk recording, and much more here:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://ccs.neu.edu/home/types/publications/publications.html#g-dissertation-2020"&gt;http://ccs.neu.edu/home/types/publications/publications.html#g-dissertation-2020&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;To the PRL: thanks for a wonderful 6.5 years.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h3 id="abstract"&gt;Abstract&lt;/h3&gt;

&lt;blockquote&gt;
 &lt;p&gt;The design space of mixed-typed languages is lively but disorganized. On one hand, researchers across academia and industry have contributed language  designs that allow typed code to interoperate with untyped code. These design efforts explore a range of goals;  some improve the expressiveness of a typed language, and  others strengthen untyped code with a tailor-made type system. On the other hand, experience with type-sound designs has revealed major challenges. We do not know how to measure the performance costs of sound interaction. Nor do we have criteria that distinguish ``truly sound&amp;rsquo;&amp;rsquo; mixed-typed languages  from others that enforce type obligations locally rather than globally.&lt;/p&gt;
 &lt;p&gt;In this dissertation, I introduce methods for assessing  mixed-typed languages and bring order to the design space. My first contribution is a performance-analysis method that allows language  implementors to systematically measure the cost of mixed-typed interaction.&lt;/p&gt;
 &lt;p&gt;My second contribution is a design-analysis method that allows language designers  to understand implications of the type system. The method addresses two central questions: whether typed code can cope with  untyped values, and whether untyped code can trust static types. Further distinctions arise by asking whether error outputs can  direct a programmer to potentially-faulty interactions.&lt;/p&gt;
 &lt;p&gt;I apply the methods to several designs and discover limitations that motivate  a synthesis of two ideas from the literature:  deep types and shallow types. Deep types offer strong guarantees but impose a high interaction cost. Shallow types offer weak guarantees and better worst-case costs. This dissertation proves that deep and shallow types can interoperate  and measures the benefits of a three-way mix.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Next year, I&amp;rsquo;ll be a &lt;a href="https://cifellows2020.org"&gt;CI Fellow&lt;/a&gt; at Brown.&lt;/p&gt;</description></item>
  <item>
   <title>Complete Monitors for Gradual Types</title>
   <link>http://prl.ccs.neu.edu/blog/2019/10/31/complete-monitors-for-gradual-types/?utm_source=migratory-typing&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2019-10-31-complete-monitors-for-gradual-types</guid>
   <pubDate>Thu, 31 Oct 2019 21:58:26 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;Syntactic type soundness is too weak to tell apart different ways of running  a program that mixes typed and untyped code. Complete monitoring is a stronger property that captures a meaningful  distinction &amp;mdash; a language satisfies complete monitoring iff it checks  all interactions between typed and untyped code.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;blockquote&gt;
 &lt;p&gt;Note: this post is an extended abstract for the paper &lt;em&gt;Complete Monitors for Gradual Types&lt;/em&gt; by Ben Greenman, Matthias Felleisen, and Christos Dimoulas. For the full paper, proofs, and slides, &lt;a href="http://www.ccs.neu.edu/home/types/publications/publications.html#gfd-oopsla-2019"&gt;click here&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3 id="example-clickable-plot"&gt;Example: Clickable Plot&lt;/h3&gt;

&lt;p&gt;The program below has a subtle bug. Can you find it?&lt;/p&gt;

&lt;p&gt;&lt;img src="/img/complete-monitoring-0.png" alt="Untyped client code, a typed API, and untyped library code." /&gt;&lt;/p&gt;

&lt;p&gt;First of all, this pseudocode program combines three chunks of code:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;On the left, an &lt;strong&gt;untyped&lt;/strong&gt; client script defines a function &lt;code&gt;h&lt;/code&gt; that expects  a pair of numbers and returns an image. The client uses this function to  create a &lt;code&gt;ClickPlot&lt;/code&gt; object, and then displays the plot &amp;mdash; ideally in a new  GUI window.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;In the center, a &lt;strong&gt;typed&lt;/strong&gt; API file describes a &lt;code&gt;ClickPlot&lt;/code&gt; object as  something with one constructor and two methods. The constructor expects  a function; according to the type, such functions can expect a pair of  numbers and must compute an image. The &lt;code&gt;mouseHandler&lt;/code&gt; method expects  a &lt;code&gt;MouseEvt&lt;/code&gt; object and returns nothing. The &lt;code&gt;show&lt;/code&gt; method expects no arguments  and returns nothing. (Presumably, these methods have side effects.)&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;On the right, an &lt;strong&gt;untyped&lt;/strong&gt; library module implements a &lt;code&gt;ClickPlot&lt;/code&gt; object.  Most of the code is omitted (&lt;code&gt;...&lt;/code&gt;), but the &lt;code&gt;mouseHandler&lt;/code&gt; method sends  its input directly to the &lt;code&gt;onClick&lt;/code&gt; callback.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The &lt;strong&gt;bug&lt;/strong&gt; is in the API &amp;mdash; in the type &lt;code&gt;([N, N]) =&amp;gt; Image&lt;/code&gt;. This type promises that a given function can expect a pair of numbers,  and indeed the client function &lt;code&gt;h&lt;/code&gt; expects a pair. But the library code on the right sends a &lt;code&gt;MouseEvt&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;What happens when we run this program in a type-sound mixed-typed language? Does &lt;code&gt;h&lt;/code&gt; receive the invalid input?&lt;/p&gt;

&lt;p&gt;As it turns out, type soundness cannot say. A type sound language may choose to enforce or ignore the fact that the  API promises a pair of numbers to the client.&lt;/p&gt;

&lt;h3 id="type-soundness-is-not-enough"&gt;Type Soundness is Not Enough&lt;/h3&gt;

&lt;p&gt;Sound types are statements about the behavior of a program. A normal type soundness theorem for a typed language says that a well-typed  program can either compute a value of the same type, compute forever (diverge),  or stop with an acceptable error (perhaps division by zero). No other behaviors are possible.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;strong&gt;Classic Type Soundness&lt;/strong&gt;&lt;/p&gt;
 &lt;p&gt;If &lt;code&gt;e : T&lt;/code&gt; then one of the following holds:&lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;&lt;code&gt;e --&amp;gt;* v&lt;/code&gt; and &lt;code&gt;v : T&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;e&lt;/code&gt; diverges&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;e --&amp;gt;* OkError&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;

&lt;p&gt;A mixed-typed language needs two &amp;ldquo;type soundness&amp;rdquo; theorems:  one for typed code and one for untyped code. The &lt;strong&gt;typed&lt;/strong&gt; soundness theorem can resemble a classic theorem. The &lt;strong&gt;untyped&lt;/strong&gt; soundness theorem is necessarily a weaker statement due to  the lack of types:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;strong&gt;Mixed-Typed Soundness&lt;/strong&gt;&lt;/p&gt;
 &lt;p&gt;If &lt;code&gt;e : T&lt;/code&gt; then one of the following holds:&lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;&lt;code&gt;e --&amp;gt;* v&lt;/code&gt; and &lt;code&gt;v : T&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;e&lt;/code&gt; diverges&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;e --&amp;gt;* OkError&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
 &lt;p&gt;And if &lt;code&gt;e&lt;/code&gt; is untyped then one of the following holds:&lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;&lt;code&gt;e --&amp;gt;* v&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; is an untyped value&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;e&lt;/code&gt; diverges&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;e --&amp;gt;* OkError&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;

&lt;p&gt;Now we can see why mixed-typed soundness is not strong enough to guarantee that  the callback &lt;code&gt;h&lt;/code&gt; in the code above receives a pair value. We have an &lt;strong&gt;untyped&lt;/strong&gt; function called from an &lt;strong&gt;untyped&lt;/strong&gt; context &amp;mdash; since  there are no types sitting right there, type soundness has nothing to say  except that the untyped code can expect an untyped value!&lt;/p&gt;

&lt;p&gt;&lt;img height="200px" src="/img/complete-monitoring-1.png" alt="Untyped library sends input directly to untyped client." /&gt;&lt;/p&gt;

&lt;p&gt;Nevertheless, this channel of communication between the library and client  arose through the typed API. One might expect the type &lt;code&gt;[N, N]&lt;/code&gt; to restrict the values that can flow across  the channel; indeed, if types really are statements about the behavior of a program,  then the channel needs to be protected.&lt;/p&gt;

&lt;p&gt;The question is: what formal property separates languages thet check  all typed/untyped channels of communication (whether direct or derived)? One answer is complete monitoring.&lt;/p&gt;

&lt;h3 id="complete-monitoring"&gt;Complete Monitoring&lt;/h3&gt;

&lt;p&gt;A mixed-typed language satisfies complete monitoring iff evaluation never  lets a value flow un-checked across a type boundary. To make this idea precise, we need to enrich the syntax of the language  with a specification of &lt;em&gt;ownership&lt;/em&gt; to say what parts of the program are  responsible for different values, and to say how evalution changes  responsibilities. Relative to a specification, complete monitoring states that every expression  that arises during evaluation is made up of parts that each have a single  owner.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;Complete Monitoring&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;For all well-formed &lt;code&gt;e&lt;/code&gt; and all &lt;code&gt;e'&lt;/code&gt;, if &lt;code&gt;e --&amp;gt;* e'&lt;/code&gt; then every subexpression of &lt;code&gt;e'&lt;/code&gt; has a unique owner.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This property separates our two behaviors for the Clickable Plot code. A language that satisfies complete monitoring enforces the API types with  a runtime check. A language that merely satisfies type soundness may skip these checks.&lt;/p&gt;

&lt;h3 id="an-aid-to-debugging"&gt;An Aid to Debugging&lt;/h3&gt;

&lt;p&gt;The question raised by the Clickable Plot example is whether a language can  &lt;strong&gt;detect&lt;/strong&gt; one mismatch between a type and a value. A language that satisfies complete monitoring detects all such mis-matches. But we can say more. If a mismatch occurs, then programmer knows exactly where to start debugging  &amp;mdash; either the type is an incorrect specification, or the given value is  flawed. In other words, complete monitoring implies a concise 2-party explanation  for every type mismatch.&lt;/p&gt;

&lt;p&gt;The paper generalizes this goal of explaining a mismatch for languages  that fail to satisfy complete monitoring. There may be 2N parties to blame thanks to un-checked channels of communication,  and we want to be certain to report all these parties and no false positives.&lt;/p&gt;

&lt;p&gt;Also in the paper, you can find:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;a model of ownership, clear &lt;em&gt;laws&lt;/em&gt; for how ownership changes during evaluation;&lt;/li&gt;
 &lt;li&gt;examples of how to systematically add ownership to an operational semantics  to attempt a proof of complete monitoring;&lt;/li&gt;
 &lt;li&gt;definitions for &lt;strong&gt;blame soundness&lt;/strong&gt; and &lt;strong&gt;blame completeness&lt;/strong&gt;;&lt;/li&gt;
 &lt;li&gt;an analysis of three semantics, which correspond to &lt;a href="https://docs.racket-lang.org/ts-reference/index.html"&gt;Typed Racket&lt;/a&gt;,  &lt;a href="http://hdl.handle.net/2022/23172"&gt;Transient Reticulated&lt;/a&gt;, and a compromise;&lt;/li&gt;
 &lt;li&gt;and discussion of an alternative, heap-based model of ownership.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Paper: &lt;a href="https://www2.ccs.neu.edu/racket/pubs/oopsla19-gfd.pdf"&gt;https://www2.ccs.neu.edu/racket/pubs/oopsla19-gfd.pdf&lt;/a&gt;&lt;/p&gt;</description></item>
  <item>
   <title>Forgetful and Heedful contracts</title>
   <link>http://prl.ccs.neu.edu/blog/2019/04/07/forgetful-and-heedful-contracts/?utm_source=migratory-typing&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2019-04-07-forgetful-and-heedful-contracts</guid>
   <pubDate>Sun, 07 Apr 2019 23:15:11 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;&lt;em&gt;Forgetful&lt;/em&gt; and &lt;em&gt;heedful&lt;/em&gt; are two methods for space-efficient contracts  developed by &lt;a href="http://www.cs.pomona.edu/~michael/"&gt;Michael Greenberg&lt;/a&gt; in &lt;a href="https://arxiv.org/abs/1410.2813"&gt;2014&lt;/a&gt;. These methods were born in the shadow of a third method, &lt;em&gt;eidetic&lt;/em&gt;,  with stronger theoretic properties. Since then, however, the forgetful method has been re-invented at least twice. Both deserve a second look.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;hr /&gt;

&lt;p&gt;Contracts are a tool for specifying and dynamically-enforcing the behavior  of a program. In a language with contracts, a programmer can annotate an API with  code that documents the intended use for other readers. When client code interacts with such an API, the annotations ensure that the  actual behavior matches the expected. If there is a mismatch, the contract annotations can report an issue  in terms of &lt;a href="https://www2.ccs.neu.edu/racket/pubs/popl11-dfff.pdf"&gt;three parties&lt;/a&gt;:  the API code, the client code, and the contract between them.&lt;/p&gt;

&lt;p&gt;For example, a Racket module that exports a sorting function can use a contract  to describe the kind of input it expects. If a client module sends invalid input, the contract blames the client  module for the error, assuming that the contract is bug-free:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #lang racket/base

  (module sort racket
    (provide
      (contract-out
        [quicksort
          (-&amp;gt; (vectorof point/c) void?)]))

    (define point/c (vectorof integer?))

    (define (quicksort points)
      ....))

  (module client racket
    (require (submod ".." sort))
    (quicksort '()))

  (require 'client)&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;quicksort: contract violation;
 expected a vector
  given: '()
  in: the 1st argument of
      (-&amp;gt; (vectorof (vectorof integer?)) void?)
  contract from: 
      (file.rkt sort)
  blaming: (file.rkt client)
   (assuming the contract is correct)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That covers the basics. For an extended introduction to contracts, visit  &lt;a href="https://docs.racket-lang.org/guide/contracts.html"&gt;The Racket Guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The quicksort example and the related figures are from the paper  &lt;a href="http://users.cs.northwestern.edu/~robby/pubs/papers/oopsla2018-fgsfs.pdf"&gt;&lt;em&gt;Collapsible Contracts: Fixing a Pathology of Gradual Typing&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id="classic-contracts-and-space-efficiency"&gt;Classic contracts and &amp;ldquo;Space Efficiency&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;(vectorof point/c)&lt;/code&gt; contract used above describes a possibly-mutable  array whose elements match the &lt;code&gt;point/c&lt;/code&gt; contract. Since the array can be mutated, this contract has implications for two parties:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;the client module must supply a good array, and&lt;/li&gt;
 &lt;li&gt;the sorting module must not insert a bad element.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;To enforce the second condition, the &lt;code&gt;vectorof&lt;/code&gt; contract wraps incoming  vectors in a proxy that checks future writes. Suppose the client sends a vector with four points:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(quicksort (vector (vector 4 4)
                   (vector 2 2)
                   (vector 1 1)
                   (vector 3 3)))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After applying the contract, the vector is wrapped in a proxy that checks  incoming writes and outgoing reads. The following picture illustrates the wrapper with a &lt;strong&gt;solid&lt;/strong&gt; blue bar  for the &lt;strong&gt;write&lt;/strong&gt; checks against the sort module and a &lt;em&gt;striped&lt;/em&gt; blue bar  for the &lt;em&gt;read&lt;/em&gt; checks against the client.&lt;/p&gt;

&lt;p&gt;&lt;img src="/img/vector-chaperone-0.png" alt="A wrapped vector" /&gt;&lt;/p&gt;

&lt;p&gt;In a straightforward implementation, these wrappers can stack up if multiple  contracts are applied to the same value. For our quicksort in particular, the elements of the vector are mutable  vectors and may accumulate wrappers as the vector is sorted &amp;mdash;  because every &lt;strong&gt;write&lt;/strong&gt; and &lt;em&gt;read&lt;/em&gt; applies a contract to the element.&lt;/p&gt;

&lt;p&gt;&lt;img src="/img/vector-chaperone-1.png" alt="Layers of element wrappers" /&gt;&lt;/p&gt;

&lt;p&gt;On the bright side, these wrappers enforce the contracts and help the  programmer understand the source of the error if any contract is violated.&lt;/p&gt;

&lt;p&gt;Unfortunately, the wrappers also affect the performance of the program. There are prices to pay for:  (1) checking values against the contracts,  (2) allocating new wrappers,  (3) and &amp;ldquo;indirecting&amp;rdquo; future writes/reads through wrappers. These space and time costs can add up.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&amp;ldquo;on a randomly ordered vector of 1,000 points, a call to quicksort can wrap the inner vectors an average of 21 times&amp;rdquo; &amp;mdash; &lt;a href="http://users.cs.northwestern.edu/~robby/pubs/papers/oopsla2018-fgsfs.pdf"&gt;&lt;em&gt;Collapsible Contracts&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;To fix the problem, researchers have been exploring &lt;em&gt;space-efficient&lt;/em&gt;  implementations of contracts that attach a bounded number of wrappers to any  value. Michael Greenberg is one of these researchers, and &lt;em&gt;eidetic&lt;/em&gt;, &lt;em&gt;forgetful&lt;/em&gt;,  and &lt;em&gt;heedful&lt;/em&gt; are his names for three implementations.&lt;/p&gt;

&lt;p&gt;(Although the goal of this post is to promote &lt;em&gt;forgetful&lt;/em&gt; and &lt;em&gt;heedful&lt;/em&gt;,  we will review all three.)&lt;/p&gt;

&lt;h3 id="eidetic-space-efficiency"&gt;Eidetic space-efficiency&lt;/h3&gt;

&lt;p&gt;The eidetic method introduces a data structure to represent higher-order  contracts. The structure supports a &lt;em&gt;merge&lt;/em&gt; operation;  when two contracts meet, they are merged in a way that avoids duplication. Eidetic contracts have the same behavior as normal &amp;ldquo;wrapping&amp;rdquo; contracts  and their size is bounded by the number (and height) of source-code  contracts in the program.&lt;/p&gt;

&lt;p&gt;An eidetic contract is an &lt;code&gt;N&lt;/code&gt;-ary tree (for &lt;code&gt;N &amp;gt; 0&lt;/code&gt;):&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;each node represents a higher-order contract combinator, such as &lt;code&gt;vectorof&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;the &lt;code&gt;N&lt;/code&gt; children of a node represent the different interactions that the  value supports&lt;/li&gt;
 &lt;li&gt;each leaf is a list of non-higher-order, or &lt;em&gt;flat&lt;/em&gt;, contracts&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;For example, the &lt;code&gt;(vectorof point/c)&lt;/code&gt; source-code contract describes an  eidetic tree with 3 nodes and 4 singleton-list leaves. Section 3.1 of the &lt;a href="http://users.cs.northwestern.edu/~robby/pubs/papers/oopsla2018-fgsfs.pdf"&gt;Collapsible Contracts&lt;/a&gt; paper has an illustration. Each tree node represents a &lt;code&gt;vectorof&lt;/code&gt; contract;  these nodes have &lt;code&gt;N=2&lt;/code&gt; children because vectors support reads and writes.&lt;/p&gt;

&lt;p&gt;A successful merge combines two trees of the same shape  by re-using half the nodes  and appending the leaf lists. Re-using nodes saves some space, and helps reduce the overhead of trees  relative to simple wrapping contracts. The main savings comes from filtering the leaf lists &amp;mdash; if an  implementation comes with a &lt;code&gt;contract-stronger?&lt;/code&gt; predicate that tests  whether one flat contract accepts fewer values than a second, then it  can remove leaf-list contracts that are preceded by stronger ones. Trees make this filtering possible.&lt;/p&gt;

&lt;p&gt;Suffice to say, eidetic is an ideal solution in theory but comes with  practical challenges. Are trees more expensive than wrappers in the common case? Can the leaf-lists in a tree share elements? Should &lt;code&gt;contract-stronger?&lt;/code&gt; try to solve problems that lack polynomial-time  solutions?&lt;/p&gt;

&lt;p&gt;Thankfully, there are at least two &amp;ldquo;compromise&amp;rdquo; alternatives.&lt;/p&gt;

&lt;h3 id="forgetful-space-efficiency"&gt;Forgetful space-efficiency&lt;/h3&gt;
&lt;!-- "no operation relies on e being a T2, skipping the check doesn't risk soundness" p.12--&gt;
&lt;!-- "In forgetful \lambda_H, we offer a simple solution to space inefficient casts: just forget about them" p.11--&gt;
&lt;!-- "Just the same, when accumulating casts on the stack, we throw away all but the last cast" p.11--&gt;
&lt;!-- "forgetful ... skip[s] checks and change[s] blame labels" p.3--&gt;

&lt;blockquote&gt;
 &lt;p&gt;&amp;ldquo;Forgetful is an interesting middle ground: if contracts exist to make partial operations safe (and not abstraction or information hiding), forgetfulness may be a good strategy.&amp;rdquo; &amp;mdash; &lt;a href="https://arxiv.org/abs/1410.2813"&gt;&lt;em&gt;Space-Efficient Manifest Contracts&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;!-- Section 10, bottom of page 23--&gt;&lt;/blockquote&gt;

&lt;p&gt;The forgetful method is exceptionally simple. When applying a new contract to a value, first check whether it is  wrapped in a similar contract. If so, then replace the existing wrapper with one that combines:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;the client obligations from the old contract, and&lt;/li&gt;
 &lt;li&gt;the server obligations from the new contract&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;If not, proceed as usual &amp;mdash; by wrapping (an unwrapped value)  or raising an error. Every value receives at most &lt;strong&gt;one&lt;/strong&gt; wrapper;  this wrapper changes as the value flows to different clients.&lt;/p&gt;

&lt;p&gt;Forgetful is safe in the sense that every piece of code can trust the  top-level shape of the values it receives. Suppose module &lt;code&gt;A&lt;/code&gt; exports a function &lt;code&gt;f&lt;/code&gt; with contract &lt;code&gt;(-&amp;gt; T1 T2)&lt;/code&gt; to  module &lt;code&gt;B&lt;/code&gt;, and suppose module &lt;code&gt;B&lt;/code&gt; shares this function with a few other  client modules using different contracts. As &lt;code&gt;f&lt;/code&gt; flows to a new client, it keeps the &lt;code&gt;T1&lt;/code&gt; domain check and gets a  replacement for the &lt;code&gt;T2&lt;/code&gt; codomain check.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Keeping &lt;code&gt;T1&lt;/code&gt; ensures that the code inside the function  (defined by module &lt;code&gt;A&lt;/code&gt;) receives input that matches its expectation.&lt;/li&gt;
 &lt;li&gt;Replacing &lt;code&gt;T2&lt;/code&gt; ensures that each new client receives output that it expects.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Unfortunately, replacing &lt;code&gt;T2&lt;/code&gt; also means that clients of module &lt;code&gt;B&lt;/code&gt; cannot  trust the &lt;code&gt;T2&lt;/code&gt; contract. This contract is not checked, and so forgetful contracts &lt;strong&gt;miss&lt;/strong&gt; some  errors that would be caught by standard contracts. For the same reason, a bug in module &lt;code&gt;B&lt;/code&gt; may go undetected by its clients  &amp;mdash; even if a later contract reports an issue, the contract system has  no memory that &lt;code&gt;B&lt;/code&gt; was partly-responsible.&lt;/p&gt;

&lt;p&gt;Despite these changes in behavior, forgetful is a straightforward  method for saving space and time relative to classic contracts.&lt;/p&gt;

&lt;h3 id="heedful-space-efficiency"&gt;Heedful space-efficiency&lt;/h3&gt;

&lt;p&gt;A heedful contract is a set of classic higher-order contracts. When applying a new contract to a value, check whether the new contract  is in the set. If so, ignore the new contract. If not, add the new contract to the set &amp;mdash; or raise an error. Every value gets at most one set-wrapper, and each member of a set-wrapper  represents a new constraint.&lt;/p&gt;

&lt;p&gt;To check a value against a set, for example when reading from a vector, check  each of the elements in any order. If an element raises an error, report it.* Alternatively, an implementation can check all the elements and report  all that disagree with the value.&lt;/p&gt;

&lt;p&gt;The heedful method is a compromise between forgetful and eidetic.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Unlike forgetful, heedful uses a new data structure to represent contacts  and requires some kind of &lt;code&gt;contract-stronger?&lt;/code&gt; predicate.  Heedful also remembers (some of) the history of a value and catches the  same errors as classic and eidetic contracts.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Unlike eidetic, heedful uses a simpler data structure with  no need to keep duplicate flat contracts  depending on the order they are encountered.  Heedful cannot, however, uniquely identify the two parties involved in a  contract error.  In general, there are multiple contracts that a programmer  must inspect to find the source of a mismatch.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;For details, see &lt;a href="https://arxiv.org/abs/1410.2813"&gt;the extended version&lt;/a&gt;  of Michael&amp;rsquo;s POPL 2015 paper. Don&amp;rsquo;t bother searching &lt;a href="http://www.cs.pomona.edu/~michael/papers/popl2015_space.pdf"&gt;the conference version&lt;/a&gt;  &amp;mdash; aside from one remark  in Appendix B, heedful and forgetful are nowhere to be found.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt; If an implementation promises to report one mismatch, instead of all  mismatches, then it does not need to keep the full set of contracts. Thanks to &lt;a href="http://mballantyne.net/"&gt;Michael Ballantyne&lt;/a&gt; for explaining  this to me.&lt;/p&gt;

&lt;h3 id="priorities-and-appearances"&gt;Priorities and Appearances&lt;/h3&gt;

&lt;p&gt;The extended version of &lt;em&gt;Space-Efficient Manifest Contracts&lt;/em&gt; introduces  the forgetful and heedful methods with extreme modesty. It&amp;rsquo;s tempting to skip past them and focus on the eidetic method.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&amp;ldquo;Since eidetic and classic contracts behave the same, why bother with forgetful and heedful? First and foremost, the calculi offer insights into the semantics of contracts: the soundness of forgetful depends on a certain philosophy of contracts; heedful relates to threesomes without blame [&lt;a href="https://dl.acm.org/citation.cfm?doid=1706299.1706342"&gt;Siek and Wadler 2010&lt;/a&gt;]. Second, we offer them as alternative points in the design space. Finally and perhaps cynically, they are strawmen&amp;mdash;warm up exercises for eidetic.&amp;rdquo; &amp;mdash; &lt;a href="https://arxiv.org/abs/1410.2813"&gt;&lt;em&gt;Space-Efficient Manifest Contracts&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;!-- Section 1, bottom of page 2--&gt;&lt;/blockquote&gt;

&lt;p&gt;And yet, at least two other research papers rely on these &amp;ldquo;strawmen&amp;rdquo; &amp;mdash; or  rather, the ideas behind the names.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://dl.acm.org/citation.cfm?id=3110285"&gt;&lt;em&gt;Gradual Typing with Union and Intersection Types&lt;/em&gt;&lt;/a&gt;,  at ICFP 2017,  demonstrates one technique for adding two varieties of types to a gradual  language. The semantics in the paper is forgetful;  if a higher-order value crosses multiple type boundaries,  the intermediate server obligations disappear.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&amp;ldquo;if a lambda abstraction is preceded by multiple casts, then the rule erases all of them, except for the last one&amp;rdquo; &amp;mdash; &lt;a href="https://dl.acm.org/citation.cfm?id=3110285"&gt;&lt;em&gt;Gradual Typing with Union and Intersection Types&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;!-- page 21--&gt;&lt;/blockquote&gt;

&lt;p&gt;This forgetfulness was a deliberate choice. A classic semantics would satisfy the same type soundness theorem,  but the authors picked forgetful for its simplicity and performance  implications.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&amp;ldquo;removing these casts preserves the soundness of the evaluation while reducing the number of them&amp;rdquo;&lt;/p&gt;
 &lt;p&gt;&amp;ldquo;while this choice makes the calculus simpler without hindering soundness, it yields a formalism unfit to finger culprits&amp;rdquo; &amp;mdash; &lt;a href="https://dl.acm.org/citation.cfm?id=3110285"&gt;&lt;em&gt;Gradual Typing with Union and Intersection Types&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;!-- p.27--&gt;&lt;!-- page 21--&gt;&lt;/blockquote&gt;
&lt;!-- The followup at POPL 2019 is not forgetful.--&gt;
&lt;!-- It's similar to eager coercions ... keep all types around and error--&gt;
&lt;!--  if there's a new type that doesn't match the old ones.--&gt;
&lt;!-- Also, that paper chooses not to let functions have intersection types,--&gt;
&lt;!--  which kind-of-avoids the questions ... but really the eagerness is key.--&gt;

&lt;p&gt;&lt;a href="https://dl.acm.org/citation.cfm?id=3009849"&gt;&lt;em&gt;Big Types in Little Runtime&lt;/em&gt;&lt;/a&gt;, at POPL 2017,  presents a gradual typing system that avoids the use of wrappers. Instead, their &lt;em&gt;transient&lt;/em&gt; semantics rewrites typed code ahead of time  to mimic the checks that forgetful contracts would perform. These checks suffice for a shallow type soundness theorem.&lt;/p&gt;

&lt;p&gt;That paper also introduces a heedful-like strategy for improving the error  messages produced by a forgetful check. The strategy adds a global map to the semantics;  keys in the map are unique identifiers for values (heap addresses),  and values are sets of types. When a value meets a compatible type, the type is added to the value&amp;rsquo;s set. When a mismatch occurs, the semantics &lt;a href="https://www.ccs.neu.edu/home/types/resources/notes/transient-undefined-blame-extract.pdf"&gt;tries to report&lt;/a&gt;  every type in the set that relates to the mismatch.&lt;/p&gt;

&lt;p&gt;And so, forgetful and heedful were edged out of POPL 2015 but managed to sneak in  to POPL 2017. Since then, forgetful appeared in ICFP 2017 and, briefly, in  &lt;a href="https://www2.ccs.neu.edu/racket/pubs/icfp18-gf.pdf"&gt;ICFP 2018&lt;/a&gt;. Where will we see them next?&lt;/p&gt;</description></item>
  <item>
   <title>The Behavior of Gradual Types: A User Study</title>
   <link>http://prl.ccs.neu.edu/blog/2018/12/11/the-behavior-of-gradual-types-a-user-study/?utm_source=migratory-typing&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2018-12-11-the-behavior-of-gradual-types-a-user-study</guid>
   <pubDate>Tue, 11 Dec 2018 19:50:33 UT</pubDate>
   <author>PRL</author>
   <description>&lt;!-- more--&gt;

&lt;blockquote&gt;
 &lt;p&gt;Note: this post is an extended abstract for the paper &lt;em&gt;The Behavior of Gradual Types: A User Study&lt;/em&gt; by Preston Tunnell&amp;mdash;Wilson, Ben Greenman, Justin Pombrio, and Shriram Krishnamurthi. For the full paper, datasets, and slides, &lt;a href="http://www.ccs.neu.edu/home/types/publications/publications.html#tgpk-dls-2018"&gt;click here&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The long-term goal of gradual typing is to build languages that offer the  &amp;ldquo;best&amp;rdquo; of both static and dynamic typing. Researchers disagree, however, on what the semantics of a mixed-typed language  should be; there are &lt;a href="/blog/2018/10/06/a-spectrum-of-type-soundness-and-performance/"&gt;at least three competing proposals&lt;/a&gt;  for combining a dynamically-typed language with a similar statically-typed language.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;It&amp;rsquo;s an interesting situation. There are dozens of papers on the semantics of gradual types&amp;mdash;and &lt;a href="http://www.ccs.neu.edu/home/types/resources/talks/tgpk-dls-2018.pdf"&gt;many claim&lt;/a&gt; to have developers in mind&amp;mdash;but zero papers that ask developers what they think.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;To help inform the discussion, we recently designed a &lt;a href="http://cs.brown.edu/research/plt/dl/dls2018"&gt;survey&lt;/a&gt;  to see what programmers think of three mixed-typed semantics. The survey is based on 8 example programs; we selected these 8 programs because the set as a whole tells the three mixed-typed semantics apart. For each program, the survey presents a few possible outcomes of running the  program and asks participants for their opinion on each outcome.&lt;/p&gt;

&lt;p&gt;The image below shows one program from the survey:&lt;/p&gt;

&lt;p&gt; &lt;img src="/img/gtsurvey-example-program.png" alt="Figure 1: example program" /&gt;&lt;/p&gt;

&lt;p&gt;This program creates an array, passes it between typed and untyped variables,  and performs write &amp;amp; read operations. What should happen when we run this program? One option is to ignore the type annotations and return the second element  of the array (&lt;code&gt;"bye"&lt;/code&gt;). A second option is to reject the write operation (on line 4) because it attempts  to write a number to a variable of type &lt;code&gt;Array(String)&lt;/code&gt;. A third option is to reject the assignment after the read operation (on line 5)  because it attempts to assign a string to a variable of type &lt;code&gt;Number&lt;/code&gt;. These are the three behaviors in the survey:&lt;/p&gt;

&lt;p&gt; &lt;img src="/img/gtsurvey-example-behaviors.png" alt="Figure 2: behaviors for the example question" /&gt;&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;A fourth option is to reject the assignment of an &lt;code&gt;Array(String)&lt;/code&gt; to a variable of type &lt;code&gt;Array(Number)&lt;/code&gt;. A few participants left comments asking for this behavior. See the &lt;a href="http://cs.brown.edu/research/plt/dl/dls2018"&gt;anonymized responses&lt;/a&gt; for their comments, and see &lt;a href="http://cs.brown.edu/~sk/Publications/Papers/Published/tgpk-beh-grad-types-user-study"&gt;the paper&lt;/a&gt; for why we left that behavior out.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For each behavior, we asked for respondents&amp;rsquo; preference along two independent dimensions:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Do you &lt;em&gt;like&lt;/em&gt; or &lt;em&gt;dislike&lt;/em&gt; this behavior?&lt;/li&gt;
 &lt;li&gt;Does it match your &lt;em&gt;expectation&lt;/em&gt; as a programmer?&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Combined, the dimensions lead to four possible &lt;em&gt;attitudes&lt;/em&gt;: Like and Expected,  Like and Unexpected, Dislike and Expected, Dislike and Unexpected. The full example question, with attitudes and space for comments, is below.&lt;/p&gt;

&lt;p&gt; &lt;img src="/img/gtsurvey-example-question.png" alt="Figure 3: complete question" /&gt;&lt;/p&gt;

&lt;p&gt;We administered the survey to three populations &amp;mdash; software engineers,  students, and Mechanical Turk workers &amp;mdash; and thereby collected three sets of  attitudes for each question. The results for the running example are below:&lt;/p&gt;

&lt;p&gt; &lt;img src="/img/gtsurvey-example-data.png" alt="Figure 4: results for Question 7" /&gt;&lt;/p&gt;

&lt;p&gt;The figure is a matrix of three columns (one for each population)  and three rows (one for each behavior). Each cell of the matrix contains a bar chart showing the attitudes  that we collected.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Unlike the survey question, the behaviors in the results are labeled as &lt;strong&gt;Deep&lt;/strong&gt;, &lt;strong&gt;Erasure&lt;/strong&gt;, and &lt;strong&gt;Shallow&lt;/strong&gt;. These names describe the three mixed-typed semantics.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For this question, the software engineers (left column, green bars)  mostly picked the &amp;ldquo;Dislike and Unexpected&amp;rdquo; attitude for every behavior. The students (mid column, blue bars) also show consensus on &amp;ldquo;Dislike and  Unexpected&amp;rdquo; for the &lt;strong&gt;Deep&lt;/strong&gt; and &lt;strong&gt;Erasure&lt;/strong&gt; behaviors; however, they are split  for the &lt;strong&gt;Shallow&lt;/strong&gt; behavior. The Mechanical Turk workers are divided on every behavior.&lt;/p&gt;

&lt;p&gt;See &lt;a href="http://cs.brown.edu/~sk/Publications/Papers/Published/tgpk-beh-grad-types-user-study"&gt;the paper&lt;/a&gt; for the other questions and responses.&lt;/p&gt;

&lt;p&gt;Overall, our main finding is that respondents preferred behaviors that enforced  full types and reported runtime mismatches as early as possible. The takeaway is thus:&lt;/p&gt;

&lt;p style="margin-left: 40px; margin-right: 40px"&gt;if you are designing a mixed-typed language and choose &lt;strong&gt;not&lt;/strong&gt; to enforce full types, then make sure to explain this behavior to users!&lt;/p&gt;

&lt;p&gt;Put lots of example programs in the language&amp;rsquo;s documentation. The programs in the survey can be adapted to explain how your chosen  behavior differs from alternatives.&lt;/p&gt;

&lt;h2 id="questions"&gt;Questions&lt;/h2&gt;

&lt;p&gt;Here are some good questions we&amp;rsquo;ve gotten that are not clearly answered in the paper.&lt;/p&gt;

&lt;h4 id="q-did-any-respondents-expect-more-than-one-behavior"&gt;Q. Did any respondents &amp;ldquo;expect&amp;rdquo; more than one behavior?&lt;/h4&gt;

&lt;p&gt;Yes, 59% &lt;!-- 20/34--&gt; of the software engineers and 82% &lt;!-- 14/17--&gt; of the students selected &amp;ldquo;Liked and Expected&amp;rdquo; and/or &amp;ldquo;Dislike and Expected&amp;rdquo; for different behaviors on the same program.&lt;/p&gt;
&lt;!-- They probably interpreted "Expected" as--&gt;
&lt;!--  "the program does something that makes sense", rather than--&gt;
&lt;!--  "the program does the one thing that I believe it should do".--&gt;
&lt;!-- ids for "double-expect" S.Es : R_24bz47lgcAOkCux R_2R4dZ1l0t3yx6fW R_b7yMVe7VtmmsrHb R_31MXSUfCyDE8FdG R_6LGXyOirYNtYWd3 R_2qyMZBAs74PrsSz R_2ASFRBh2jfuRgP1 R_1PUc0AUEzdXKGt8 R_2dL60N9oPIkbvWY R_1BXXqYyxH7R4r9l R_1ON2sxGalcODyAd R_1oyZasBudU5gKPS R_1FIHgkQbWGaxuHd R_b1s2YMBWCrCRvxf R_29t0zWxkQsfb9FT R_2fevZOrFGzS6JLf R_8Dn6NMjDyigT59n R_2pRG370z3cBUaKv R_2qDXTFI53ntWMu4 R_ZI8AwATueqyWwOR--&gt;
&lt;!-- ids for "double-expect" students : R_9B6WHWEX5l0DskN R_22VAu37cGWQPQx1 R_3hgYSaGy2tbyY3G R_3rTbAqgn1rhQK4d R_r3HqAP1yGRXHaZX R_1l05qvQ1sYOCcCF R_3qaMT9xR7CRYg2Y R_1Li0sGHkxk1VfcA R_24ITtgvBzg9RpE3 R_3HzshHbDWkayp4t R_5mtEFLtSX0iPVOp R_1IR6vdpmVw4OCqV R_2XpWlkKjH9LQqln R_DoQrROe0dcb1YJz--&gt;

&lt;h4 id="q-did-the-respondents-have-a-prior-preference-for-static-or-dynamic-typing"&gt;Q. Did the respondents have a prior preference for static or dynamic typing?&lt;/h4&gt;

&lt;p&gt;Near the end of the survey we asked: &amp;ldquo;Which do you prefer, typed or untyped programming?&amp;rdquo;. See table 2 of &lt;a href="http://cs.brown.edu/~sk/Publications/Papers/Published/tgpk-beh-grad-types-user-study"&gt;the paper&lt;/a&gt; for coded responses to this question,  or the &lt;a href="http://cs.brown.edu/research/plt/dl/dls2018"&gt;anonymized responses&lt;/a&gt; for the ground truth. Most preferred typed programming.&lt;/p&gt;</description></item>
  <item>
   <title>Java and Migratory Typing</title>
   <link>http://prl.ccs.neu.edu/blog/2018/12/02/java-and-migratory-typing/?utm_source=migratory-typing&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2018-12-02-java-and-migratory-typing</guid>
   <pubDate>Sun, 02 Dec 2018 14:41:53 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;The &lt;em&gt;transient&lt;/em&gt; approach to migratory typing (circa &lt;a href="http://homes.sice.indiana.edu/mvitouse/papers/dls14.pdf"&gt;2014&lt;/a&gt;)  is similar to type erasure in Java (circa &lt;a href="https://docs.oracle.com/javase/1.5.0/docs/relnotes/features.html"&gt;2004&lt;/a&gt;)  in a few interesting ways.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h2 id="migratory-typing"&gt;Migratory typing&lt;/h2&gt;

&lt;p&gt;The goal of &lt;em&gt;migratory typing&lt;/em&gt; is to enrich the type system of a language  without breaking backwards compatibility. Ideally, code that uses the enriched types:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;(G1) benefits from new ahead-of-time checks,&lt;/li&gt;
 &lt;li&gt;(G2) benefits from stronger run-time guarantees, and&lt;/li&gt;
 &lt;li&gt;(G3) may interact with all kinds of existing code.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;There are tradeoffs involved in the implementation of a migratory typing  system, however, and (as we will see) different implementations may focus on  different goals than the three above.&lt;/p&gt;

&lt;p&gt;A typical migratory typing system adds a static type checker to a dynamically  typed language (&lt;a href="/blog/2018/10/06/a-spectrum-of-type-soundness-and-performance/index.html"&gt;examples&lt;/a&gt;),  but one could also extend the type system of a statically-typed language;  for example, by &lt;a href="https://hal.inria.fr/hal-01629909v2"&gt;adding dependent types&lt;/a&gt;. In this sense, Java 1.5.0 is a migratory typing system for pre-generics Java. The addition of generic types enabled new ahead-of-time checks and maintained backwards  compatibility with existing Java code.&lt;/p&gt;

&lt;p&gt;Java&amp;rsquo;s implementation of migratory typing has some interesting things in common  with the &lt;em&gt;transient&lt;/em&gt; implementation strategy recently proposed by  Michael Vitousek and collaborators (&lt;a href="http://homes.sice.indiana.edu/mvitouse/papers/dls14.pdf"&gt;DLS&amp;rsquo;14&lt;/a&gt;, &lt;a href="https://mail.google.com/mail/u/0/h/1atrn21qlyrrh/?&amp;amp;"&gt;POPL&amp;rsquo;17&lt;/a&gt;). The goal of this post is to demonstrate the connections.&lt;/p&gt;

&lt;h2 id="erasure-migratory-typing"&gt;Erasure migratory typing&lt;/h2&gt;

&lt;p&gt;Before we compare Java 1.5.0 to transient, let&amp;rsquo;s review a simpler strategy:  the &lt;em&gt;erasure&lt;/em&gt; approach to migratory typing.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://www.typescriptlang.org/"&gt;TypeScript&lt;/a&gt; is a great (modern) example of the erasure approach. TypeScript is a migratory typing system for JavaScript. A TypeScript module gets validated by an ahead-of-time type checker and  compiles to JavaScript. After compilation, any JavaScript program may import bindings  from the generated code. Conversely, a TypeScript module may import bindings from a JavaScript module  by declaring a static type for each binding.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;The &lt;a href="http://definitelytyped.org/"&gt;DefinitelyTyped&lt;/a&gt; repository provides TypeScript type definitions for many JavaScript libraries.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The TypeScript compiler erases types;  every type &lt;code&gt;T&lt;/code&gt; in the source code translates to the universal &amp;ldquo;JavaScript type&amp;rdquo;. For instance, a TypeScript function declaration compiles to an untyped  JavaScript function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function (n0 : number, n1 : number) { return n0 + n1; })

// ==(compiles to)==&amp;gt;

(function (n0, n1) { return n0 + n1; })&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TypeScript satisfies goals &lt;strong&gt;G1&lt;/strong&gt; and &lt;strong&gt;G3&lt;/strong&gt; for a migratory typing system  because its type checker adds ahead-of-time checks and its  compiler outputs JavaScript. TypeScript does not satisfy goal &lt;strong&gt;G2&lt;/strong&gt; because the compiler erases types. In terms of the example above, the compiled function may be invoked with any  pair of JavaScript values; the variable &lt;code&gt;n0&lt;/code&gt; is not guaranteed to point  to a &lt;code&gt;number&lt;/code&gt; at run-time. On one hand, this means the type annotations have no effect on the behavior  of a program &amp;mdash; and in particular, cannot be trusted for debugging. On the other hand, it means that an experienced JavaScript programmer can  re-use their knowledge to predict the behavior of a TypeScript program.&lt;/p&gt;

&lt;p&gt;In an ordinary program, the run-time guarantees of TypeScript are simply  the run-time guarantees of JavaScript:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;if a TypeScript expression &lt;code&gt;e&lt;/code&gt; has the static type &lt;code&gt;T&lt;/code&gt; and evaluates to  a value &lt;code&gt;v&lt;/code&gt;,  then the only guarantee is that &lt;code&gt;v&lt;/code&gt; is a valid JavaScript value  (e.g., &lt;code&gt;T&lt;/code&gt; could be &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; could be an incompatible object).&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="transient-migratory-typing"&gt;Transient migratory typing&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/mvitousek/reticulated"&gt;Reticulated&lt;/a&gt; is a migratory typing  system for Python that follows a &lt;em&gt;transient&lt;/em&gt; implementation strategy. A Reticulated module gets type-checked and compiles to a Python module that  defends itself from certain type-invalid inputs through the use of  assertions that run in near-constant time. The type-checking addresses goal &lt;strong&gt;G1&lt;/strong&gt;,  the compilation to Python provides interoperability (goal &lt;strong&gt;G3&lt;/strong&gt;),  and the assertions partially meet goal &lt;strong&gt;G2&lt;/strong&gt;.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;These &lt;em&gt;certain&lt;/em&gt; inputs are the ones that would cause a standard typed operational semantics to reach an undefined state. For a discussion of &lt;em&gt;near-constant&lt;/em&gt;, see &lt;a href="http://www.ccs.neu.edu/home/types/publications/publications.html#gm-pepm-2018"&gt;&lt;em&gt;On the Cost of Type-Tag Soundness&lt;/em&gt;, section 2&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For example, here is a Reticulated function  that computes the average of a list of numbers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Reticulated (commit e478343)
def average(nums : List(Float)) -&amp;gt; Float:
  if ns:
    return sum(ns) / len(ns)
  else:
    raise ValueError("average: expected non-empty list")&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and here is the Python code it compiles to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from retic.runtime import *
from retic.transient import *
from retic.typing import *

def average(nums):
    check_type_list(nums)
    if ns:
        return check_type_float((check_type_function(sum)(ns) / check_type_function(len)(ns)))
    else:
        raise check_type_function(ValueError)('average: expected non-empty list')&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
 &lt;p&gt;Note: the Reticulated syntax for type annotations is similar to the one proposed in &lt;a href="https://www.python.org/dev/peps/pep-0484/"&gt;PEP 484&lt;/a&gt;, but not identical. For example, Reticulated does not require forward references to be embedded in strings.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The Reticulated compiler removes all type annotations and inserts &lt;code&gt;check_type&lt;/code&gt;  assertions throughout the code. In &lt;code&gt;average&lt;/code&gt;, these assertions check that: (1) the input is a list,  (2) the output is a &lt;code&gt;float&lt;/code&gt;, (3) and the names &lt;code&gt;sum&lt;/code&gt; &lt;code&gt;len&lt;/code&gt; and  &lt;code&gt;ValueError&lt;/code&gt; point to callable values. That&amp;rsquo;s all. The assertions &lt;strong&gt;do not check&lt;/strong&gt; that &lt;code&gt;nums&lt;/code&gt; contains only floating-point  numbers.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;The assertions also do not check that the function bound to &lt;code&gt;sum&lt;/code&gt; is defined for a single argument, which is arguably a bug. Scaling a model to an implementation is always challenging.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If &lt;code&gt;nums&lt;/code&gt; contains something other than floating point numbers, then the  call to &lt;code&gt;average&lt;/code&gt; may cause &lt;code&gt;sum&lt;/code&gt; to raise an exception or it may silently  compute a nonsense result. The behavior depends on the implementation of &lt;code&gt;sum&lt;/code&gt; in the same way that  the behavior of a TypeScript function depends on any JavaScript functions  that it invokes.&lt;/p&gt;

&lt;p&gt;Reticulated does not erase types, nor does it fully enforce types. Every type in a Reticulated module translates to its  top-level type constructor &lt;code&gt;C(T)&lt;/code&gt;, e.g.:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  C(Float)                = Float
  C(List(Float))          = List
  C(List(Float) -&amp;gt; Float) = -&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Consequently, Reticulated has a slightly stronger run-time guarantee than Python:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;if &lt;code&gt;e&lt;/code&gt; is an expression with static type &lt;code&gt;T&lt;/code&gt; that evaluates to a value &lt;code&gt;v&lt;/code&gt;,  then &lt;code&gt;v&lt;/code&gt; is guaranteed to have a top-level shape that matches the &lt;code&gt;C(T)&lt;/code&gt;  constructor.&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="java-migratory-typing"&gt;Java migratory typing&lt;/h2&gt;

&lt;p&gt;Java 1.5.0 added &lt;a href="https://www.jcp.org/en/jsr/detail?id=14"&gt;generic types&lt;/a&gt;  to the Java 1.4.0 type system. The benefit of generics is that a programmer can:  write one class definition,  use the definition in a few different contexts,  and receive specific feedback from the type checker in each context.&lt;/p&gt;

&lt;h3 id="review-generic-types"&gt;Review: generic types&lt;/h3&gt;

&lt;p&gt;Suppose we want to write a &lt;code&gt;Box&lt;/code&gt; class that holds some kind of value;  the value could be an &lt;code&gt;Integer&lt;/code&gt; or a &lt;code&gt;String&lt;/code&gt; or anything else. Here is a pre-generics definition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Box {
  private Object val;

  public Box(Object val) { this.set(val); }

  public void set(Object val) { this.val = val; }

  public Object get() { return this.val; }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this definition is it possible to make boxes that hold different types  of values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// good!
Box iBox = new Box(new Integer(4));
Box sBox = new Box(new String("X"));&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but it is also possible to &amp;ldquo;change the type&amp;rdquo; of the contents of a &lt;code&gt;Box&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// maybe bad!
iBox.set(new String("not a number"));&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and some calls to &lt;code&gt;get&lt;/code&gt; must be followed by a type cast:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// annoying!
((String) sBox.get()).charAt(0);&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;With generics, we can give a name (e.g. &lt;code&gt;ValType&lt;/code&gt;) to &amp;ldquo;the type of the value inside a box&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class GBox&amp;lt;ValType&amp;gt; {
  private ValType val;

  public GBox(ValType val) { this.set(val); }

  public void set(ValType val) { this.val = val; }

  public ValType get() { return this.val; }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and now we can tell the type checker to check different boxes differently (satisfying goal &lt;strong&gt;G1&lt;/strong&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GBox&amp;lt;Integer&amp;gt; iBox = new GBox&amp;lt;Integer&amp;gt;(new Integer(0));
GBox&amp;lt;String&amp;gt; sBox = new GBox&amp;lt;String&amp;gt;(new String("A"));

// iBox.set(new String("not a number")); // Type Error, good!

sBox.get().charAt(0); // no cast, good!&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="backwards-compatibility--danger"&gt;Backwards compatibility &amp;amp; danger&lt;/h3&gt;

&lt;p&gt;Java generics are backwards-compatible with older code (goal &lt;strong&gt;G3&lt;/strong&gt;). This means that pre-generics code can interact with instances of a generic  class. Vice-versa, generic code can interact with pre-generics classes. Since pre-generics code is not aware of type parameters, these interactions  are potentially unsafe. For example, a pre-generics method can change the type of a &lt;code&gt;GBox&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Java 1.4.0 method
public static void evil(GBox b) { b.set(666); }

// Java 1.5.0 method
public static void test() {
  GBox&amp;lt;String&amp;gt; sBox = new GBox&amp;lt;String&amp;gt;(new String("A"));
  evil(sBox); // OK, but generates unchecked warning
  sBox.get().charAt(0);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above passes the type checker (with a warning about the &lt;code&gt;evil&lt;/code&gt; method),  and so it &lt;em&gt;seems&lt;/em&gt; as though running the code will run the nonsense  method call &lt;code&gt;666.charAt(0)&lt;/code&gt; and lead to evil behavior. The actual result, however, is a cast error immediately after the call  &lt;code&gt;sBox.get()&lt;/code&gt; returns.&lt;/p&gt;

&lt;p&gt;Based on the cast error, we can tell that  the compiler does not trust the type &lt;code&gt;GBox&amp;lt;String&amp;gt;&lt;/code&gt; and  inserts a run-time check that the result of the &lt;code&gt;.get()&lt;/code&gt; is a string object.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&amp;ldquo;Calling legacy code from generic code is inherently dangerous; once you mix generic code with non-generic legacy code, all the safety guarantees that the generic type system usually provides are void.&amp;rdquo; &lt;a href="https://www.oracle.com/technetwork/java/javase/generics-tutorial-159168.pdf"&gt;Generics in the Java Programming Language, Section 6.1&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3 id="java-type-erasure"&gt;Java Type Erasure&lt;/h3&gt;

&lt;p&gt;In order to support pre-generics and post-generics code on the same  &lt;a href="https://docs.oracle.com/javase/specs/jvms/se11/html/index.html"&gt;virtual machine&lt;/a&gt;,  the Java compiler &lt;a href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.6"&gt;erases&lt;/a&gt;  generic type parameters after type-checking. Everywhere that the compiled code depends on an erased type, such as the  &lt;code&gt;String&lt;/code&gt; in &lt;code&gt;GBox&amp;lt;String&amp;gt;&lt;/code&gt; above, Java adds a cast to prove to the Java Virtual Machine (JVM)  that the erased bytecode is type-safe. (A smarter JVM type system might be able to prove that some casts are  unnecessary via &lt;a href="https://www2.ccs.neu.edu/racket/pubs/icfp10-thf.pdf"&gt;occurrence typing&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;After erasure, the &lt;code&gt;GBox&amp;lt;ValType&amp;gt;&lt;/code&gt; class declaration loses its parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Erase `ValType`, replace with `Object`
class GBox {
  private Object val;

  public GBox(Object val) { this.set(val); }

  public void set(Object val) { this.val = val; }

  public Object get() { return this.val; }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the client code gains a cast:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GBox sBox = new GBox(new String("A"));

((String) sBox.get()).charAt(0);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, so good. But it&amp;rsquo;s worth noting that erasure can cause problems with Java arrays. An array needs to know the run-time type of its elements, so the following &amp;ldquo;natural&amp;rdquo; definition of an &lt;code&gt;ArrayList&lt;/code&gt; is not permitted:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class ArrayList&amp;lt;T&amp;gt; {
  private T[] data;
  private int size;

  public ArrayList(int capacity) {
    data = new T[capacity];
    size = 0;
  }

  public T get(int ix) {
    // TODO bounds check
    return data[ix]
  }

  // ....
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The trouble is that &lt;code&gt;T&lt;/code&gt; does not say anything about the data that a new array needs to handle:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ArrayList.java:6: error: generic array creation
    data = new T[capacity];&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only work-arounds require an array of objects and unchecked casts. One solution is to unsafely cast the array to the generic type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  // possibly dangerous, if `data` is aliased to an `Object[]`
  public ArrayList(int capacity) {
    data = (T[]) new Object[capacity];
    size = 0;
  }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The other is to unsafely cast array elements in the &lt;code&gt;get&lt;/code&gt; method, and elsewhere:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class ArrayList&amp;lt;T&amp;gt; {
  private Object[] data;
  private int size;

  public ArrayList(int capacity) {
    data = new Object[capacity];
    size = 0;
  }

  public T get(int ix) {
    boundsCheck(ix);
    return (T) data[ix];
  }

  // ....
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both may potentially lead to &lt;a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/TechnicalDetails.html#FAQ050"&gt;heap pollution&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;"The decision not to make all generic types [not erased] is one of the most crucial, and controversial design decisions involving the type system of the Java programming language.&lt;/p&gt;
 &lt;p&gt;"Ultimately, the most important motivation for this decision is compatibility with existing code." &lt;a href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.7"&gt;Java Language Specification, section 4.7&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3 id="run-time-guarantees"&gt;Run-time guarantees&lt;/h3&gt;

&lt;p&gt;By contrast to Reticulated&amp;rsquo;s &lt;code&gt;C(T)&lt;/code&gt; transformation, the following &lt;code&gt;G(T)&lt;/code&gt;  transformation describes generic-type erasure,  where &lt;code&gt;T&amp;lt;T1&amp;gt;&lt;/code&gt; describes a type &lt;code&gt;T&lt;/code&gt; with parameter &lt;code&gt;T1&lt;/code&gt;  and &lt;code&gt;A[T1, T2]&lt;/code&gt; describes a type variable &lt;code&gt;A&lt;/code&gt; with lower bound &lt;code&gt;T1&lt;/code&gt; and upper bound &lt;code&gt;T2&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  G(T&amp;lt;T1&amp;gt;)     = G(T)
  G(A[T1, T2]) = G(T1)
  G(T)         = T      otherwise&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If generic-type erasure results in a type mismatch (e.g., in &lt;code&gt;sBox.get().charAt(0)&lt;/code&gt; above),  the compiler inserts a cast. The inserted casts led to the run-time error in the previous example, and  provide the following run-time guarantee:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;if &lt;code&gt;e&lt;/code&gt; is an expression with static type &lt;code&gt;T&lt;/code&gt; that evaluates to a value &lt;code&gt;v&lt;/code&gt;,  then &lt;code&gt;v&lt;/code&gt; is guaranteed to match the (bytecode) type &lt;code&gt;G(T)&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="discussion"&gt;Discussion&lt;/h2&gt;

&lt;p&gt;TypeScript, Reticulated Python, and Java 1.5.0 each improved the type system  of an existing language, but maintained backwards compatibility with existing  code. The name &lt;a href="http://drops.dagstuhl.de/opus/volltexte/2017/7120/"&gt;migratory typing&lt;/a&gt;  describes this kind of language extension.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;a href="http://drops.dagstuhl.de/opus/volltexte/2015/5031/"&gt;Gradual typing&lt;/a&gt; is a similar; a gradual type system starts with a statically-typed language and adds dynamic typing in a principled way (&lt;a href="https://pleiad.cl/papers/2016/garciaAl-popl2016.pdf"&gt;example&lt;/a&gt;).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The TypeScript team had a choice between erasing types and enforcing types. They chose to erase types and run all code (typed or untyped) at the level  of JavaScript. (Some TypeScript &lt;a href="https://lorefnon.tech/2018/03/25/typescript-and-validations-at-runtime-boundaries/"&gt;libraries&lt;/a&gt;, however, can enforce some types.)&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;TypeScript is not the only erasure language, nor is it the first. The oldest (I think) is &lt;a href="http://www.softwarepreservation.org/projects/LISP/maclisp_family/"&gt;MACLISP&lt;/a&gt;. For an erasure manifesto, see &lt;a href="http://bracha.org/pluggableTypesPosition.pdf"&gt;Pluggable Type Systems&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The Reticulated team faced an analogous choice, and chose to enforce the top-level  shape of values in typed code (&lt;a href="http://homes.sice.indiana.edu/mvitouse/papers/popl17.pdf"&gt;POPL 2017&lt;/a&gt;). It will be interesting to see if this guarantee helps developers maintain programs,  or if it is too shallow to be much use. The &lt;a href="https://www.pyret.org/index.html"&gt;Pyret&lt;/a&gt; language has been successful with  comparable shallow checks.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Note: the POPL 2017 paper advertises an &amp;ldquo;open-world soundness&amp;rdquo;, but I do not see how this idea is different from the older idea of soundness in a multi-language system (&lt;a href="https://www.eecs.northwestern.edu/~robby/pubs/papers/toplas09-mf.pdf"&gt;TOPLAS 2009&lt;/a&gt;, &lt;a href="https://www2.ccs.neu.edu/racket/pubs/dls06-tf.pdf"&gt;DLS 2006&lt;/a&gt;).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Similarly, the Java team chose to erase generic types in Java 1.5.0 and use shallow casts in the JVM. The casts around type-erased generics provide a minimal level of safety &amp;mdash;  enough to prevent the use of a generic object from corrupting the state of a  VM instance.&lt;/p&gt;

&lt;p&gt;Alternatively, Java could enforce full generic types at run-time. Over the years there have been a few proposals to do so (&lt;a href="http://gafter.blogspot.com/2006/11/reified-generics-for-java.html"&gt;example 1&lt;/a&gt;,  &lt;a href="https://wiki.openjdk.java.net/display/valhalla/Main"&gt;example 2&lt;/a&gt;). The C# language has a similar type system and enforces  generics at run-time (sources:  &lt;a href="https://mattwarren.org/2018/03/02/How-generics-were-added-to-.NET/"&gt;blog post&lt;/a&gt;,  &lt;a href="https://www.microsoft.com/en-us/research/publication/design-and-implementation-of-generics-for-the-net-common-language-runtime/"&gt;PLDI 2001 paper&lt;/a&gt;,  &lt;a href="https://dl.acm.org/citation.cfm?doid=378795.378797"&gt;backup link to paper&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id="acknowledgments"&gt;Acknowledgments&lt;/h2&gt;

&lt;p&gt;Thank you to &lt;a href="https://github.com/rmculpepper"&gt;Ryan Culpepper&lt;/a&gt; and &lt;a href="http://users.eecs.northwestern.edu/~jesse/"&gt;Jesse Tov&lt;/a&gt; for noticing the similarity between  Java&amp;rsquo;s generic-type erasure and transient migratory typing. Jesse commented on an early version of this post, supplied new Java example code, and explained the trouble with generics and arrays.&lt;/p&gt;</description></item>
  <item>
   <title>A Spectrum of Type Soundness and Performance</title>
   <link>http://prl.ccs.neu.edu/blog/2018/10/06/a-spectrum-of-type-soundness-and-performance/?utm_source=migratory-typing&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2018-10-06-a-spectrum-of-type-soundness-and-performance</guid>
   <pubDate>Sat, 06 Oct 2018 11:23:35 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;The literature on mixed-typed languages presents (at least) three fundamentally different ways of thinking about the integrity of programs that combine  statically typed and dynamically typed code. Recently, we have been sorting them out.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;blockquote&gt;
 &lt;p&gt;Note: this post is an extended abstract for the paper &lt;em&gt;A Spectrum of Type  Soundness and Performance&lt;/em&gt; by Ben Greenman and Matthias Felleisen.  For the full paper, slides, code, and a video presentation, visit  &lt;a href="http://www.ccs.neu.edu/home/types/publications/publications.html#gf-icfp-2018"&gt;http://www.ccs.neu.edu/home/types/publications/publications.html#gf-icfp-2018&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;A dynamically-typed language runs any program that &amp;ldquo;looks good&amp;rdquo; (i.e.,  passes some basic syntactic criteria. In Python a program cannot mix  indentation levels. In Racket a program cannot refer to unbound variables). A statically-typed language runs any program that both &amp;ldquo;looks good&amp;rdquo; and  is well-typed according to a type checker.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;mixed-typed&lt;/em&gt; language allows some combination of static and dynamic typing. There are many languages that fall in the mixed-typed category; figure 1 lists  a few, roughly arranged left-to-right by the year they first provided a way to  mix.&lt;/p&gt;

&lt;div class="figure"&gt;&lt;img src="/img/mixed-typed-systems-by-year.png" alt="Figure 1: Some mixed-typed languages" /&gt;
 &lt;p class="caption"&gt;Figure 1: Some mixed-typed languages&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;These languages all try to combine static and dynamic typing in a useful way,  but they take VERY different approaches. For example:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;strong&gt;MACLISP&lt;/strong&gt; defines a syntax for type annotations but does not say how a compiler  should interpret the types; see section 14.2 of the &lt;a href="http://www.softwarepreservation.org/projects/LISP/MIT/Moon-MACLISP_Reference_Manual-Apr_08_1974.pdf"&gt;Moonual&lt;/a&gt;.  For example, a compiler may use types to generate specialized code that assumes  the type annotations are correct (and has undefined behavior otherwise).&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Strongtalk&lt;/strong&gt; includes a static type checker and DOES NOT use types to change the  behavior of a program.  For rationale, see the &lt;a href="http://bracha.org/pluggableTypesPosition.pdf"&gt;Pluggable Type Systems&lt;/a&gt; position paper.&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Typed Racket&lt;/strong&gt; lets a program combine statically-typed modules and dynamically-typed  modules. The compiler inserts run-time checks at the boundaries between such  modules to detect any mismatches between the static types and incoming dynamically-typed  values.&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Thorn&lt;/strong&gt; requires that every value in a program has a type, but allows  dynamically-typed contexts to manipulate values. In other words, every Thorn  value is an instance of a statically-declared class and classes may contain  dynamically-typed methods.&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Reticulated&lt;/strong&gt; lets a program combine static and dynamic &lt;em&gt;expressions&lt;/em&gt; and  guarantees that the combination has a well-defined semantics (Vitousek, Swords, and Siek &lt;a href="https://dl.acm.org/citation.cfm?id=3009849"&gt;POPL 2017&lt;/a&gt;).&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;That makes five different systems. There are 15 other systems in the figure, and many more in the world. How can we make sense of this space? We claim: by understanding each system&amp;rsquo;s protocol for checking  dynamically-typed values at a &lt;em&gt;type boundary&lt;/em&gt; (between static and dynamic code).&lt;/p&gt;

&lt;h3 id="main-contribution"&gt;Main Contribution&lt;/h3&gt;

&lt;p&gt;In the paper &lt;a href="http://drops.dagstuhl.de/opus/volltexte/2015/5031/"&gt;&lt;em&gt;A Spectrum of Type Soundness and Performance&lt;/em&gt;&lt;/a&gt;,  we define a tiny mixed-typed language and show three ways to define the  behavior of programs &amp;mdash; based on three protocols for checking  dynamically-typed values that cross a boundary into statically-typed code.&lt;/p&gt;

&lt;p&gt;The three behaviors are inspired by existing languages. A &lt;strong&gt;higher order&lt;/strong&gt; behavior ensures that dynamically-typed  values match the static type at a boundary &amp;mdash; by checking the value when possible,  and by monitoring the value&amp;rsquo;s future interactions when necessary. A &lt;strong&gt;first order&lt;/strong&gt; behavior performs a yes-or-no check on dynamically-typed values  and never monitors their future behavior. An &lt;strong&gt;erasure&lt;/strong&gt; behavior does no checking whatsoever.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Example (monitors): if typed code expects a function from numbers to numbers and receives an untyped function &lt;code&gt;f&lt;/code&gt;, then one way to enforce the type boundary is to wrap &lt;code&gt;f&lt;/code&gt; in a proxy to assert that every future call to &lt;code&gt;f&lt;/code&gt; returns a number. In this case, the proxy monitors the behavior of &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Concretely, the paper defines three formal semantics with the same names. The &lt;strong&gt;higher-order&lt;/strong&gt; semantics enforces full types at the boundaries (Section 2.3). The &lt;strong&gt;first-order&lt;/strong&gt; semantics enforces type constructors at the boundaries, and  furthermore enforces type constructors on every &amp;ldquo;selector&amp;rdquo; operation in typed  code, e.g., function application, data structure access (Section 2.5). The &lt;strong&gt;erasure&lt;/strong&gt; semantics simply ignores the types (Section 2.4).&lt;/p&gt;

&lt;p&gt;Each semantics satisfies a &lt;em&gt;different&lt;/em&gt; notion of soundness for mixed-typed  programs, and each notion is slightly weaker than soundness for fully-typed  programs. The paper states these theorems (Section 2) and the  &lt;a href="https://repository.library.northeastern.edu/files/neu:cj82rk279"&gt;online supplement&lt;/a&gt;  gives full proofs.&lt;/p&gt;

&lt;p&gt;The paper has more to say about the meta-theory. See section 2 and section 4.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;To the best of our knowledge, this paper is the first to explicitly acknowledge that different approaches to a mixed-typed language lead to different notions of soundness. Other papers state type soundness theorems for &lt;a href="https://dl.acm.org/citation.cfm?id=2676971"&gt;subset of the language&lt;/a&gt; (in the spirit of &lt;a href="http://soundiness.org/"&gt;soundiness&lt;/a&gt;) or use the name &amp;ldquo;type soundness&amp;rdquo; to describe &lt;a href="https://dl.acm.org/citation.cfm?id=2676971"&gt;a different property&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Next, we used the three semantics as a guide to arrive at three compilers for  Typed Racket. The higher-order compiler is the standard Typed Racket. The first-order compiler is something we built, based on the semantics. The erasure compiler simply ignores the type annotations &amp;mdash; similar to Typed Racket&amp;rsquo;s  &lt;a href="http://docs.racket-lang.org/ts-reference/Typed_Racket_Syntax_Without_Type_Checking.html"&gt;no-check&lt;/a&gt; language.&lt;/p&gt;

&lt;p&gt;Using this set-up, we measured the performance of mixed-typed programs via  each compiler using the method suggested by Takikawa et. al (&lt;a href="https://www2.ccs.neu.edu/racket/pubs/popl16-tfgnvf.pdf"&gt;POPL 2016&lt;/a&gt;). The programs we measured are the non-object-oriented ones from our &lt;a href="http://docs.racket-lang.org/gtp-benchmarks/index.html"&gt;benchmark suite&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To some extent, the performance results confirm conjectures from the literature. The full results, however, include many surprises &amp;mdash; see section 3 of the paper,  section B of the &lt;a href="https://repository.library.northeastern.edu/files/neu:cj82rk279"&gt;supplement&lt;/a&gt;,  and/or the &lt;a href="http://www.ccs.neu.edu/home/types/publications/apples-to-apples/gf-icfp-2018-slides.pdf"&gt;slides&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id="implications"&gt;Implications&lt;/h3&gt;

&lt;ol&gt;
 &lt;li&gt;The model in the paper is one way to understand the different approaches  to mixed-typed languages. See section 5 of the paper,  section D of the &lt;a href="https://repository.library.northeastern.edu/files/neu:cj82rk279"&gt;supplement&lt;/a&gt;,  or &lt;a href="http://www.ccs.neu.edu/home/types/publications/apples-to-apples/gf-icfp-2018-slides.pdf"&gt;slide 114&lt;/a&gt;.&lt;/li&gt;
 &lt;li&gt;Programmers using mixed-typed languages need to know what guarantees their  types provide.  (It is &lt;a href="https://twitter.com/jbandi/status/965005464638541825"&gt;not safe to assume that TypeScript types give the same guarantees as OCaml types&lt;/a&gt;!)  Section 4 of the paper contains many examples of how the different guarantees  may affect practice.&lt;/li&gt;
 &lt;li&gt;The relative performance of different approaches is more nuanced than the  literature suggests. Our paper gives a first systematic comparison based on  implementations that have clear areas for improvement. The question is:  can we find improvements that lead to asymptotic differences, or is it a  battle for constant factors?&lt;/li&gt;&lt;/ol&gt;

&lt;blockquote&gt;
 &lt;p&gt;Note: in this post, a &lt;em&gt;mixed-typed language&lt;/em&gt; is one that allows any combination of static and dynamic typing. A &lt;em&gt;gradually-typed language&lt;/em&gt; is one that allows a certain kind of mixing that satisfies properties defined by Siek, Vitousek, Cimini, and Boyland (&lt;a href="http://drops.dagstuhl.de/opus/volltexte/2015/5031/"&gt;SNAPL 2015&lt;/a&gt;).&lt;/p&gt;&lt;/blockquote&gt;</description></item>
  <item>
   <title>Sampling Gradual Typing Performance</title>
   <link>http://prl.ccs.neu.edu/blog/2018/05/08/sampling-gradual-typing-performance/?utm_source=migratory-typing&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2018-05-08-sampling-gradual-typing-performance</guid>
   <pubDate>Tue, 08 May 2018 15:37:37 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;This post explains the sampling method introduced in the paper &lt;a href="http://www.ccs.neu.edu/home/types/publications/publications.html#gm-pepm-2018"&gt;&lt;em&gt;On the Cost of Type-Tag Soundness&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h2 id="quick-reference-how-to-apply-the-method"&gt;Quick Reference: How to apply the method&lt;/h2&gt;

&lt;ol&gt;
 &lt;li&gt;Find an untyped program, measure its running time.&lt;/li&gt;
 &lt;li&gt;Define a &lt;em&gt;granularity&lt;/em&gt; for type annotations (by-function, by-module, by-program, &amp;hellip;.).&lt;/li&gt;
 &lt;li&gt;Define a sample size &lt;strong&gt;s&lt;/strong&gt; and number of samples &lt;strong&gt;r&lt;/strong&gt;.&lt;/li&gt;
 &lt;li&gt;Randomly select &lt;strong&gt;s&lt;/strong&gt; &lt;em&gt;configurations&lt;/em&gt; uniformly at random, measure their running time.&lt;/li&gt;
 &lt;li&gt;Repeat the previous step &lt;strong&gt;r&lt;/strong&gt; times.&lt;/li&gt;
 &lt;li&gt;Pick a positive real number &lt;strong&gt;D&lt;/strong&gt;.&lt;/li&gt;
 &lt;li&gt;Count the proportion of configurations in each sample with running time less-than-or-equal-to &lt;strong&gt;D&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;Build a 95% confidence interval for the &lt;strong&gt;r&lt;/strong&gt; proportions computed in the previous step&lt;/li&gt;
 &lt;li&gt;Conclusion: there is a good chance that your interval contains the true proportion of configurations with running time less-than-or-equal-to &lt;strong&gt;D&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;h2 id="background-what-to-measure"&gt;Background: what to measure&lt;/h2&gt;

&lt;p&gt;A migratory typing system adds static typing to a dynamically-typed (or, untyped) language. The recipe for &amp;ldquo;adding static typing&amp;rdquo; has a few steps:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;add a syntax for type annotations&lt;/li&gt;
 &lt;li&gt;add a static type checker&lt;/li&gt;
 &lt;li&gt;add a semantics for statically-typed parts of the program&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;If the semantics for statically-typed parts of the program is &lt;strong&gt;not&lt;/strong&gt; the same  as the semantics for dynamically-typed parts, then it is important to measure  performance.&lt;/p&gt;

&lt;p&gt;The key question is: how does adding type annotations affect the  running time of a working program? We do not know how to answer this question directly.&lt;/p&gt;

&lt;p&gt;An easier question, that we can answer, is: for a few programs each with  one full set of type annotations, how does adding or removing the chosen type  annotations affect the running time of these programs?&lt;/p&gt;

&lt;p&gt;The next two sections give two methods for answering this question.&lt;/p&gt;

&lt;h2 id="exhaustive-method"&gt;Exhaustive Method&lt;/h2&gt;

&lt;p&gt;One way to answer our easier question is to remove type annotations one  &amp;ldquo;unit&amp;rdquo; at a time and measure the running time of all these partially-typed  programs. We call the &amp;ldquo;unit&amp;rdquo; the &lt;em&gt;granularity&lt;/em&gt; of the performance evaluation. For example, some choices for granularity are to remove types one module  at a time, to remove types one function at a time, or to remove types  one variable at a time. We call the &amp;ldquo;partially-typed programs&amp;rdquo; the &lt;em&gt;configurations&lt;/em&gt; of the original  dynamically-typed program. Note that the number of configurations depends on the choice of granularity  &amp;mdash; I can&amp;rsquo;t just use the word &lt;em&gt;configurations&lt;/em&gt; without telling you the  granularity I have in mind.&lt;/p&gt;

&lt;p&gt;After measuring the running time of all configurations, we can summarize the  results. One way to summarize is to pick a number &lt;strong&gt;D&lt;/strong&gt; and count the number of configurations  that run at most &lt;strong&gt;D&lt;/strong&gt; times slower than the original dynamically-typed program. If this number is large, then the takeaway is:  if &lt;em&gt;you&lt;/em&gt; are willing to accept at most a &lt;strong&gt;D&lt;/strong&gt;x slowdown, and you add your  own type annotations to your own program, then there&amp;rsquo;s some hope that your  configuration runs at most &lt;strong&gt;D&lt;/strong&gt; times slower than your original program.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Credit for the exhaustive method: &lt;a href="https://www2.ccs.neu.edu/racket/pubs/popl16-tfgnvf.pdf"&gt;&lt;em&gt;Is Sound Gradual Typing Dead?&lt;/em&gt;&lt;/a&gt; and &lt;a href="https://www2.ccs.neu.edu/racket/pubs/ecoop2015-takikawa-et-al.pdf"&gt;&lt;em&gt;Toward Practical Gradual Typing&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2 id="simple-random-approximation-method"&gt;Simple Random Approximation Method&lt;/h2&gt;

&lt;p&gt;The method above does not scale to large programs or fine granularities  because it asks for an exponential number of measurements. E.g., if there are 20 units to add or remove types from, then there are 1 million  configurations to measure. Exponentials are bad.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://www.ccs.neu.edu/home/types/publications/publications.html#gm-pepm-2018"&gt;&lt;em&gt;On the Cost of Type-Tag Soundness&lt;/em&gt;&lt;/a&gt;,  suggests a method based on simple random sampling that answers a similar question. Instead of measuring the true proportion of configurations that run at most  &lt;strong&gt;D&lt;/strong&gt; times slower than the original dynamically-typed program, we:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;pick a sample size &lt;strong&gt;s&lt;/strong&gt; (in the paper, we used &lt;strong&gt;s = 10M&lt;/strong&gt; where &lt;strong&gt;M&lt;/strong&gt; is the number of units),&lt;/li&gt;
 &lt;li&gt;pick a number of samples &lt;strong&gt;r&lt;/strong&gt; (in the paper, we used &lt;strong&gt;r = 10&lt;/strong&gt;),&lt;/li&gt;
 &lt;li&gt;and build a 95% confidence interval for the true proportion of configurations  that run at most &lt;strong&gt;D&lt;/strong&gt; times slower than the original program (from the  &lt;strong&gt;r&lt;/strong&gt; proportions of configurations that run at most &lt;strong&gt;D&lt;/strong&gt; times slower than the  original program in each of the &lt;strong&gt;r&lt;/strong&gt; samples).&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The method is outlined above, described in the paper, and validated in that paper&amp;rsquo;s appendix. Please let us know if you have more questions.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Maybe you&amp;rsquo;re wondering, &amp;ldquo;gee why do they keep writing out &amp;lsquo;configurations that  run at most &amp;hellip;.&amp;rsquo; instead of something shorter?&amp;rdquo;. Well, the short version is &lt;em&gt;&lt;strong&gt;D&lt;/strong&gt;-deliverable&lt;/em&gt; and it was introduced in the &lt;a href="https://www2.ccs.neu.edu/racket/pubs/popl16-tfgnvf.pdf"&gt;&lt;em&gt;Is Sound Gradual Typing Dead?&lt;/em&gt;&lt;/a&gt; paper. Unfortunately, (1) that paper instantiated &lt;strong&gt;D&lt;/strong&gt; to &lt;strong&gt;3&lt;/strong&gt;-deliverable in order to  explain a few graphs and (2) at least two published papers (&lt;a href="https://dl.acm.org/citation.cfm?id=3009849"&gt;paper 1&lt;/a&gt;, &lt;a href="https://dl.acm.org/citation.cfm?id=3133878"&gt;paper 2&lt;/a&gt;)  now cite us as saying &lt;strong&gt;3&lt;/strong&gt;x overhead is the cutoff between a good migratory  typing system and a bad one.&lt;/p&gt;
 &lt;p&gt;&amp;hellip;&lt;/p&gt;
 &lt;p&gt;If we can&amp;rsquo;t trust scientists to understand, then we &lt;em&gt;definitely&lt;/em&gt; can&amp;rsquo;t trust  you folks on the internet.&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2 id="faq"&gt;FAQ&lt;/h2&gt;

&lt;h3 id="q-what-is-the-sampling-method-useful-for"&gt;Q. What is the sampling method useful for?&lt;/h3&gt;

&lt;ul&gt;
 &lt;li&gt;Making a confidence interval for the true proportion of configurations that  run at most &lt;strong&gt;D&lt;/strong&gt; times slower than some baseline, for your favorite value of &lt;strong&gt;D&lt;/strong&gt;.&lt;/li&gt;&lt;/ul&gt;

&lt;h3 id="q-what-is-the-sampling-method-not-useful-for"&gt;Q. What is the sampling method &lt;strong&gt;not&lt;/strong&gt; useful for?&lt;/h3&gt;

&lt;ul&gt;
 &lt;li&gt;Finding the slowest configuration.&lt;/li&gt;
 &lt;li&gt;Finding the average running time of all configurations.&lt;/li&gt;
 &lt;li&gt;Evaluations where &amp;ldquo;removing types&amp;rdquo; might involve changing &lt;strong&gt;List[Int]&lt;/strong&gt; to &lt;strong&gt;List[Dyn]&lt;/strong&gt;, etc.&lt;/li&gt;
 &lt;li&gt;Situations where its wrong to assume that a programmer will start from untyped and pick a configuration uniformly at random&lt;/li&gt;
 &lt;li&gt;&amp;hellip;. many more &amp;hellip;.&lt;/li&gt;&lt;/ul&gt;

&lt;h3 id="q-why-is-it-okay-to-choose-d-after-collecting-the-samples"&gt;Q. Why is it okay to choose &lt;strong&gt;D&lt;/strong&gt; after collecting the samples?&lt;/h3&gt;

&lt;p&gt;The &amp;ldquo;quick reference&amp;rdquo; at the top of this post suggests choosing a value for &lt;strong&gt;D&lt;/strong&gt;  (the cutoff between good and bad performance) after sampling configurations  and measuring their running time. This may sound strange, because (1) the value of &lt;strong&gt;D&lt;/strong&gt; affects our bottom-line  judgment about the proportion of configurations with good performance, and (2)  shouldn&amp;rsquo;t and value that affects the bottom line be fixed before taking samples? (To avoid accidental &lt;a href="https://en.wikipedia.org/wiki/Data_dredging"&gt;data dredging&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;The reason it is ok to pick &lt;strong&gt;D&lt;/strong&gt; after taking the sample is that the  running times in the sample are independent of the choice of &lt;strong&gt;D&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;For example, if one person chose &lt;strong&gt;D=3&lt;/strong&gt; and a second person chose &lt;strong&gt;D=9&lt;/strong&gt;,  both would follow the same protocol independent of &lt;strong&gt;D&lt;/strong&gt; to take samples.&lt;/p&gt;

&lt;h3 id="q-how-does-migratory-typing-relate-to-gradual-typing"&gt;Q. How does migratory typing relate to gradual typing?&lt;/h3&gt;

&lt;p&gt;Gradual typing is not just about adding a type system to an existing programming  language. See &lt;a href="http://drops.dagstuhl.de/opus/volltexte/2015/5031/"&gt;&lt;em&gt;Refined Criteria for Gradual Typing&lt;/em&gt;&lt;/a&gt;  and &lt;a href="http://drops.dagstuhl.de/opus/volltexte/2017/7120/"&gt;&lt;em&gt;Migratory Typing: 10 Years Later&lt;/em&gt;&lt;/a&gt;  for details.&lt;/p&gt;

&lt;h3 id="q-do-you-have-code-i-can-use-to-plot-sampling-data"&gt;Q. Do you have code I can use to plot sampling data?&lt;/h3&gt;

&lt;p&gt;Yes, start here:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://docs.racket-lang.org/gtp-plot/index.html#%28def._%28%28lib._gtp-plot%2Fplot..rkt%29._samples-plot%29%29"&gt;http://docs.racket-lang.org/gtp-plot/index.html#%28def._%28%28lib._gtp-plot%2Fplot..rkt%29._samples-plot%29%29&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Please ask questions and open issues if you have trouble. The source is here:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://github.com/bennn/gtp-plot"&gt;https://github.com/bennn/gtp-plot&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h3 id="q-where-is-code-for-the-sampling-paper"&gt;Q. Where is code for the sampling paper?&lt;/h3&gt;

&lt;p&gt;Start here:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://pkgd.racket-lang.org/pkgn/package/gm-pepm-2018"&gt;https://pkgd.racket-lang.org/pkgn/package/gm-pepm-2018&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Source is here:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/retic_performance"&gt;https://github.com/nuprl/retic_performance&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="closing-thoughts"&gt;Closing Thoughts&lt;/h2&gt;

&lt;p&gt;Statistics is easy to do wrong. Please let us know if you think our method is doing bad statistics.&lt;/p&gt;</description></item></channel></rss>