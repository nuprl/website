<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
 <title type="text">PRL Blog: Posts tagged 'category theory'</title>
 <link rel="self" href="http://prl.ccs.neu.edu/blog/feeds/category-theory.atom.xml" />
 <link href="http://prl.ccs.neu.edu/blog/tags/category-theory.html" />
 <id>urn:http-prl-ccs-neu-edu:-blog-tags-category-theory-html</id>
 <updated>2017-09-27T15:44:57Z</updated>
 <entry>
  <title type="text">Final Algebra Semantics is Observational Equivalence</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2017/09/27/final-algebra-semantics-is-observational-equivalence/?utm_source=category-theory&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2017-09-27-final-algebra-semantics-is-observational-equivalence</id>
  <published>2017-09-27T15:44:57Z</published>
  <updated>2017-09-27T15:44:57Z</updated>
  <author>
   <name>Max New</name></author>
  <content type="html">
&lt;p&gt;Recently, &amp;ldquo;final encodings&amp;rdquo; and &amp;ldquo;finally tagless style&amp;rdquo; have become popular techniques for defining embedded languages in functional languages. In a recent discussion in the Northeastern PRL lab, &lt;a href="https://github.com/michaelballantyne"&gt;Michael Ballantyne&lt;/a&gt;, &lt;a href="http://ccs.neu.edu/home/ryanc"&gt;Ryan Culpepper&lt;/a&gt; and I asked &amp;ldquo;in what category are these actually final objects&amp;rdquo;? As it turns out our very own &lt;a href="http://www.ccs.neu.edu/home/wand/"&gt;Mitch Wand&lt;/a&gt; wrote one of the first papers to make exactly this idea precise, so I read it &lt;a href="https://www.cs.indiana.edu/ftp/techreports/TR65.pdf"&gt;available here&lt;/a&gt; and was pleasantly surprised to see that the definition of a final algebra there is essentially equivalent to the definition of observational equivalence.&lt;/p&gt;

&lt;p&gt;In this post, I&amp;rsquo;ll go over some of the results of that paper and explain the connection to observational equivalence. In the process we&amp;rsquo;ll learn a bit about categorical logic, and I&amp;rsquo;ll reformulate some of the category theory in that paper to be a bit more modern in presentation, cleaning some things up in the process.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="intuition-implementing-a-signature"&gt;Intuition: Implementing a Signature&lt;/h1&gt;

&lt;p&gt;As a running example, say we wanted to implement a datatype of finite maps whose keys and values are both integers, i.e., finite multisets of integers.&lt;/p&gt;

&lt;p&gt;We could specify such a datatype by specifying a little language of numbers and finite multisets. We&amp;rsquo;ll have two &amp;ldquo;sorts&amp;rdquo; &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;multiset&lt;/code&gt;, a constant for every integer, and an addition function&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;'n : () -&amp;gt; num;
add : (num, num) -&amp;gt; num&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;subject to the silly-looking equation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;add('n,'m) = '(n + m)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and some operations on multisets&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;empty : () -&amp;gt; multiset;
singleton : (num) -&amp;gt; multiset;
union : (multiset, multiset) -&amp;gt; multiset;
remove : (num, multiset) -&amp;gt; multiset;
count : (num, multiset) -&amp;gt; num&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;subject to the computational equations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;count('n, empty) = '0
count('n, singleton('n)) = '1
count('n, singleton('m)) = '0
count('n, union(s,t)) = add(count('n,s), count('n, t))
count('n, remove('n,s)) = '0
count('n, remove('m,s)) = count('n,s)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are &amp;ldquo;all&amp;rdquo; of the equations we need to actually run our programs and get a number out, but not all the equations we intuitively &lt;em&gt;want&lt;/em&gt; for reasoning about our programs. For instance, clearly &lt;code&gt;union&lt;/code&gt; should be commutative, and &lt;code&gt;remove&lt;/code&gt; should be idempotent, but it&amp;rsquo;s impossible to prove that with just the equations specified. In fact, we can make a model of this theory that refutes them by constructing the &amp;ldquo;initial algebra&amp;rdquo;. In Haskell, we could say&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Empty&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Singleton&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Integer&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Union&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Remove&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Integer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kr"&gt;deriving&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Eq&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nf"&gt;count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;::&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Integer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Integer&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Empty&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Singleton&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Singleton&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Union&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Remove&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Remove&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Then it is completely obvious that all of our equations hold, but then &lt;code&gt;Union&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; commutative, as ghci will tell us:&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Singleton&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;Union&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Singleton&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Singleton&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;Union&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Singleton&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="kt"&gt;False&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;However, there is another encoding that will give us that &lt;code&gt;union&lt;/code&gt; is commutative and &lt;code&gt;remove n&lt;/code&gt; is idempotent and actually every equation we could possibly want! It&amp;rsquo;s called the &amp;ldquo;final encoding&amp;rdquo; or &amp;ldquo;final algebra&amp;rdquo;. In Haskell, this looks like:&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;::&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Integer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Integer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nf"&gt;count&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;::&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Integer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Integer&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;count&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nf"&gt;empty&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;::&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;empty&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nf"&gt;singleton&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;::&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Integer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;singleton&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                                         &lt;/span&gt;&lt;span class="kr"&gt;then&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                                         &lt;/span&gt;&lt;span class="kr"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nf"&gt;union&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;::&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;union&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nf"&gt;remove&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;::&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Integer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;remove&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                                        &lt;/span&gt;&lt;span class="kr"&gt;then&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                                        &lt;/span&gt;&lt;span class="kr"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;count&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nf"&gt;test&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;and&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;count&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;count&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;singleton&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;union&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;singleton&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;singleton&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;union&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;singleton&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Now we can verify that &lt;code&gt;union&lt;/code&gt; is commutative because&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;union&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;		  &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;union&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;since &lt;code&gt;+&lt;/code&gt; is commutative. Equality isn&amp;rsquo;t decidable anymore so I can&amp;rsquo;t give you a simple piece of code to witness this, but we can test our example before and we won&amp;rsquo;t be able to distinguish them, no surprise:&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;singleton&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;union&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;singleton&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;singleton&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;union&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;singleton&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;and&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;count&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;count&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;True&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;How do we know this is the &amp;ldquo;best&amp;rdquo; or at least &amp;ldquo;most canonical&amp;rdquo; implementation of our datatype? The intuition is that we really don&amp;rsquo;t care at all &lt;em&gt;how&lt;/em&gt; our multisets are implemented as long as they behave the right way with respect to &lt;code&gt;count&lt;/code&gt; since &lt;code&gt;count&lt;/code&gt; returns an &lt;code&gt;Integer&lt;/code&gt;, a type we do understand. Our encoding accomplishes this by representing a multiset &lt;code&gt;s&lt;/code&gt; by the partially applied function &lt;code&gt;\n -&amp;gt; count n s&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The formal name for this idea is &lt;em&gt;observational equivalence&lt;/em&gt;. We say that two closed terms &lt;code&gt;s,t&lt;/code&gt; of sort &lt;code&gt;multiset&lt;/code&gt; are &lt;em&gt;observationally equivalent&lt;/em&gt; if for any term &lt;code&gt;C&lt;/code&gt; of type &lt;code&gt;num&lt;/code&gt; that has &lt;code&gt;s&lt;/code&gt; as a subterm, we can swap &lt;code&gt;t&lt;/code&gt; in for &lt;code&gt;s&lt;/code&gt; and prove that the two terms are equal. For instance &lt;code&gt;C&lt;/code&gt; might be &lt;code&gt;count(3, union(s, singleton(3)))&lt;/code&gt; or &lt;code&gt;add(4,remove(5,s))&lt;/code&gt;. Then we&amp;rsquo;ve reduced the possibly complicated equality for &lt;code&gt;multiset&lt;/code&gt; to the simple equality of &lt;code&gt;num&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Proving that the final encoding above satisfies all observational equivalences is beyond the scope of this blog post (see &lt;a href="https://hal.inria.fr/inria-00076514/document"&gt;here&lt;/a&gt;), but let&amp;rsquo;s see what all this talk about &amp;ldquo;algebras&amp;rdquo;, initial or final is all about.&lt;/p&gt;

&lt;h1 id="formalization-attempt-1-algebras-of-a-theory"&gt;Formalization Attempt 1: Algebras of a Theory&lt;/h1&gt;

&lt;p&gt;First, our little language of numbers and multisets is called a &lt;em&gt;theory&lt;/em&gt;. The specific category gadget that we&amp;rsquo;ll use to describe it is a &lt;em&gt;multi-sorted Lawvere theory&lt;/em&gt;, or just &lt;em&gt;Lawvere theory&lt;/em&gt; for short.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;Lawvere theory&lt;/em&gt; is a category with finite products all of whose objects are finite products of a collection of &lt;em&gt;sorts&lt;/em&gt; \(S\). We can construct this category from our little language above by making the objects be &lt;em&gt;contexts&lt;/em&gt; \(x:num,y:multiset,...\) and morphisms \(\Gamma \to
x_1:s_1,...,x_n:s_n\) to be \(n\)-tuples of terms \(\Gamma \vdash t_1 : s_1,...,
\Gamma \vdash t_n :  s_n\) &lt;em&gt;modulo&lt;/em&gt; the equations we&amp;rsquo;ve specified. We&amp;rsquo;ll use the letter \(T\) to mean a Lawvere theory.&lt;/p&gt;

&lt;p&gt;Then a &lt;em&gt;\(T\)-algebra&lt;/em&gt; is a denotational semantics of our theory \(T\), i.e., a product preserving functor \(A : T \to Set\). This means for every sort we get a set \(A(s)\) and for every term \(x_1:s_1,...,x_n:s_n
\vdash t : s\) a function \(A(t) : A(s_1)\times\cdots \times A(s_n) \to
A(s)\).&lt;/p&gt;

&lt;p&gt;Finally a &lt;em&gt;morphism of \(T\)-algebras&lt;/em&gt; from \(A\) to \(B\) is a way to translate one algebra into another. Briefly, it is a natural transformation from \(A\) to \(B\), but concretely this means for every sort \(s\) we get a function \(\alpha_s : A(s) \to B(s)\) that translates \(A\)s interpretation of \(s\) as a set into \(B\)s. The key property that we want is that the operations according to \(A\) and \(B\) do the same thing as determined by \(\alpha\). Specifically, for any term \(x_1:s_1,...,x_n:s_n \vdash t :
s\), and inputs \(x_1 \in A(s_1),...,x_n \in A(s_n)\) we should get the same result if we evaluate \(A(t)(x_1,\ldots,x_n)\) and then apply \(\alpha_s\) as if we first translate \(x_1,\ldots,x_n\) to \(B(s_1),\ldots,B(s_n)\) and then apply \(B(t)\). If you unwind the definitions, this is exactly what naturality says.&lt;/p&gt;

&lt;p&gt;Then we have a category we&amp;rsquo;ll call \(T-Alg\) of \(T\)-algebras and we can ask if there are initial or final algebra. It turns out that both of them &lt;em&gt;always&lt;/em&gt; exist.&lt;/p&gt;

&lt;p&gt;The initial algebra is most famous here, we define for each sort \(In(T)(s) = \cdot \vdash s\), the closed terms of that sort modulo the equivalence of the theory, and \(In(T)(s_1,\ldots,s_n) =
In(T)(s_1)\times\ldots,In(T)(s_n)\). Then the terms are just interpreted as the functions you get by plugging closed inputs into them. Then if we look at what what a morphism of \(T\)-algebras from \(In(T) \to A\) is, we see that we don&amp;rsquo;t have any choice, the only one is the one that maps \(\cdot \vdash t : s\) to \(A(t)\) and this makes all the right diagrams to commute. This is pretty similar to our definition of &amp;ldquo;initial algebra&amp;rdquo; before, except that this time we defined &lt;code&gt;count&lt;/code&gt; as a function, not just a case of an ADT, but that was just an easy way to satisfy the computational equations for &lt;code&gt;count&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;However, an egregious flaw presents itself when we look at what the &lt;em&gt;final&lt;/em&gt; algebra is. It&amp;rsquo;s completely trivial! We can define \(Fin(T)\) to take every sort to a one element set \(Fin(T)(s) = \{*\}\) and every term to the trivial function \(\{*\}^n \to \{*\}\). What the hell? This interprets numbers and multisets as trivial one-element sets. To rule this one out, we need to add some conditions to our algebras.&lt;/p&gt;

&lt;h1 id="formalization-algebras-of-a-theory-extension"&gt;Formalization: Algebras of a Theory Extension&lt;/h1&gt;

&lt;p&gt;To rule out these boring algebras, and get a nice final algebra, we have to recognize that the sorts &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;multiset&lt;/code&gt; in our theory are not really on equal footing. While we are not sure how multisets should be defined, we know &lt;em&gt;exactly&lt;/em&gt; what numbers are!&lt;/p&gt;

&lt;p&gt;To formalize this we&amp;rsquo;ll call the full theory \(T_1\) and the theory with just numbers \(T_0\). Then there should be a map from \(T_0\) to \(T_1\) that is the inclusion of theories. We&amp;rsquo;ll formalize this as a &lt;em&gt;morphism of theories&lt;/em&gt;. A morphism of theories is a &lt;em&gt;strict&lt;/em&gt; product-preserving functor from one theory to another. The strictness ensures that we don&amp;rsquo;t mix up our sorts and our contexts, a morphim of theories has to map sorts to sorts, whereas a non-strict functor could map a sort to a context with two sorts it&amp;rsquo;s equivalent to. What this really amounts to is a translation of one theory into another. It maps sorts to sorts and terms to terms of the appropriate sorts in a compositional way. However, we don&amp;rsquo;t want to consider &lt;em&gt;all&lt;/em&gt; such morphisms, only the ones that are &amp;ldquo;conservative extensions&amp;rdquo;, which means&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;there are no new closed terms at old types&lt;/li&gt;
 &lt;li&gt;closed terms that were different before remain different.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;In our example (1) ensures that we don&amp;rsquo;t add any new exotic numbers like &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;∞&lt;/code&gt;, and (2) ensures that we keep \(0\) different from \(1\), like the final algebra did before by having all numbers have the same interpreation \(*\).&lt;/p&gt;

&lt;p&gt;We can formalize this in the following way. Note that any morphism of Lawvere theories \(m : T \to S\) induces a &lt;em&gt;functor&lt;/em&gt; on the category of algebras \(m^* : S-Alg \to T-Alg\) by just composing functors. An \(S\)-algebra is a functor from \(S\) to sets, and \(m\) is a functor from \(T\) to \(S\) so we can compose to get \(m^*(A)(t) = A(m(t))\).&lt;/p&gt;

&lt;p&gt;Now, we can express the idea of a conservative extension by saying that the canonical arrow from \(In(T)\) to \(m^*(In(S))\) is an isomorphism. Recalling the definition of initial algebras, this says exactly that the closed terms in \(T\) up to \(T\)-equivalence are isomorphic to the closed terms of the type provided by \(m\) in \(S\) up to \(S\)-equivalence. This is an equivalent formulation to the definition in Mitch&amp;rsquo;s paper, but there it is separated into two properties fullness and faithfulness, and doesn&amp;rsquo;t use the initial algebras and \(m^*\) explicitly.&lt;/p&gt;

&lt;p&gt;Now we can verify that the inclusion \(i : T_0 \to T_1\) of the number theory into the number-multiset theory is an extension in this sense.&lt;/p&gt;

&lt;p&gt;Finally we can define our notion of \(i\)-algebra, which will be our correct notion of algebra. An \(i\)-algebra is a \(T_1\) algebra \(A\) such that&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;The canonical algebra map \(! : In(T_0) \to m^*A\) is an isomorphism.&lt;/li&gt;
 &lt;li&gt;The canonical algebra map \(! : In(T_1) \to A\) is surjective i.e.,  for each sort \(s, !_s\) is surjective.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;The first condition says again that we have a conservative extension of \(T_0\), but the second is more interesting. It says that every denotation given by \(A\) is represented by some term in \(T_1\). In fact what it really ensures is that \(A\) determines a &lt;em&gt;congruence relation&lt;/em&gt; on \(T_1\) given by \(t1 \equiv_A t2\) if \(A(t1) = A(t2)\). In light of this, the first condition could be called &lt;em&gt;adequacy&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Furthermore, the surjectivity condition ensures that any morphism of \(i\) algebras, i.e., a map as \(T_1\)-algebras is also surjective, so a morphism \(A \to B\) is a witness to the fact that \(B\) determines a &lt;em&gt;stronger&lt;/em&gt; congruence relation on \(T_1\) than \(A\) does: \(t1 \equiv_B t2
\implies t1 \equiv_A t2\). Then asking for a final algebra is asking for exactly the:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Strongest adequate congruence relation&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;which is exactly the definition of observational equivalence you will find in, say Pitt&amp;rsquo;s chapter of &lt;a href="https://www.cis.upenn.edu/~bcpierce/attapl/"&gt;Advanced TAPL&lt;/a&gt;. There is a difference in the meaning of &lt;em&gt;adequacy&lt;/em&gt;, though. Usually adequacy is defined in terms of an operational semantics, but here everything is based on an axiomatic notion of equality, but I think they play the same role in the two settings, so I think it&amp;rsquo;s reasonable to use the same word. On thing I like about this formulation is very nice though since it makes obvious that &lt;em&gt;adequacy&lt;/em&gt; is not a predetermined concept, we have to pick \(T_0\) and \(i\) in order to know what adequacy means.&lt;/p&gt;

&lt;h1 id="conclusion-tying-it-back-to-final-encodings"&gt;Conclusion: Tying it back to Final Encodings&lt;/h1&gt;

&lt;p&gt;So now we&amp;rsquo;ve seen that&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Final algebras are equivalent to initial algebras modulo observational equivalence&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Of course we haven&amp;rsquo;t precisely gotten back to where we started: we were talking about denotational semantics in terms of sets and functions, but what we really want are implementations in our favorite programming languages. Fortunately, we didn&amp;rsquo;t use very many properties of sets in our definition, so it&amp;rsquo;s pretty easy to swap out the category of Sets for some category built out of the terms of our programming language. We can also swap out sets for some much cooler category of denotations like domains or metric spaces or time-varying values.&lt;/p&gt;

&lt;p&gt;Another question is how to implement this when we have a proper &lt;em&gt;type theory&lt;/em&gt; and not just some boring sorts. In particular, if we have function types, then we won&amp;rsquo;t be able to get functions from functions in our term model to functions in our denotations due to contravariance. Perhaps logical relations are the solution?&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Closure Conversion as CoYoneda</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2017/08/28/closure-conversion-as-coyoneda/?utm_source=category-theory&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2017-08-28-closure-conversion-as-coyoneda</id>
  <published>2017-08-28T10:30:00Z</published>
  <updated>2017-08-28T10:30:00Z</updated>
  <author>
   <name>Max New</name></author>
  <content type="html">
&lt;p&gt;The continuation-passing style transform (cps) and closure conversion (cc) are two techniques widely employed by compilers for functional languages, and have been studied extensively in the compiler correctness literature. Interestingly, &lt;em&gt;typed&lt;/em&gt; versions of each can be proven to be equivalence preserving using polymorphic types and parametric reasoning, as shown by my advisor Amal Ahmed and Matthias Blume (&lt;a href="http://www.ccs.neu.edu/home/amal/papers/epc.pdf"&gt;cps&lt;/a&gt;,&lt;a href="http://www.ccs.neu.edu/home/amal/papers/tccpoe.pdf"&gt;cc&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;In fact, there is something like a duality between the two proofs, cps uses a universal type, closure-conversion uses an existential type and the isomorphism proofs use analogous reasoning. It turns out that both are instances of general theorems in category theory: the polymorphic cps isomorphism can be proven using the Yoneda lemma, and the polymorphic closure-conversion isomorphism can be proven using a less well known theorem often called the &lt;a href="https://ncatlab.org/nlab/show/co-Yoneda+lemma"&gt;*co*Yoneda lemma&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The connection between cps and the Yoneda embedding/lemma is detailed elsewhere in the &lt;a href="http://www.cs.ox.ac.uk/people/daniel.james/iso/iso.pdf"&gt;literature&lt;/a&gt; and blogosphere (&lt;a href="https://golem.ph.utexas.edu/category/2008/01/the_continuation_passing_trans.html"&gt;ncafe&lt;/a&gt;, &lt;a href="https://bartoszmilewski.com/2015/09/01/the-Yoneda-lemma/"&gt;Bartosz&lt;/a&gt;), so I&amp;rsquo;ll focus on closure conversion here. Also, I&amp;rsquo;ll try to go into some detail in showing how the &amp;ldquo;usual&amp;rdquo; version of Yoneda/coYoneda (using the category of sets) relates to the appropriate version for compilers.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll assume some background knowledge on closure conversion and parametricity below. Fortunately, Matt Might has a &lt;a href="http://matt.might.net/articles/closure-conversion/"&gt;nice blog post explaining untyped closure conversion&lt;/a&gt;.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;\(
\newcommand{\Set}{\mathsf{Set}}
\newcommand{\Hom}{\mathsf{Hom}}
\)&lt;/p&gt;

&lt;h2 id="polymorphic-closure-conversion"&gt;Polymorphic Closure Conversion&lt;/h2&gt;

&lt;p&gt;Closure conversion is a way of compiling a language with closures (i.e., basically any modern high-level language) to one that only has function pointers/labels like C or machine code. Closure conversion compiles high-level functions (aka closures) to a pair of an environment that will contain the values of all the functions&amp;rsquo; free variables and a code pointer to a block that takes as inputs all the inputs to the function and values for all of the free variables.&lt;/p&gt;

&lt;p&gt;For instance&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = 3 in λ y. x + y&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would be converted to something like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = 3 in ([x: 3], λ env, y. let x = env.x in x + y)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Can we give a type to the resulting code? The source program has type &lt;code&gt;Number -&amp;gt; Number&lt;/code&gt;, but the target has a type more like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ x: Number} × ({x : Number} × Number -&amp;gt; Number).&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition to being ugly, this type is leaking irrelevant details of the function&amp;rsquo;s implementation: all of its free variables are there in its type, so two terms with the same function type but different free variables would be translated to different types. Also high-level program equivalences like \(\beta\)-reducing the term to just &lt;code&gt;λ y. 3 + y&lt;/code&gt; would not even preserve typing. Not only that, but some bad code could now supply a &lt;em&gt;different&lt;/em&gt;, well-typed value for &lt;code&gt;x&lt;/code&gt; than allowed which could break invariants the programmer had about the function.&lt;/p&gt;

&lt;p&gt;We could fix the type preservation issue by just using a dynamic type for our environment, but this would still leak details in the values. Fortunately, there is a nice solution to the other problems using existential types. The idea is that the type of the environment of free variables is &lt;em&gt;irrelevant&lt;/em&gt; to anyone that calls the function, only the function itself should know what the environment looks like; the type of the environment should be &lt;em&gt;abstract&lt;/em&gt; to the caller and &lt;em&gt;concrete&lt;/em&gt; to the callee. Existential types capture this.&lt;/p&gt;

&lt;p&gt;We can translate functions in the source of type &lt;code&gt;A -&amp;gt; B&lt;/code&gt; to pairs of an environment and a code pointer, but now making the environment type existentially quantified:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;∃ Γ. Γ × (Γ × A -&amp;gt; B).&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the syntax of existential types ensure that all any consumer can do with the &lt;code&gt;env : Γ&lt;/code&gt; in the pair is pass it to the code pointer with an &lt;code&gt;A&lt;/code&gt; argument.&lt;/p&gt;

&lt;p&gt;How do we prove that this is correct? And what does correct even mean? We&amp;rsquo;ll focus on a property called &lt;em&gt;full abstraction&lt;/em&gt; which says that if two programs are equal in the source language, then their translations are equal. Here, equal in the source language will just mean \(\beta,\eta \) equivalence, so things like as above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = 3 in λ y. x + y
≡
λ y. 3 + y&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To prove this we&amp;rsquo;ll show that in a language with existential types the types &lt;code&gt;∃ Γ. Γ × (Γ × A -&amp;gt; B)&lt;/code&gt; and &lt;code&gt;A \to B&lt;/code&gt; are isomorphic. The usual proof is by parametricity, instead we&amp;rsquo;ll use a closely related category-theoretic argument: the coYoneda lemma.&lt;/p&gt;

&lt;h2 id="the-coyoneda-lemma"&gt;The CoYoneda Lemma&lt;/h2&gt;

&lt;p&gt;The coYoneda lemma is a generalization of the equivalence described above. I&amp;rsquo;ll start with the ordinary version which uses &lt;em&gt;coends&lt;/em&gt; and &lt;em&gt;presheaves&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The coYoneda lemma says that for any category \( C \), presheaf \( Q : C^{op} \to \Set \), and object \(A \in C \), \(Q(A) \) is isomorphic to the coend: \[ \exists B. (A \to B) \times Q(B) \] Let&amp;rsquo;s break that down.&lt;/p&gt;

&lt;h3 id="coends"&gt;Coends&lt;/h3&gt;

&lt;p&gt;A coend is a construction that is very similar to the parametric existential quantifier. If you&amp;rsquo;re familiar with parametricity, a good intuition is that coends have the same definition as existential types but where the only relations are functional relations.&lt;/p&gt;

&lt;p&gt;You can take the coend of a functor of type \(M : C^{op} \times C \to
\Set \). We can get such an \(M \) from a type with a free type variable like \( X \times A \to X \) by splitting the \(X \) into positive and negative occurrences: \(X^- \times A \to X^+ \). Then the coend \(\exists X. M(X,X) \in \Set \) is like the union of all \(M(X,X) \), but where the \(X \) is ensured to be &amp;ldquo;irrelevant&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;So for any object \(A \in C \) there is a map \(pack_A : M(A,A) \to
\exists X. M(X,X) \), we can &amp;ldquo;hide the A&amp;rdquo;. To make sure the \(X \) is treated opaquely, we add an invariance condition that says if you have an \(mA : M(A,A) \) and an \(mB :
M(B,B) \) such that the \(A, B\) positions are related by some function \(f : A \to B \), then \(pack_A(mA) = pack_B(mB)\). More formally, this means that if you have a \(m' : M(B,A) \), then&lt;/p&gt;

&lt;p&gt;\[ pack_B(M(B,f)(m')) = pack_A(M(f,A)(m'))\] or in a point-free style: \[ pack_B \circ M(B,f) = pack_A \circ M(f,A) : M(B,A) \to \exists X. M(X,X) \]&lt;/p&gt;

&lt;p&gt;A function parameterized by types like \(pack \) that has this property is called a &lt;em&gt;co-wedge&lt;/em&gt; from \(M \).&lt;/p&gt;

&lt;p&gt;A coend is an object \(\exists X. M(X,X) \) and a co-wedge \(\forall
A. pack_A : M(A,A) \to \exists X. M(X,X) \) that are &lt;em&gt;universal&lt;/em&gt;, i.e. any other co-wedge \(\forall A. f_A : M(A,A) \to C\) factors through \(pack_A \). This gives us the syntax for existential elimination.&lt;/p&gt;

&lt;p&gt;If you are familiar with parametricity, it is a good exercise to see why the usual condition for invariance wrt all &lt;em&gt;relations&lt;/em&gt; implies that a parametric \(pack, \exists X. M(X,X) \) will form a cowedge. It seems that in general it would not be a universal co-wedge because a parametric exists is invariant under all relations and there are many relations that don&amp;rsquo;t act like functions.&lt;/p&gt;

&lt;h3 id="presheaves"&gt;Presheaves&lt;/h3&gt;

&lt;p&gt;Next, a presheaf is just a functor \( Q : C^{op} \to
\Set \). Think of this as a set that is parameterised by a type of &amp;ldquo;inputs&amp;rdquo;, so if you have a map in \(C, f : A \to B\) you get a function \(Q(f) :
Q(B) \to Q(A) \) that &amp;ldquo;preprocesses&amp;rdquo; the inputs using \(f
\). Functoriality ensures that preprocessing with the identity is just the identity and that composition of preprocessers is the preprocessor from the composite function.&lt;/p&gt;

&lt;p&gt;So the informal explanation of the coYoneda lemma is that for any presheaf \(Q \), if we have an \( \exists X. (A \to X) \times Q(X)
\), then since we can&amp;rsquo;t inspect the \(X \) in any way, all we can really do is compose the \(Q(X) \) with the preprocesser from the function \(A \to X \), giving us a \(Q(A) \).&lt;/p&gt;

&lt;h3 id="enriched-categories-and-enriched-coyoneda"&gt;Enriched Categories and Enriched CoYoneda&lt;/h3&gt;

&lt;p&gt;But there&amp;rsquo;s a gap from here to applying this to a programming language, the coYoneda lemma as presented says that \(Q(A) \) and \(\exists B. (A \to B) \times Q(B) \) are isomorphic as &lt;em&gt;sets&lt;/em&gt;, but we wanted an isomorphism of &lt;em&gt;types&lt;/em&gt; in our programming language. We can reconcile this by considering &lt;em&gt;enriched&lt;/em&gt; category theory and the &lt;em&gt;enriched&lt;/em&gt; coYoneda lemma. Let \(V \) be a category, then if \( V
\) is sufficiently like the category of sets, then we can do a lot of category theory by replacing the word &amp;ldquo;set&amp;rdquo; with &amp;ldquo;object of \(V \)&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Specifically, a \(V \)-enriched category (or just \(V\)-category) has a set of objects \(Ob \), but for each pair of objects \(A,B
\in Ob \) we get a \( V\)-object \(\Hom(A,B) \) of morphisms from \(A \) to \( B \). If \(V \) is a closed category, we can see \(V \) &lt;em&gt;itself&lt;/em&gt; as a \(V\)-enriched category with the same objects and just making \(\Hom(A,B) = A \to B \) i.e. the &lt;em&gt;internal&lt;/em&gt; hom aka exponential.&lt;/p&gt;

&lt;p&gt;Then we can reinterpret the coYoneda lemma above by saying \(C \) is a \(V\)-category and \(Q \) is a \(V\)-presheaf i.e., just a contravariant functor from \(V \) to itself: \(Q : V^{op} \to V\) where the preprocessing function is now a morphism in \(C \). Haskelletons just call this a &lt;a href="https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html"&gt;contravariant functor&lt;/a&gt;. Furthermore, since existential types provide at least as strong of a reasoning principle as coends, the proof of the coYoneda lemma goes through with existential types instead. Finally, the point-free description above for coend can be interpreted in any category.&lt;/p&gt;

&lt;p&gt;Now that we&amp;rsquo;re working all inside our language, let&amp;rsquo;s look at what the isomorphism looks like in Haskellish/Agdaish syntax. We want mutually inverse functions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;f : (Contravariant Q) =&amp;gt; (∃ Γ. (Δ -&amp;gt; Γ) × (Q Γ)) -&amp;gt; Q Δ
g : (Contravariant Q) =&amp;gt; Q Δ -&amp;gt; ∃ Γ. (Δ -&amp;gt; Γ) × (Q Γ)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you try to implement them you won&amp;rsquo;t be able to get it wrong, but here they are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;f (k, qΓ) = contramap k qΓ
g qΔ = (id, qΔ)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where we just instantiate \(\Gamma = \Delta \) in the second case. You can prove \( f \circ g = id \) using just \(\beta \) and the Contravariant laws, but to prove \(g \circ f = id \) you need to use the coend reasoning. For those of you that know about the Yoneda lemma, note the similarity to that proof in using the identity function and instantiating a type variable in a trivial way.&lt;/p&gt;

&lt;h2 id="closure-version-as-coyoneda"&gt;Closure Version as CoYoneda&lt;/h2&gt;

&lt;p&gt;Now it&amp;rsquo;s time to bring it all together. Let \(V \) be our programming language viewed as a category in the usual way.&lt;/p&gt;

&lt;p&gt;We want to prove the closure conversion isomorphism:&lt;/p&gt;

&lt;p&gt;\[ A \to B \cong \exists \Gamma. \Gamma \times (\Gamma \times A \to B)
\]&lt;/p&gt;

&lt;p&gt;using the \(V \)-coYoneda lemma which says for any contravariant functor \(Q : V^{op} \to V \), and object \(\Delta \in V\)&lt;/p&gt;

&lt;p&gt;\[ Q(\Delta) \cong \exists \Gamma. (\Delta \to \Gamma) \times Q(\Gamma)
\]&lt;/p&gt;

&lt;p&gt;Clearly based on the right hand side, \(Q \) should be \( - \times
A \to B \) which gives us for any \(\Delta \in V\):&lt;/p&gt;

&lt;p&gt;\[ \Delta \times A \to B \cong \exists \Gamma. (\Delta \to \Gamma) \times (\Gamma \times A \to B)
\]&lt;/p&gt;

&lt;p&gt;Next we pick \(\Delta = 1\), the unit type. Then we use some basic facts about the unit type: \(1 \times A \cong
A \) and \(1 \to \Gamma \cong \Gamma\) (at least in a pure language) to get the desired result by composition:&lt;/p&gt;

&lt;p&gt;\[ A \to B \cong 1 \times A \to B \cong \exists \Gamma. (1 \to
\Gamma) \times (\Gamma \times A \to B) \cong \exists \Gamma. \Gamma
\times (\Gamma \times A \to B)\]&lt;/p&gt;

&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Since closure conversion is an instance of the CoYoneda lemma, this might be a nice example to give intuition for CoYoneda for programmers. While not as famous as its cousin Yoneda, CoYoneda is used in &lt;a href="https://hackage.haskell.org/package/kan-extensions-5.0.2/docs/Data-Functor-Coyoneda.html"&gt;Haskell&lt;/a&gt; and is also central to the &lt;a href="https://ncatlab.org/nlab/show/Day+convolution"&gt;Day Convolution&lt;/a&gt;, which can be used to give semantics to &lt;a href="atkey-thesis"&gt;separation logic&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Also in researching for this post, I was surprised at how little I could find on the relationship between ends/coends and relational parametricity. This seems very unfortunate as it looks like we&amp;rsquo;re reproving some of the same theorems (Yoneda, coYoneda) using very similar, but incompatible formalisms.&lt;/p&gt;

&lt;h2 id="you-might-also-like"&gt;You might also like&lt;/h2&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="http://prl.ccs.neu.edu/blog/2017/06/05/syntactic-parametricity-strikes-again/"&gt;Syntactic Parametricity Strikes Again&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="http://prl.ccs.neu.edu/blog/2017/05/01/categorical-semantics-for-dynamically-typed-programming-languages/"&gt;Categorical Semantics for Dynamically Typed Programming  Languages&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="http://prl.ccs.neu.edu/blog/2016/11/16/understanding-constructive-galois-connections/"&gt;Understanding Constructive Galois  Connections&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</content></entry>
 <entry>
  <title type="text">Categorical Semantics for Dynamically Typed Programming Languages</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2017/05/01/categorical-semantics-for-dynamically-typed-programming-languages/?utm_source=category-theory&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2017-05-01-categorical-semantics-for-dynamically-typed-programming-languages</id>
  <published>2017-05-01T12:25:17Z</published>
  <updated>2017-05-01T12:25:17Z</updated>
  <author>
   <name>Max New</name></author>
  <content type="html">&lt;!-- more--&gt;

&lt;p&gt;In 1969, Dana Scott wrote an &lt;a href="/blog/static/scott-69-93-type-theoretical-alternative.pdf"&gt;unpublished manuscript&lt;/a&gt; in which he said untyped lambda calculus had no mathematical meaning, 11 years later he wrote &lt;a href="/blog/static/scott-80-relating-theories.pdf"&gt;a paper&lt;/a&gt; that organized many of the different semantics he and others had since found using the language of category theory.&lt;/p&gt;

&lt;p&gt;This latter paper is really the first deserving of the title &amp;ldquo;categorical semantics of dynamic typing&amp;rdquo;, and so I&amp;rsquo;m going to present some of the theorems and &amp;ldquo;theorems&amp;rdquo; presented in that paper, but mingled with the history of the idea and the preceding papers that led to them.&lt;/p&gt;

&lt;p&gt;&lt;a href="/blog/static/dyn-cats.pdf"&gt;My Full Notes&lt;/a&gt; continue the story, and you might also be interested in the &lt;a href="https://github.com/nuprl/hopl-s2017/blob/master/lecture_notes/2017-04-07.md"&gt;discussion during the lecture&lt;/a&gt;.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Understanding Constructive Galois Connections</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2016/11/16/understanding-constructive-galois-connections/?utm_source=category-theory&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2016-11-16-understanding-constructive-galois-connections</id>
  <published>2016-11-16T00:00:00Z</published>
  <updated>2016-11-16T00:00:00Z</updated>
  <author>
   <name>Max New</name></author>
  <content type="html">
&lt;p&gt;One of my favorite papers at ICFP 2016 (in lovely &lt;a href="http://conf.researchr.org/home/icfp-2016"&gt;Nara, Japan&lt;/a&gt;) was &lt;a href="https://arxiv.org/abs/1511.06965"&gt;Constructive Galois Connections: Taming the Galois Connection Framework for Mechanized Metatheory&lt;/a&gt; by &lt;a href="http://david.darais.com/"&gt;David Darais&lt;/a&gt; and &lt;a href="https://www.cs.umd.edu/~dvanhorn/"&gt;David Van Horn&lt;/a&gt;. The central technical result is quite interesting, but a little intimidating, so I&amp;rsquo;d like to share a &amp;ldquo;de-generalization&amp;rdquo; of the result that I found helpful to understand.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="history"&gt;History&lt;/h1&gt;

&lt;p&gt;I won&amp;rsquo;t go into much of the details of the paper, because I think it is quite well written, but here&amp;rsquo;s a short overview. The paper is about how to do verified static analysis while taking advantage of the calculational approach of &lt;a href="http://www.di.ens.fr/~cousot/COUSOTpapers/Marktoberdorf98.shtml"&gt;Abstract Interpretation&lt;/a&gt;. The problem is that the Galois connections people use for abstract domains are not always computable. Darais and Van Horn show however that there is a very useful class of Galois connections that is computable, and they show how they can exploit this to write verified static analyses that more closely follow the &amp;ldquo;on-paper&amp;rdquo; proofs, and offload much of the details to the proof assistant as mere calculation.&lt;/p&gt;

&lt;p&gt;David Darais told me about these results when we were at POPL 2016 (in less lovely but much more convenient &lt;a href="http://conf.researchr.org/home/POPL-2016"&gt;St. Petersburg, Florida&lt;/a&gt;) and in particular about the central theorem of the paper, which shows that two different classes of Galois connections they define, &amp;ldquo;Kleisli&amp;rdquo; and &amp;ldquo;Constructive&amp;rdquo; Galois connections, are actually constructively equivalent. I was really surprised by the result when he explained it to me, and so I hoped to find if there was a known generalization of the result for adjunctions of categories, rather than Galois connections of posets.&lt;/p&gt;

&lt;p&gt;Eventually, my usual trawling of &lt;a href="http://mathoverflow.net/"&gt;Mathoverflow&lt;/a&gt; and &lt;a href="https://ncatlab.org/nlab/show/HomePage"&gt;nlab&lt;/a&gt; led me to a &lt;a href="https://ncatlab.org/nlab/show/Cauchy+complete+category#InOrdinaryCatTheoryByProfunctors"&gt;not-quite generalization to categories&lt;/a&gt; and interestingly a &lt;a href="http://mathoverflow.net/questions/222516/duality-between-compactness-and-hausdorffness/222524#222524"&gt;&lt;em&gt;de&lt;/em&gt;-generalization to sets&lt;/a&gt; that helped me immensely to understand the theorem.&lt;/p&gt;

&lt;p&gt;Since I know that the original theorem is a bit technical, I&amp;rsquo;ll explain the de-generalization to sets here, which I hope will help to understand their theorem.&lt;/p&gt;

&lt;h1 id="functions-and-relations"&gt;Functions and Relations&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s start with the &amp;ldquo;Kleisli Arrows&amp;rdquo;, which are monotone functions \(f : A \to P(B) \) where \(A,B \) are posets and \(P(B)\) represents the poset of downward-closed subsets of \(B \).&lt;/p&gt;

&lt;p&gt;Now to &amp;ldquo;de-posetize&amp;rdquo; this, we&amp;rsquo;ll take sets \(X,Y \) and let \(P(Y) \) mean the powerset of \(Y\), that is the set of all subsets of \(Y \). Then a function \(f : X \to P(Y) \) is actually exactly the same thing as a relation \(R \subset X \times Y \). From \(f :
X \to P(Y) \) we can take \(R = \{(x,y) \in X\times Y | y\in f(x)\} \) and from \(R\) we can construct \(f(x) = \{y \in Y | (x,y) \in R \}\).&lt;/p&gt;

&lt;p&gt;Furthermore, the &amp;ldquo;Kleisli composition&amp;rdquo; is the same as composition of relations. If \(R \subset X \times Y \) and \(Q \subset Y \times Z
\), then the composition is defined as \[ (R;Q) = \{(x,z) \in X \times Z | \exists y\in Y. (x,y) \in R \land (y,z) \in Q\}\]&lt;/p&gt;

&lt;p&gt;Then the next thing we need to understand is what is the de-generalization of &amp;ldquo;Kleisli Galois connection&amp;rdquo;? Well, Galois connections are an instance of what&amp;rsquo;s called an adjunction in category theory, which is usually formulated in terms of categories, functors and natural transformations. However, you can interpret the definition of adjunction in any &amp;ldquo;universe&amp;rdquo; that acts like the universe of categories, functors and natural transformations and it turns out we have such a universe. The universe I&amp;rsquo;m talking about is called \(\texttt{Rel}\), and it consists of sets, relations between sets and &lt;em&gt;inclusion of relations&lt;/em&gt;, i.e. that one relation is a subset of another.&lt;/p&gt;

&lt;p&gt;Then what does it mean to have an adjunction between two relations \(R \subset X \times Y, Q \subset Y \times X\)? Taking apart the definition it just means&lt;/p&gt;

&lt;p&gt;\begin{align}\tag{1}  \Delta(X) \subset R;Q \end{align} \begin{align}\tag{2}  Q;R \subset \Delta(Y) \end{align}&lt;/p&gt;

&lt;p&gt;where \(\Delta \) means the &lt;em&gt;diagonal&lt;/em&gt;, or equality relation on the set:&lt;/p&gt;

&lt;p&gt;\[\Delta(X) = \{(x_1,x_2) \in X | x_1 = x_2 \} \]&lt;/p&gt;

&lt;p&gt;So we just need to unravel what (1) and (2) mean above. Unwinding (1), we get that for any \(x \in X\), there exists a \(y \in Y \) such that \((x,y) \in R \) and \((y,x) \in Q\). This tells us for one that \(R \) is a &amp;ldquo;right-total&amp;rdquo; relation and \(Q \) is a &amp;ldquo;left-total&amp;rdquo; relation. Every \(x \) is related to some \( y\) by \( R \) and \( Q\).&lt;/p&gt;

&lt;p&gt;If we unwind (2), we get that for any \(y,y' \in Y\) if there&amp;rsquo;s some \(x \in X \) such that \((x,y) \in R \) and \((y',x) \in Q \) then actually \(y = y')\). This one is a bit more mysterious, but first, let&amp;rsquo;s see what this tells us about the relationship between \(R\) and \(Q \).&lt;/p&gt;

&lt;p&gt;If \((x,y) \in R \), then by (1) there&amp;rsquo;s some \(y' \in Y\) so that \((x,y') \in R \) and \((y',x) \in Q\). Then, by (2) we know that \(y = y'\), so we&amp;rsquo;ve shown that if \((x,y) \in R \) then \((y,x)
\in Q\). Then a completely symmetric argument shows that if \((y,x)
\in Q \) then \((x,y)\in R\)! So we&amp;rsquo;ve discovered that actually \(Q \) is just the opposite relation of \(R \).&lt;/p&gt;

&lt;p&gt;Then if we look at (2) again but replace the \(Q\)&amp;rsquo;s by flipped \(R\)&amp;rsquo;s we get that for any \(y,y' \in Y\), if there&amp;rsquo;s some \(x
\in X\) such that \((x,y) \in R \) and \((x,y')\in R\) then \(y
= y'\), which tells us that \(R \) is a partial function, i.e., that every \(x \) is related to at most one \(y \) by \(R \).&lt;/p&gt;

&lt;p&gt;You may recognize it now, our \(R \subset X \times Y \) is just a function, and saying \(R, Q\) are adjoint is exactly the same as saying that \(Q = R^{\text{op}}\) and \(R \) is a function. Adjunctions are so pervasive you saw them back in pre-algebra!&lt;/p&gt;

&lt;h1 id="constructive-galois-connections"&gt;Constructive Galois Connections&lt;/h1&gt;

&lt;p&gt;Back to constructive Galois connections, I hope if you read the paper you can see that their theorem is a generalization of the above argument, where instead of relations we have &amp;ldquo;monotone relations&amp;rdquo;, i.e., downward-closed \(R \subset A^{\text{op}} \times B \). Then you can interpret the definition of adjunction in that universe and get that it&amp;rsquo;s the same as a Kleisli Galois connection and that a similar argument to the above shows that the &amp;ldquo;left adjoint&amp;rdquo; is represented by a monotone function \(f : A \to B \):&lt;/p&gt;

&lt;p&gt;\[R = \{(x,y) | y \le f(x) \} \]&lt;/p&gt;

&lt;p&gt;Which shows that every Kleisli Galois connection is actually a constructive Galois connection! The details are in their paper, and I hope they are easier to follow now.&lt;/p&gt;

&lt;p&gt;In fact, we get a little extra from what&amp;rsquo;s mentioned in their paper, which is that the &amp;ldquo;right adjoint&amp;rdquo; is represented by \(f \) as well but in the opposite way:&lt;/p&gt;

&lt;p&gt;\[Q = \{(y,x) | f(x) \le y \}\]&lt;/p&gt;

&lt;h1 id="category-theory-post-scriptum"&gt;Category Theory Post Scriptum&lt;/h1&gt;

&lt;p&gt;If you&amp;rsquo;re interested in Category theory, here&amp;rsquo;s a more technical addendum.&lt;/p&gt;

&lt;p&gt;Remembering from Category Theory class, sets are just posets where objects are only less than themselves and posets are (basically) categories where there is at most 1 arrow between objects, so we might naturally ask, does this theorem extend to categories?&lt;/p&gt;

&lt;p&gt;Well, first we need a generalization from relations to downward-closed relations to what are called &lt;a href="https://ncatlab.org/nlab/show/profunctor"&gt;distributors or profunctors&lt;/a&gt;. Then we can also generalize inclusion of relations to morphisms of distributors and ask, is every left adjoint distributor represented by a functor?&lt;/p&gt;

&lt;p&gt;The answer is, at least in full generality, no! For it to be true we need a special property on the codomain of the left adjoint \(R : C
\not\to D \), which is called (for mind-boggling reasons) &lt;a href="https://ncatlab.org/nlab/show/Cauchy+complete+category#InOrdinaryCatTheoryByProfunctors"&gt;Cauchy completeness&lt;/a&gt;. Viewing sets and posets as special categories, it turns out that they always have this property, and that&amp;rsquo;s why the theorem worked out for those adjunctions.&lt;/p&gt;</content></entry></feed>