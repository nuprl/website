<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
 <title type="text">PRL Blog: PRL Blog</title>
 <link rel="self" href="http://prl.ccs.neu.edu/blog/feeds/all.atom.xml" />
 <link href="http://prl.ccs.neu.edu/blog/index.html" />
 <id>urn:http-prl-ccs-neu-edu:-blog-index-html</id>
 <updated>2022-02-16T00:00:42Z</updated>
 <entry>
  <title type="text">[Ř Overview I (cross-post)](https://www.o1o.ch/lab/entry/1309rkp8krzaq1catz4by5gyt719ejoi4qpiabpnmzsx64fke3g4huga3b0qqinc.html)</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2022/02/16/-r%CC%8C-overview-i-cross-post-https-www-o1o-ch-lab-entry-1309rkp8krzaq1catz4by5gyt719ejoi4qpiabpnmzsx64fke3g4huga3b0qqinc-html/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2022-02-16-r-CC-8C-overview-i-cross-post-https-www-o1o-ch-lab-entry-1309rkp8krzaq1catz4by5gyt719ejoi4qpiabpnmzsx64fke3g4huga3b0qqinc-html</id>
  <published>2022-02-16T00:00:42Z</published>
  <updated>2022-02-16T00:00:42Z</updated>
  <author>
   <name>Olivier Flückiger</name></author>
  <content type="html"></content></entry>
 <entry>
  <title type="text">Introducing Visual and Interactive-Syntax realized (VISr) for ClojureScript (and JavaScript)</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2022/01/06/introducing-visual-and-interactive-syntax-realized-visr-for-clojurescript-and-javascript/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2022-01-06-introducing-visual-and-interactive-syntax-realized-visr-for-clojurescript-and-javascript</id>
  <published>2022-01-06T17:56:08Z</published>
  <updated>2022-01-06T17:56:08Z</updated>
  <author>
   <name>Leif Andersen</name></author>
  <content type="html">
&lt;p&gt;
 &lt;style&gt;.caption {  display: none; }&lt;/style&gt;&lt;/p&gt;

&lt;p&gt;Visual and interactive-syntax is a type of language-oriented programming that allows developers to use, view, and edit portions of a textual program with graphics. Using interactive-syntax provides the benefits of a graphical programming language, while keeping all of the benefits of a purely textual language. For example, the following is an example of a small network embedded in a program:&lt;/p&gt;

&lt;div class="figure"&gt;&lt;img src="/img/intro-visr/visr-and-text.png" alt="Graphical network embedded in text" /&gt;
 &lt;p class="caption"&gt;Graphical network embedded in text&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;Interactive-syntax is backed by human readable code; the visual components exists purely when writing and editing code. This backing means all of the tools involved in software development work with interactive-syntax extensions. For example:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;version control, such as git, works with interactive-syntax;&lt;/li&gt;
 &lt;li&gt;programs using interactive-syntax can be written and edited with your favorite  text editor or IDE;&lt;/li&gt;
 &lt;li&gt;cut/copy/paste works with interactive-syntax using your operating system&amp;rsquo;s  native clipboard;&lt;/li&gt;
 &lt;li&gt;code analysis tools, like diff and refactor, still work with  interactive-syntax; and&lt;/li&gt;
 &lt;li&gt;you can use interactive-syntax in any language or environment that supports  language-oriented programming.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;To learn more about interactive-syntax, watch &lt;a href="https://www.youtube.com/watch?v=8htgAxJuK5c"&gt;this video&lt;/a&gt; or read &lt;a href="https://dl.acm.org/doi/10.1145/3428290"&gt;the accompanying paper&lt;/a&gt;.&lt;/p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/8htgAxJuK5c" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen"&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href="https://visr.pl"&gt;VISr (Visual and Interactive-Syntax realized) for ClojureScript&lt;/a&gt; is a practical implementation of interactive-syntax in web browsers. The VISr environment is a full-featured IDE that supports interactive-syntax components called VISrs. Additionally, the VISr environment comes with a package manager that supports &lt;a href="https://www.npmjs.com/"&gt;NPM packages&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This article is a brief introduction to both the VISr environment and the components that make up a VISrs. It discusses how to insert a VISr into code, how to manipulate a VISr, and how to create a new types of VISr. Future articles will discuss more advanced uses such as integrating NPM packages and using VISrs in other languages.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="getting-started-with-visr"&gt;Getting started with VISr&lt;/h1&gt;

&lt;p&gt;Start by going to &lt;a href="https://visr.pl"&gt;visr.pl&lt;/a&gt;, which is a web-based IDE that directly supports VISrs. Once in the IDE, press &lt;code&gt;Insert VISr&lt;/code&gt; to place a VISr at the current cursor position. This VISr contains two buttons:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;clicking the first displays the VISr&amp;rsquo;s visual representation, and&lt;/li&gt;
 &lt;li&gt;clicking the second shows its textual representation.&lt;/li&gt;&lt;/ul&gt;

&lt;div class="figure"&gt;&lt;img src="/img/intro-visr/visr.png" alt="VISr" /&gt;
 &lt;p class="caption"&gt;VISr&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;Opening the code shows that the new VISr is an instance of &lt;code&gt;visr.core/empty-visr&lt;/code&gt;, a default VISr provided by the IDE. This VISr expects a map with the key &lt;code&gt;:message&lt;/code&gt; to display in the visual view. Changing the value associated with &lt;code&gt;:message&lt;/code&gt; changes what is displayed, in this case &amp;ldquo;Endless Possibility&amp;rdquo;:&lt;/p&gt;

&lt;div class="figure"&gt;&lt;img src="/img/intro-visr/visr-open.png" alt="Open Visr" /&gt;
 &lt;p class="caption"&gt;Open Visr&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;Remember that, although this VISr is displayed graphically, it still exists as human-readable text. One way to see this text is by copying and pasting the VISr. A copy of the same VISr will appear when it is placed back into the IDE. However, pasting it into other text editors that do not natively support VISrs yields the following human readable, and editable, text:&lt;/p&gt;

&lt;div class="brush: clojurescript"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:editor&lt;/span&gt; &lt;span class="nv"&gt;visr.core/empty-visr&lt;/span&gt;&lt;span class="p"&gt;}(&lt;/span&gt;&lt;span class="nf"&gt;visr.core/empty-visr+elaborate&lt;/span&gt; 
                                 &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:message&lt;/span&gt; &lt;span class="s"&gt;"Endless Possibility"&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;This operation works in reverse too. Writing out similar text and pasting it into &lt;a href="https://visr.pl"&gt;visr.pl&lt;/a&gt; yields its visual representation.&lt;/p&gt;

&lt;h1 id="making-a-new-visr"&gt;Making a new VISr&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;defvisr&lt;/code&gt; form creates a VISr type. This form expects two methods:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;a &lt;code&gt;render&lt;/code&gt; method that provides visualization and interaction when code is  edited, and&lt;/li&gt;
 &lt;li&gt;an &lt;code&gt;elaborate&lt;/code&gt;/&lt;code&gt;elaborate-fn&lt;/code&gt; method that gives the VISr compile-time and  run-time semantics.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;The following is the signature for a simple VISr type:&lt;/p&gt;

&lt;div class="brush: clojurescript"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ns &lt;/span&gt;&lt;span class="nv"&gt;example.core&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defvisr&lt;/span&gt; &lt;span class="nv"&gt;Counter&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;elaborate-fn&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;"TODO-elaborate"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;render&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;"TODO-render"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;This example uses &lt;code&gt;elaborate-fn&lt;/code&gt;, a simplified version of &lt;code&gt;elaborate&lt;/code&gt; that gives the &lt;code&gt;VISr&lt;/code&gt; the same semantics as a function application. It also allows the &lt;code&gt;defvisr&lt;/code&gt; form to work in the same file as the VISr itself.&lt;/p&gt;

&lt;div class="figure"&gt;&lt;img src="/img/intro-visr/sig.png" alt="Example of elaborate-fn semantics" /&gt;
 &lt;p class="caption"&gt;Example of elaborate-fn semantics&lt;/p&gt;&lt;/div&gt;

&lt;h1 id="the-render-method-for-edit-time-semantics"&gt;The Render Method for Edit-Time Semantics&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;render&lt;/code&gt; method is given the VISr state &lt;a href="https://clojure.org/reference/atoms"&gt;as an atom&lt;/a&gt;; updating this atom also updates the code to reflect the new state. The return value for &lt;code&gt;render&lt;/code&gt; must be a &lt;a href="https://reagent-project.github.io/"&gt;Reagent form&lt;/a&gt; that is the visual view for the VISr. A render method for a counter VISr might look as follows:&lt;/p&gt;

&lt;div class="brush: clojurescript"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;render&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:button&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:on-click&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;swap!&lt;/span&gt; &lt;span class="nv"&gt;this&lt;/span&gt; &lt;span class="nv"&gt;inc&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;And in action:&lt;/p&gt;

&lt;div class="figure"&gt;&lt;img src="/img/intro-visr/simpl-count.png" alt="Simple Count Example" /&gt;
 &lt;p class="caption"&gt;Simple Count Example&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;This VISr doesn&amp;rsquo;t match the theme of the page; it also requires the state to be a single number. Using &lt;a href="https://react-bootstrap.github.io/"&gt;React Bootstrap&lt;/a&gt; and Reagent cursors fixes both of these issues:&lt;/p&gt;

&lt;div class="brush: clojurescript"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ns &lt;/span&gt;&lt;span class="nv"&gt;example.core&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:require&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;reagent.core&lt;/span&gt; &lt;span class="ss"&gt;:refer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;react-bootstrap&lt;/span&gt; &lt;span class="ss"&gt;:refer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;]]))&lt;/span&gt;
            
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defvisr&lt;/span&gt; &lt;span class="nv"&gt;Counter&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;elaborate-fn&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;"TODO-elaborate"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;render&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cursor&lt;/span&gt; &lt;span class="nv"&gt;this&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:count&lt;/span&gt;&lt;span class="p"&gt;])]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when-not &lt;/span&gt;&lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;reset!&lt;/span&gt; &lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;Button&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:on-click&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;swap!&lt;/span&gt; &lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="nv"&gt;inc&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;])))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;h1 id="elaboration-and-run-time-semantics"&gt;Elaboration and Run-Time Semantics&lt;/h1&gt;

&lt;p&gt;The elaborate method takes the VISr state, and is expected to provide a compile-time or run-time semantics. In the simplified case of &lt;code&gt;elaborate-fn&lt;/code&gt;, the VISr semantics takes the form of a function application:&lt;/p&gt;

&lt;div class="brush: clojurescript"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;elaborate-fn&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:keys&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;]}]&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;This &lt;code&gt;elaborate&lt;/code&gt; method expects a dictionary with the key &lt;code&gt;:count&lt;/code&gt; and returns the value associated with that key. It makes use of &lt;a href="https://clojure.org/guides/destructuring"&gt;ClojureScript&amp;rsquo;s Destructuring&lt;/a&gt; for brevity. The following code is equivalent:&lt;/p&gt;

&lt;div class="brush: clojurescript"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;elaborate-fn&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;get &lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt; &lt;span class="ss"&gt;:count&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;h1 id="putting-it-all-together"&gt;Putting it all together&lt;/h1&gt;

&lt;p&gt;The final result is:&lt;/p&gt;

&lt;div class="brush: clojurescript"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ns &lt;/span&gt;&lt;span class="nv"&gt;test.core&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:require&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;reagent.core&lt;/span&gt; &lt;span class="ss"&gt;:refer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;react-bootstrap&lt;/span&gt; &lt;span class="ss"&gt;:refer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;]]))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defvisr&lt;/span&gt; &lt;span class="nv"&gt;Counter&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;elaborate-fn&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:keys&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;]}]&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;render&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cursor&lt;/span&gt; &lt;span class="nv"&gt;this&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:count&lt;/span&gt;&lt;span class="p"&gt;])]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when-not &lt;/span&gt;&lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;reset!&lt;/span&gt; &lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;Button&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:on-click&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;swap!&lt;/span&gt; &lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="nv"&gt;inc&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;])))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Here is the VISr in action:&lt;/p&gt;

&lt;div class="figure"&gt;&lt;img src="/img/intro-visr/full-count.png" alt="Full Count Example" /&gt;
 &lt;p class="caption"&gt;Full Count Example&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;That&amp;rsquo;s all there is to it. From here, you can go to &lt;a href="https://visr.pl"&gt;visr.pl&lt;/a&gt; to make your own programs using VISr. You can also &lt;a href="https://study.visr.pl"&gt;take this survey&lt;/a&gt;, which contains more advanced example uses for VISr. If you find any bugs or want to contribute, you can also head to &lt;a href="https://github.com/LeifAndersen/interactive-syntax-clojure"&gt;the visr project page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thanks for reading, happy coding!&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Deep and Shallow Types</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2020/12/23/deep-and-shallow-types/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2020-12-23-deep-and-shallow-types</id>
  <published>2020-12-23T18:21:55Z</published>
  <updated>2020-12-23T18:21:55Z</updated>
  <author>
   <name>Ben Greenman</name></author>
  <content type="html">
&lt;p&gt;I successfully defended my Ph.D. dissertation. You can find the document, a talk recording, and much more here:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://ccs.neu.edu/home/types/publications/publications.html#g-dissertation-2020"&gt;http://ccs.neu.edu/home/types/publications/publications.html#g-dissertation-2020&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;To the PRL: thanks for a wonderful 6.5 years.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h3 id="abstract"&gt;Abstract&lt;/h3&gt;

&lt;blockquote&gt;
 &lt;p&gt;The design space of mixed-typed languages is lively but disorganized. On one hand, researchers across academia and industry have contributed language  designs that allow typed code to interoperate with untyped code. These design efforts explore a range of goals;  some improve the expressiveness of a typed language, and  others strengthen untyped code with a tailor-made type system. On the other hand, experience with type-sound designs has revealed major challenges. We do not know how to measure the performance costs of sound interaction. Nor do we have criteria that distinguish ``truly sound&amp;rsquo;&amp;rsquo; mixed-typed languages  from others that enforce type obligations locally rather than globally.&lt;/p&gt;
 &lt;p&gt;In this dissertation, I introduce methods for assessing  mixed-typed languages and bring order to the design space. My first contribution is a performance-analysis method that allows language  implementors to systematically measure the cost of mixed-typed interaction.&lt;/p&gt;
 &lt;p&gt;My second contribution is a design-analysis method that allows language designers  to understand implications of the type system. The method addresses two central questions: whether typed code can cope with  untyped values, and whether untyped code can trust static types. Further distinctions arise by asking whether error outputs can  direct a programmer to potentially-faulty interactions.&lt;/p&gt;
 &lt;p&gt;I apply the methods to several designs and discover limitations that motivate  a synthesis of two ideas from the literature:  deep types and shallow types. Deep types offer strong guarantees but impose a high interaction cost. Shallow types offer weak guarantees and better worst-case costs. This dissertation proves that deep and shallow types can interoperate  and measures the benefits of a three-way mix.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Next year, I&amp;rsquo;ll be a &lt;a href="https://cifellows2020.org"&gt;CI Fellow&lt;/a&gt; at Brown.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Transient for Optional and Keyword Functions</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2020/11/12/transient-for-optional-and-keyword-functions/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2020-11-12-transient-for-optional-and-keyword-functions</id>
  <published>2020-11-12T10:15:16Z</published>
  <updated>2020-11-12T10:15:16Z</updated>
  <author>
   <name>Ben Greenman</name></author>
  <content type="html">
&lt;p&gt;A short adventure into the depths of optional and/or keyword  functions in Racket.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;hr /&gt;

&lt;p&gt;Transient, or rather &lt;em&gt;the Transient semantics for a mixed-typed language&lt;/em&gt;,  is one way to let statically-typed code safely interact with untyped code. You can read all about it in  &lt;a href="http://hdl.handle.net/2022/23172"&gt;Michael Vitousek&amp;rsquo;s 2019 dissertation&lt;/a&gt;  or &lt;a href="https://ccs.neu.edu/home/types/publications/publications.html#g-dissertation-2020"&gt;my 2020 dissertation&lt;/a&gt;,  and you can see how it compares to other mixed-typed semantics  &lt;a href="http://prl.ccs.neu.edu/blog/2018/10/06/a-spectrum-of-type-soundness-and-performance/"&gt;here&lt;/a&gt;. The idea is to give up on &lt;a href="http://prl.ccs.neu.edu/blog/2019/10/31/complete-monitors-for-gradual-types/"&gt;behavioral type guarantees&lt;/a&gt;  and focus on a (weak) form of type soundness. To enforce soundness, Transient rewrites every expression in typed code  with assertions called &lt;em&gt;shape checks&lt;/em&gt;; for example:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;if a typed module imports an untyped library, then every value that crosses  the module boundary gets a shape check;&lt;/li&gt;
 &lt;li&gt;if typed code reads from an array, then every element that comes out of the  array must satisfy a shape check; and&lt;/li&gt;
 &lt;li&gt;if a typed function escapes to untyped code, then the function must use  a shape check to validate every input that it receives.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Our goal today is to understand the shape checks for functions. Suppose we know how to turn a type &lt;strong&gt;T&lt;/strong&gt; into a shape check, and we have a  function with type &lt;strong&gt;T&lt;/strong&gt; that needs to check its inputs. The question is how to actually do the check in Racket v7.9.&lt;/p&gt;

&lt;p&gt;In your standard theory, rewriting is no problem. A (simplified, model) function takes exactly one argument and needs exactly one  shape check in the body; if &lt;strong&gt;T = (-&amp;gt; Symbol Boolean)&lt;/strong&gt; then we need  to check the shape &lt;strong&gt;symbol?&lt;/strong&gt; of the domain type &lt;strong&gt;Symbol&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; source code
(: f (-&amp;gt; Symbol Boolean))
(define (f sym)
  (eq? sym 'hola))

;; ===&amp;gt;

;; imaginary (but realistic) rewritten code
(define (f sym)
  (assert sym symbol?)
  (eq? sym 'hola))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Typed Racket function can accept optional arguments, keyword arguments,  and optional keyword arguments. These are still fairly easy to handle in theory. Below, the function type &lt;strong&gt;T&lt;/strong&gt; accepts 1 to 3 inputs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; source code
(: g (-&amp;gt;* [#:a Boolean] [Symbol #:c Void] Symbol))
(define (g #:a a [b 'b] #:c [c #f])
  (if a b (if c 'left 'right)))

;; ===&amp;gt;

;; imaginary, unrealistic rewritten code
(define (g #:a a [b 'b] #:c [c #f])
  (assert a boolean?)
  (assert b symbol?)
  (assert c void?)
  (if a b (if c 'left 'right)))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Good &amp;mdash; we basically know what we want. If the Racket core language had optional and keyword functions, then we&amp;rsquo;d be  done.&lt;/p&gt;

&lt;p&gt;But no, Racket expands these optional/keyword  functions into primitive &lt;a href="https://docs.racket-lang.org/raco/decompile.html#(def._((lib._compiler%2Fzo-structs..rkt)._lam))"&gt;&lt;strong&gt;lambda&lt;/strong&gt;&lt;/a&gt;  and &lt;a href="https://docs.racket-lang.org/raco/decompile.html#(def._((lib._compiler%2Fzo-structs..rkt)._case-lam))"&gt;&lt;strong&gt;case-lambda&lt;/strong&gt;&lt;/a&gt;  forms. Typed Racket type-checks this expanded code, thus Shallow Typed Racket  (the Transient version) must rewrite the expanded code.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s keep digging.&lt;/p&gt;

&lt;p&gt;From now on, &amp;ldquo;Shallow&amp;rdquo; or &amp;ldquo;Shallow TR&amp;rdquo; refers to my implementation  of Transient for Typed Racket (TR). We&amp;rsquo;ll talk about Shallow instead of &amp;ldquo;Transient&amp;rdquo; in case future work reveals a  better way to implement the Transient idea.&lt;/p&gt;

&lt;h2 id="false-start-follow-the-type"&gt;False Start: Follow the Type&lt;/h2&gt;

&lt;p&gt;Beware &amp;mdash; Shallow TR cannot rely on type annotations to decide which shape  checks to insert. The example function &lt;strong&gt;g&lt;/strong&gt; above demonstrates that annotations are not  good enough. With our imagined rewrite, calls that leave out the optional  &lt;strong&gt;#:c&lt;/strong&gt; keyword lead to a shape-check failure because the variable &lt;strong&gt;c&lt;/strong&gt; gets  the default value &lt;strong&gt;#f&lt;/strong&gt; instead of a void value. Concretely, the third assert from above fails:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define (g #:a a [b 'b] #:c [c #f])
  ....
  (assert c void?) ;; fails if c is the #f default value
  ....)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem arises from subtyping. According to the annotations, the function &lt;strong&gt;g&lt;/strong&gt; has an external type that is  less precise than the internal type that validates the function body:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; external type T
(: g (-&amp;gt;* [#:a Boolean] [Symbol #:c Void] Symbol))

;; internal type T2, subtype of external (T2 &amp;lt;: T), validates body
(: g (-&amp;gt;* [#:a Boolean] [Symbol #:c (U #f Void)] Symbol))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thanks to this external / internal distinction, the following easy  rewrite idea, &lt;em&gt;Solution 0&lt;/em&gt;, fails. Despite the failure, this first solution is a useful starting point for  a success.&lt;/p&gt;

&lt;h4 id="solution-0-step-1-mimic-the-typechecker"&gt;Solution 0, Step 1: Mimic the Typechecker&lt;/h4&gt;

&lt;p&gt;Shallow TR uses the same type checker as classic &lt;em&gt;Deep&lt;/em&gt; TR. If type checking succeeds, then Shallow must insert shape checks. Otherwise, compilation stops with a type error.&lt;/p&gt;

&lt;p&gt;Thanks to its wholesale reuse of the type checker, Shallow TR can use  syntax patterns from the type checker to navigate expanded Racket code. For optional and keyword functions in particular, Shallow can get started  by looking at how the type checker recognizes these forms in expanded code.&lt;/p&gt;

&lt;p&gt;Here are two syntax patterns for keyword functions and optional functions  in the Deep TR type checker (&lt;a href="https://github.com/racket/typed-racket/blob/325f621716966b95a68af700624bafa21ac66e14/typed-racket-lib/typed-racket/typecheck/tc-expr-unit.rkt#L274-L295"&gt;typecheck/tc-expr-unit.rkt&lt;/a&gt;). The omitted code (&lt;strong&gt;&amp;hellip;.&lt;/strong&gt;) does actual type checking:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define (tc-expr/check/internal form expected-type)
  ....
  (syntax-parse form
    #:literal-sets (kernel-literals tc-expr-literals)
    ....
    [(~and (let-values ([(f) fun]) . body) kw:kw-lambda^)
    ....]
    [(~and (let-values ([(f) fun]) . body) opt:opt-lambda^)
    ....]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok! Those two patterns say a lot about the expansion of optional and keyword  functions:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;Both forms expand to a &lt;strong&gt;let-values&lt;/strong&gt; that binds one function &lt;strong&gt;fun&lt;/strong&gt;.&lt;/li&gt;
 &lt;li&gt;TR uses the syntax classes &lt;strong&gt;kw-lambda^&lt;/strong&gt; and &lt;strong&gt;opt-lambda^&lt;/strong&gt; to  tell these particular &lt;strong&gt;let-values&lt;/strong&gt; apart from others.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Shallow TR can use exactly these patterns to   recognize optional/keyword functions.&lt;/p&gt;

&lt;h4 id="solution-0-step-2-parse-the-domain-type"&gt;Solution 0, Step 2: Parse the Domain Type&lt;/h4&gt;

&lt;p&gt;Once the Shallow TR rewriter has found an optional/keyword function,  the next step is to find the function&amp;rsquo;s type and figure out the right  shape check. For an optional function, the rewriter has an expression that  matches the following pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [(~and (let-values ([(f) fun]) . body) opt:opt-lambda^)
    ....]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, we need a type. The type checker decorates (almost) every expression with a type as a syntax  property. (Unreachable code may not have a type.) The &lt;a href="https://github.com/racket/typed-racket/blob/325f621716966b95a68af700624bafa21ac66e14/typed-racket-lib/typed-racket/types/type-table.rkt#L80"&gt;&lt;strong&gt;type-of&lt;/strong&gt;&lt;/a&gt;  function gets the type decoration from an expression. A little experimentation shows that the function  part of our expression, &lt;strong&gt;fun&lt;/strong&gt;, has a type. Great.&lt;/p&gt;

&lt;p&gt;Second, we need to parse the domain from the function type. This is easier said than done. Fortunately, our final solution does not need the parsing step so I will  list the challenges and move on:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;The type of &lt;strong&gt;fun&lt;/strong&gt; could be a straightforward &lt;a href="https://github.com/racket/typed-racket/blob/325f621716966b95a68af700624bafa21ac66e14/typed-racket-lib/typed-racket/rep/type-rep.rkt#L693"&gt;&lt;strong&gt;Fun type&lt;/strong&gt;&lt;/a&gt;,  but it could also be a: &lt;a href="https://github.com/racket/typed-racket/blob/325f621716966b95a68af700624bafa21ac66e14/typed-racket-lib/typed-racket/rep/type-rep.rkt#L701"&gt;&lt;strong&gt;DepFun type&lt;/strong&gt;&lt;/a&gt;,  or &lt;a href="https://github.com/racket/typed-racket/blob/325f621716966b95a68af700624bafa21ac66e14/typed-racket-lib/typed-racket/rep/type-rep.rkt#L521"&gt;&lt;strong&gt;Poly type&lt;/strong&gt;&lt;/a&gt;,  or &lt;a href="https://github.com/racket/typed-racket/blob/325f621716966b95a68af700624bafa21ac66e14/typed-racket-lib/typed-racket/rep/type-rep.rkt#L531"&gt;&lt;strong&gt;PolyDots type&lt;/strong&gt;&lt;/a&gt;,  or even a &lt;a href="https://github.com/racket/typed-racket/blob/325f621716966b95a68af700624bafa21ac66e14/typed-racket-lib/typed-racket/rep/type-rep.rkt#L900"&gt;&lt;strong&gt;Union type&lt;/strong&gt;&lt;/a&gt;.&lt;/li&gt;
 &lt;li&gt;Each part of the domain type corresponds to one parameter of the &lt;strong&gt;fun&lt;/strong&gt; expression.  Matching the parameter names to types is not straightforward; for example,  do the mandatory parameters come first in &lt;strong&gt;fun&lt;/strong&gt;, or the mandatory keywords?&lt;/li&gt;&lt;/ul&gt;

&lt;h4 id="solution-0-step-3-insert-a-shape-check"&gt;Solution 0, Step 3: Insert a Shape Check&lt;/h4&gt;

&lt;p&gt;Once we have the target &lt;strong&gt;fun&lt;/strong&gt; expression and a map from parameter names  to types, the final step of our tentative solution is easy. First, convert the types to shape predicates. Second, parse &lt;strong&gt;fun&lt;/strong&gt; to separate the parameters from the body. Third, insert a block of shape checks to the top of the body. All together, rewriting &lt;strong&gt;fun&lt;/strong&gt; goes something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(syntax-parse fun
  [(#%plain-lambda formals . body)
   #:with (shape-check ...)
          (make-shape-checks #'formals (type-of fun))
   #'(#%plain-lambda formals (#%plain-app void shape-check ...) . body)])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rewritten function executes shape checks immediately, and then proceeds  with the &lt;strong&gt;body&lt;/strong&gt; after validating each actual parameter.&lt;/p&gt;

&lt;h2 id="on-the-trail-optkey-expansion"&gt;On the Trail: optkey Expansion&lt;/h2&gt;

&lt;p&gt;Our &lt;em&gt;Solution 0&lt;/em&gt; fails because the type of the &lt;strong&gt;fun&lt;/strong&gt; expression  that it gets from the type-checked code is an external type. In terms of the &lt;strong&gt;g&lt;/strong&gt; function from above, &lt;em&gt;Solution 0&lt;/em&gt; uses the type  &lt;strong&gt;Void&lt;/strong&gt; instead of the internal type &lt;strong&gt;(U Void #f)&lt;/strong&gt; to check the &lt;strong&gt;c&lt;/strong&gt; parameter. To get internal types, we need to look closer at &lt;strong&gt;fun&lt;/strong&gt; and the rest of  the optional/keyword expansion.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s study three example functions and their expanded forms. The expansions reveal a common pattern that motivates a new Shallow TR strategy.&lt;/p&gt;

&lt;p&gt;If you want to expand these examples yourself, hide them from the Racket  toplevel as follows. For each example function &lt;strong&gt;X&lt;/strong&gt; create a module &lt;strong&gt;test.rkt&lt;/strong&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#lang racket/base

(define _ignore
  (let ()
    X
    (void)))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Invoke the expander with &lt;code&gt;raco expand test.rkt &amp;gt; test.rkt.txt&lt;/code&gt; and explore  the generated &lt;strong&gt;.txt&lt;/strong&gt; file.&lt;/p&gt;

&lt;h3 id="example-1-mandatory-keyword"&gt;Example 1: mandatory keyword&lt;/h3&gt;

&lt;p&gt;The source is a function with one mandatory positional argument and one optional positional argument.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(lambda (x [y 0])
  (+ x y))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Expansion generates a &lt;strong&gt;case-lambda&lt;/strong&gt; that accepts one or two arguments. The one-argument case supplies a default value for the missing parameter. Both cases call a generated function &lt;strong&gt;F&lt;/strong&gt; that expects two arguments,  resolves defaults in a different way,  and executes the function body.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(let-values (((F)
              (lambda (x2 y1)
                (let-values (((x) x2))
                  (let-values (((y) (if '#f '0 y1)))
                    (let-values () (#%app + x y)))))))
  (case-lambda
   ((x) (#%app F x '0))
   ((x y1) (#%app F x y1))))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: the expression &lt;strong&gt;(if &amp;rsquo;#f &amp;rsquo;0 y1)&lt;/strong&gt; in the generated &lt;strong&gt;F&lt;/strong&gt; function  is equal to &lt;strong&gt;y1&lt;/strong&gt; alone. In general, the &lt;strong&gt;if&lt;/strong&gt; is for default expressions. (&lt;a href="https://pythonconquerstheuniverse.wordpress.com/2012/02/15/mutable-default-arguments/"&gt;Unlike Python&lt;/a&gt;,  Racket evaluates a mutable default once for each function call.) When the default is an immediate value, as this example illustrates,  the expander generates a &lt;strong&gt;#f&lt;/strong&gt; test. A general-purpose optimizer can remove this test before the code runs.&lt;/p&gt;

&lt;h3 id="example-2"&gt;Example 2:&lt;/h3&gt;

&lt;p&gt;The source is a function with one mandatory positional argument and one mandatory keyword argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(lambda (x #:y y)
  (+ x y))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Expansion generates several functions:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;strong&gt;F0&lt;/strong&gt; expects a plain list of arguments and executes the source function&amp;rsquo;s body&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;F1&lt;/strong&gt; expects a list of keywords, a list of arguments, and a final argument.  The purpose of &lt;strong&gt;F1&lt;/strong&gt; is to organize a call to &lt;strong&gt;F0&lt;/strong&gt;.&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;lifted/2&lt;/strong&gt; is the constructor for a generated struct type.  Other functions help the struct call &lt;strong&gt;F1&lt;/strong&gt;.  Nevermind the details; I don&amp;rsquo;t fully understand them either.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The important piece for Shallow TR is the &lt;strong&gt;F0&lt;/strong&gt; function  because the goal of rewriting is to protect the original  function body against untyped inputs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(let-values (((F0)
              (lambda (y1 x3)
                (let-values (((x) x3))
                  (let-values (((y) y1))
                    (let-values () (#%app + x y)))))))
  (let-values (((F1)
                (lambda (given-kws given-args x3)
                  (let-values (((y1) (#%app car given-args)))
                    (#%app F0 y1 x3)))))
    (#%app
     lifted/2
     (lambda (given-kws given-argc)
       (if (#%app = given-argc '3)
         (let-values (((l2571) given-kws))
           (if (#%app pair? l2571)
             (if (#%app eq? (#%app car l2571) '#:y)
               (#%app null? (#%app cdr l2571))
               '#f)
             '#f))
         '#f))
     (case-lambda
      ((given-kws given-args x)
       (#%app F1 given-kws given-args x)))
     '(#:y)
     '(#:y))))&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="example-3"&gt;Example 3:&lt;/h3&gt;

&lt;p&gt;The source is a function with one mandatory positional argument and one optional keyword argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(lambda (x #:y [y 0])
  (+ x y))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Expansion again generates several functions:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;strong&gt;F0&lt;/strong&gt; expects a plain list of arguments, resolves the optional default,  and executes the source function&amp;rsquo;s body&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;F1&lt;/strong&gt; calls &lt;strong&gt;F0&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;At the bottom, there are two &lt;strong&gt;case-lambda&lt;/strong&gt; functions that call  &lt;strong&gt;F1&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Again, the &lt;strong&gt;F0&lt;/strong&gt; function is the focal point for Shallow TR rewriting.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(let-values (((F0)
              (lambda (y1 x3)
                (let-values (((x) x3))
                  (let-values (((y) (if '#f '0 y1)))
                    (let-values () (#%app + x y)))))))
  (let-values (((F1)
                (lambda (given-kws given-args x3)
                  (let-values (((y2) (#%app pair? given-kws)))
                    (let-values (((y1)
                                  (if y2 (#%app car given-args) '0)))
                      (#%app F0 y1 x3))))))
    (#%app
     make-optional-keyword-procedure
     (lambda (given-kws given-argc)
       (if (#%app = given-argc '3)
         (let-values (((l1571) given-kws))
           (let-values (((l1571)
                         (if (#%app null? l1571)
                           l1571
                           (if (#%app eq? (#%app car l1571) '#:y)
                             (#%app cdr l1571)
                             l1571))))
             (#%app null? l1571)))
         '#f))
     (case-lambda
      ((given-kws given-args x)
       (#%app F1 given-kws given-args x)))
     null
     '(#:y)
     (case-lambda
      ((x) (#%app F1 null null x))))))&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="solution-the-shallow-tr-rewrite-strategy"&gt;Solution: The Shallow TR Rewrite Strategy&lt;/h2&gt;

&lt;p&gt;All three examples show a common pattern among the expansions of optional  and keyword functions. Each function expands to a &lt;strong&gt;let-values&lt;/strong&gt; form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(let-values (((f) fun)) . body)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Furthermore, the generated &lt;strong&gt;fun&lt;/strong&gt; is a lambda that first resolves optional  arguments and then executes the body of the original function. Here is the &lt;strong&gt;fun&lt;/strong&gt; from &lt;em&gt;Example 3&lt;/em&gt; again;  it has formal parameters for the keyword arg. and the mandatory arg.,  and one &lt;strong&gt;let-values&lt;/strong&gt; to resolve each parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  (lambda (y1 x3)
    (let-values (((x) x3))
      (let-values (((y) (if '#f '0 y1)))
        (let-values () (#%app + x y)))))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another experiment with &lt;strong&gt;type-of&lt;/strong&gt; shows that the right-hand side of  each &lt;strong&gt;let-values&lt;/strong&gt; has an internal type annotation. Excellent! Both &lt;strong&gt;(type-of x3)&lt;/strong&gt;  and &lt;strong&gt;(type-of (if &amp;rsquo;#f &amp;rsquo;0 y1))&lt;/strong&gt; are the right types for shape checks. Shallow TR can:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;inspect the &lt;strong&gt;let-values&lt;/strong&gt; one-by-one;&lt;/li&gt;
 &lt;li&gt;convert the type of each right-hand expression to a shape predicate; and&lt;/li&gt;
 &lt;li&gt;rewrite each right-hand &lt;strong&gt;expr&lt;/strong&gt; into &lt;strong&gt;(assert expr shape?)&lt;/strong&gt;.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;This should work! In fact, we can do slightly better:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;when the right-hand expression is a conditional &lt;strong&gt;(if test default-expr supplied-arg)&lt;/strong&gt;&lt;/li&gt;
 &lt;li&gt;then Shallow only needs to check the supplied arg: &lt;strong&gt;(if test default-expr (assert supplied-arg shape?))&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Note: Shallow needs to rewrite the default expression, but it can trust its  final shape because of (Transient) type soundness.&lt;/p&gt;

&lt;h2 id="a-problem-with-methods-and-a-bugfix"&gt;A Problem with Methods and a Bugfix&lt;/h2&gt;

&lt;p&gt;Currently, Shallow TR rewrites optional and keyword functions using  the &lt;strong&gt;let-values&lt;/strong&gt; plan described above. Each formal parameter has one &lt;strong&gt;let-values&lt;/strong&gt; binding,  and the type on each bound expression defines the shape check.&lt;/p&gt;

&lt;p&gt;Last May, though, this rewriting caused new failures in methods  with optional arguments. The failure was due to a mismatch between Typed Racket  and the Racket class expander. Since then, we &lt;a href="https://github.com/racket/racket/pull/3182"&gt;fixed the class expander&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First, here is a class with one method that runs correctly. The method &lt;strong&gt;f&lt;/strong&gt; accepts an optional positional argument &lt;strong&gt;x&lt;/strong&gt;; the default  value of &lt;strong&gt;x&lt;/strong&gt; is the current value of the field &lt;strong&gt;my-num&lt;/strong&gt; (fields are mutable):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define c0%
  (class object%
    (super-new)
    (field (my-num 2))
    (define/public (f [x my-num])
      (+ x x))))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Second, here is a similar method that fails. This time, the default is an immediate value &lt;strong&gt;2&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define c1%
  (class object%
    (super-new)
    (define/public (f [x 2])
      (+ x x))))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running a call &lt;strong&gt;(send o1 f)&lt;/strong&gt; used to raise a shape-check failure about  a strange value:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;shape error: Expected a real number, got &lt;code&gt;#&amp;lt;unsafe-undefined&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What is going on?&lt;/p&gt;

&lt;p&gt;It turns out, the undefined value comes from the expander. Here is an optional function with a default expression:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(lambda (x [y z])
  (+ x y))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Expansion generates a function &lt;strong&gt;F0&lt;/strong&gt; that checks for the undefined value,  and an outer &lt;strong&gt;case-lambda&lt;/strong&gt; that supplies undefined when the default  is needed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(let-values (((F0)
              (lambda (x2 y1)
                (let-values (((x) x2))
                  (let-values (((y)
                                (if (#%app eq? y1 unsafe-undefined)
                                  z
                                  y1)))
                    (let-values () (#%app + x y)))))))
  (case-lambda
   ((x) (#%app F0 x unsafe-undefined))
   ((x y1) (#%app F0 x y1))))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s the normal way that &lt;strong&gt;unsafe-undefined&lt;/strong&gt; shows up:  the &lt;a href="https://github.com/racket/racket/blob/c0ff11e27bd28e070c20b7a9b0f7365f8f2b665a/racket/collects/racket/private/kw.rkt"&gt;expander for optional/keyword functions&lt;/a&gt;  looks for default expressions  vs. default values and uses the undefined value for expressions.&lt;/p&gt;

&lt;p&gt;Three other facts conspired to make the problem with optional methods:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;Typed Racket also looks for default expressions vs. default values  (search for &lt;strong&gt;immediate-default&lt;/strong&gt; &lt;a href="https://github.com/racket/typed-racket/blob/325f621716966b95a68af700624bafa21ac66e14/typed-racket-lib/typed-racket/base-env/annotate-classes.rkt"&gt;here&lt;/a&gt;).  When an optional parameter has a default expression, Typed Racket  widens its internal type to accept the &lt;strong&gt;unsafe-undefined&lt;/strong&gt; value  (search for &lt;strong&gt;-Unsafe-Undefined&lt;/strong&gt;  &lt;a href="https://github.com/racket/typed-racket/blob/325f621716966b95a68af700624bafa21ac66e14/typed-racket-lib/typed-racket/types/kw-types.rkt"&gt;here (kw)&lt;/a&gt;  and  &lt;a href="https://github.com/racket/typed-racket/blob/325f621716966b95a68af700624bafa21ac66e14/typed-racket-lib/typed-racket/typecheck/tc-lambda-unit.rkt"&gt;here (opt)&lt;/a&gt;).&lt;/li&gt;
 &lt;li&gt;The class expander does some pre-processing on optional methods and  inadvertantly turned every default value into a default expression.&lt;/li&gt;
 &lt;li&gt;Shallow TR pushes default expression checks &lt;strong&gt;(if test default-expr supplied-arg)&lt;/strong&gt;  to the &lt;strong&gt;supplied-arg&lt;/strong&gt; instead of wrapping the whole &lt;strong&gt;if&lt;/strong&gt; form.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;In the end, Typed Racket saw a default value and inferred an overly-precise  type. The type would be correct but for the class expander. As-is, the type was unsound&amp;mdash;but harmless because the false assumption  was guarded by an &lt;strong&gt;if&lt;/strong&gt; test for &lt;strong&gt;unsafe-undefined&lt;/strong&gt;. Running Shallow TR revealed the unsoundness with its eager shape check.&lt;/p&gt;

&lt;p&gt;Again, the resolution was to fix the class expander (&lt;a href="https://github.com/racket/racket/pull/3182"&gt;racket/racket #3182&lt;/a&gt;). Both Typed Racket and Shallow TR stayed the same. The change removes an unnecessary run-time check from expanded optional methods.&lt;/p&gt;

&lt;h2 id="lessons"&gt;Lessons&lt;/h2&gt;

&lt;ol&gt;
 &lt;li&gt;Optional and keyword functions are not core forms in Racket.  They expand to a combination of simple functions.&lt;/li&gt;
 &lt;li&gt;Digging into the expansion is sometimes necessary.  There are at least three places that do so&amp;mdash;the class expander, TR, and Shallow TR&amp;mdash;and unfortunately they all need to cooperate.&lt;/li&gt;
 &lt;li&gt;The development of Shallow TR helped find several latent bugs in TR, Racket, and other libraries.  Figure 57 of &lt;a href="https://ccs.neu.edu/home/types/publications/publications.html#g-dissertation-2020"&gt;my dissertation&lt;/a&gt;  lists them all.&lt;/li&gt;&lt;/ol&gt;</content></entry>
 <entry>
  <title type="text">Transient Answers Old Questions</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2020/10/15/transient-answers-old-questions/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2020-10-15-transient-answers-old-questions</id>
  <published>2020-10-15T13:32:12Z</published>
  <updated>2020-10-15T13:32:12Z</updated>
  <author>
   <name>Ben Greenman</name></author>
  <content type="html">
&lt;p&gt;Several old questions from the Typed Racket mailing list have new and simple answers under a &amp;ldquo;transient&amp;rdquo; Typed Racket.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;hr /&gt;

&lt;p&gt;For the past few months, I&amp;rsquo;ve been adding a transient semantics to Typed Racket. The project is called Shallow Typed Racket. Details are in the &lt;a href="https://github.com/racket/typed-racket/pull/952"&gt;RFC&lt;/a&gt;  and &lt;a href="https://github.com/racket/typed-racket/pull/948"&gt;pull request&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The short story is that the new Shallow Racket does less to enforce types  when typed code interacts with untyped code. Typed code is still type-sound, but that&amp;rsquo;s about it. By contrast, types are much stronger in classic Typed Racket.&lt;/p&gt;

&lt;p&gt;Shallow Racket&amp;rsquo;s weaker types allow more programs to run. While testing whether the new freedom is useful, I reviewed a few years of  Typed Racket questions on the &lt;a href="https://groups.google.com/g/racket-users"&gt;Racket mailing list&lt;/a&gt;. There were a surprising number of questions that went like this:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;strong&gt;Q.&lt;/strong&gt; Hey, I ran a program expecting &lt;em&gt;X&lt;/em&gt; to happen, but &lt;em&gt;Y&lt;/em&gt; happened instead. Is this a bug?&lt;/p&gt;
 &lt;p&gt;&lt;strong&gt;A.&lt;/strong&gt; No, Typed Racket has to do &lt;em&gt;Y&lt;/em&gt; because of its strong types.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&amp;hellip; but changing to shallow types gives the &lt;em&gt;X&lt;/em&gt; behavior! Here are their stories.&lt;/p&gt;

&lt;p&gt;Going forward, &lt;strong&gt;Deep&lt;/strong&gt; refers to normal Typed Racket and &lt;strong&gt;Shallow&lt;/strong&gt; refers to Shallow Typed Racket.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id="higher-order-value-as-any"&gt;Higher-Order Value as Any&lt;/h2&gt;

&lt;p&gt;Original message : &lt;a href="https://groups.google.com/g/racket-users/c/cCQ6dRNybDg/m/CKXgX1PyBgAJ"&gt;groups.google.com/g/racket-users/c/cCQ6dRNybDg/m/CKXgX1PyBgAJ&lt;/a&gt;&lt;/p&gt;

&lt;h4 id="on-20180416-mailoo-wrote"&gt;On 2018&amp;ndash;04&amp;ndash;16, &lt;em&gt;mailoo&lt;/em&gt; wrote:&lt;/h4&gt;

&lt;blockquote&gt;
 &lt;p&gt; I play a little with the &amp;ldquo;Any&amp;rdquo; type (due to &amp;lsquo;dynamic-require&amp;rsquo; which   return Any), and I&amp;rsquo;m not able to cast them back in a function.&lt;/p&gt;
 &lt;p&gt; I (over) simplify my question with this little program :&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;(: p Any) 
(define (p i) (displayln i)) 

; Here I want to get back my function 
(define proc (cast p (-&amp;gt; Integer Void))) 
(proc 2) &lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
 &lt;p&gt; but I get this error when I try to execute the function :&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;; contract violation 
; Attempted to use a higher-order value passed as `Any` in untyped code: #&amp;lt;procedure:p&amp;gt; &lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="whats-going-on"&gt;What&amp;rsquo;s going on?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Deep&lt;/strong&gt; raises an error because it must enforce the &lt;code&gt;Any&lt;/code&gt; type with a contract that  rejects all interactions. Things would go badly if an Any-typed function expected a String but got an  Integer.&lt;/p&gt;

&lt;h3 id="hows-transient"&gt;How&amp;rsquo;s transient?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Shallow&lt;/strong&gt; prints 2 and returns void. No error. Same goes for dynamic-require.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id="parametric-contract-affects-untyped-code"&gt;Parametric Contract Affects Untyped Code&lt;/h2&gt;

&lt;p&gt;Original message : &lt;a href="https://groups.google.com/g/racket-users/c/ZbYRQCy93dY/m/kF_Ek0VvAQAJ"&gt;groups.google.com/g/racket-users/c/ZbYRQCy93dY/m/kF_Ek0VvAQAJ&lt;/a&gt;&lt;/p&gt;

&lt;h4 id="on-20191215-john-clements-wrote"&gt;On 2019&amp;ndash;12&amp;ndash;15, John Clements wrote:&lt;/h4&gt;

&lt;blockquote&gt;
 &lt;p&gt; It looks like my quick attempt at importing index-of into TR is running into a problem. Here’s the program I ran:&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;  #lang typed/racket 

  (require/typed racket/list 
  [index-of (All (T) ((Listof T) T -&amp;gt; (U False Natural)))]) 

  (index-of '(n s e w) 'n) ;; returns... #f? &lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
 &lt;p&gt; In typed/racket/no-check this returns 0, and also in racket (mutatis mutandis).&lt;/p&gt;
 &lt;p&gt; I thought this might be some kind of parametricity issue, but even when I instantiate index-of at Symbol which should pretty much clear the way for arbitrary equality checking, I still get False.&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3 id="whats-going-on"&gt;What&amp;rsquo;s going on?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Deep&lt;/strong&gt; enforces parametricity for &lt;code&gt;All&lt;/code&gt; types, and this throws off the equality  function that index-of uses internally.&lt;/p&gt;

&lt;h3 id="hows-transient"&gt;How&amp;rsquo;s transient?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Shallow&lt;/strong&gt; returns 0.&lt;/p&gt;

&lt;p&gt;ps John, thanks very much for working on &lt;a href="https://adventofcode.com"&gt;Advent of Code&lt;/a&gt; and mailing the list!&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id="unable-to-protect-opaque-value-as-any"&gt;Unable to Protect Opaque Value as Any&lt;/h2&gt;

&lt;p&gt;Original message : &lt;a href="https://groups.google.com/g/racket-users/c/jtmVDFCGL28/m/jwl4hsjtBQAJ"&gt;groups.google.com/g/racket-users/c/jtmVDFCGL28/m/jwl4hsjtBQAJ&lt;/a&gt;&lt;/p&gt;

&lt;h4 id="on-20191211-marc-kaufmann-wrote"&gt;On 2019&amp;ndash;12&amp;ndash;11, Marc Kaufmann wrote:&lt;/h4&gt;

&lt;blockquote&gt;
 &lt;p&gt;I have one file called &lt;code&gt;type-test.rkt&lt;/code&gt; with the following&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;#lang typed/racket

(require (only-in typed/web-server/http response/xexpr response))

(provide f2)

(: f2 (-&amp;gt; (U response Any)))
(define (f2)
  (define x '(body (h1 "Try it")))
  (: resp response)
  (define resp (response/xexpr x))
  resp)&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
 &lt;p&gt;Then I have another &lt;em&gt;untyped&lt;/em&gt; file for a servlet:&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;#lang racket

(require "type-test.rkt"
         web-server/servlet
         web-server/servlet-env)

(define (start req)
  (f2))

(serve/servlet start
               #:servlet-regexp #rx""
               #:launch-browser? #false
               #:port 8080)&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
 &lt;p&gt;Notice that I am telling [f2] that &lt;code&gt;resp&lt;/code&gt; is of type &lt;code&gt;response&lt;/code&gt;. Yet, when I run the server with &lt;code&gt;start&lt;/code&gt; [&amp;hellip;.] I get the following result:&lt;/p&gt;
 &lt;p&gt;(f2): Error, see below.&lt;/p&gt;
 &lt;p&gt;The error is:&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;f2: broke its own contract
  any-wrap/c: Unable to protect opaque value passed as `Any`
  value: #&amp;lt;response&amp;gt;
  in: the range of
      (-&amp;gt; Any)&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="whats-going-on"&gt;What&amp;rsquo;s going on?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Deep&lt;/strong&gt; tries to enforce the &lt;code&gt;Any&lt;/code&gt; type with a contract that rejects all  interactions, but needs to know what interactions are possible in order  to make a reject-all contract. For many values, Deep can ask questions like procedure? and struct-info  to learn enough. But this program sends an opaque response struct across a boundary and  Deep does not have the right inspector to learn about the struct fields.&lt;/p&gt;

&lt;h3 id="hows-transient"&gt;How&amp;rsquo;s transient?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Shallow&lt;/strong&gt; does nothing to enforce the Any type. This program runs, and in general Shallow never complains about opaque values.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id="type-inference-installs-a-precise-type"&gt;Type Inference Installs a Precise Type&lt;/h2&gt;

&lt;p&gt;Original message : &lt;a href="https://groups.google.com/g/racket-users/c/2X5olKMV3C4/m/mJhsp9ZWBgAJ"&gt;groups.google.com/g/racket-users/c/2X5olKMV3C4/m/mJhsp9ZWBgAJ&lt;/a&gt;&lt;/p&gt;

&lt;h4 id="on-20200214-john-clements-wrote"&gt;On 2020&amp;ndash;02&amp;ndash;14, John Clements wrote:&lt;/h4&gt;

&lt;blockquote&gt;
 &lt;p&gt;I think I may understand what’s going on here, but a student and I worked on this for quite a while today before I found the problem.&lt;/p&gt;
 &lt;p&gt;Here’s a program:&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;#lang typed/racket 

(define-type Store (Mutable-HashTable Integer Value)) 
(define-type Value (U Real Boolean String)) 

(define top-store
  (cast
    (make-hash (list (cons -1 14) (cons 1 #t) (cons 2 #f)))
    Store))

(hash-set! top-store 5 1234)&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
 &lt;p&gt;It fails with this error:&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;contract violation
expected: (or/c (and/c byte? positive?) #t #f)
given: 1234
in: the values of
the 3rd conjunct of
(and/c hash?
       hash-mutable?
       (hash/c exact-integer?
               (or/c (and/c byte? positive?) #t #f)
               #:immutable #f))&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="whats-going-on"&gt;What&amp;rsquo;s going on?&lt;/h3&gt;

&lt;p&gt;First off, &lt;strong&gt;Deep&lt;/strong&gt; runs fine after swapping &lt;code&gt;cast&lt;/code&gt; for &lt;code&gt;ann&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Second, Typed Racket does try to generalize inferred types for mutable data. If the only value in the hash is the byte 14 then Deep also runs.&lt;/p&gt;

&lt;p&gt;The problem is that Typed Racket does not generalize the inferred value type  (U Byte Boolean) and that cast is a run-time tool for enforcing types. Casts create contracts to protect mutable data. In this program, there are two contracts:  one based on the Store type to protect code that uses the hash,  and one based on the inferred type to protect the hash against bad writes. That second contract raises the error message.&lt;/p&gt;

&lt;h3 id="hows-transient"&gt;How&amp;rsquo;s transient?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Shallow&lt;/strong&gt; runs successfully. The cast looks for a hash, does not make a contract, and ignores the inferred  type going forward.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id="same-arity-functions-in-a-case-lambda"&gt;Same-Arity Functions in a Case Lambda&lt;/h2&gt;

&lt;p&gt;Original message : &lt;a href="https://groups.google.com/g/racket-users/c/BDrrgW0axGQ/m/P31NxeGHAAAJ"&gt;groups.google.com/g/racket-users/c/BDrrgW0axGQ/m/P31NxeGHAAAJ&lt;/a&gt;&lt;/p&gt;

&lt;h4 id="on-20190705-ryan-kramer-wrote"&gt;On 2019&amp;ndash;07&amp;ndash;05, Ryan Kramer wrote:&lt;/h4&gt;

&lt;blockquote&gt;
 &lt;p&gt;In the code below, can &lt;code&gt;maybe-car&lt;/code&gt; have the given type [&amp;hellip;.]?&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;#lang typed/racket

(module untyped racket
  (provide maybe-car)
  (define (maybe-car x)
    (cond
      [(pair? x) (car x)]
      [else x])))

(require/typed
 'untyped
 [maybe-car (All (a b) (case-&amp;gt;
                        (-&amp;gt; (Pairof a b) a)
                        (-&amp;gt; a a)))])&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
 &lt;p&gt;[Current error:]&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;Type Checker:
 Type (All (a b) (case-&amp;gt; (-&amp;gt; (Pairof a b) a) (-&amp;gt; a a)))
  could not be converted to a contract:
   function type has two cases of arity 1&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="whats-going-on"&gt;What&amp;rsquo;s going on?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Deep&lt;/strong&gt; tries to enforce the type with a Racket &lt;code&gt;or/c&lt;/code&gt; contract, but cannot. The problem is that or/c only has partial support for unions. If or/c ends up with two possible higher-order options at runtime, it halts. In this case, we end up with two function contracts that have the same arity  and don&amp;rsquo;t know which to apply to an incoming function.&lt;/p&gt;

&lt;p&gt;Note, the &amp;ldquo;Type Checker&amp;rdquo; error message is much better than what or/c would  give on its own.&lt;/p&gt;

&lt;h3 id="hows-transient"&gt;How&amp;rsquo;s transient?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Shallow&lt;/strong&gt; simply checks that maybe-car accepts both arities inside the  case-&amp;gt; type. The code runs fine. Later, when the function gets applied in typed code, Shallow spot-checks the  results.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="immutable-type-affects-untyped-code"&gt;Immutable Type Affects Untyped Code&lt;/h3&gt;

&lt;p&gt;Original message : &lt;a href="https://groups.google.com/g/racket-users/c/UD20HadJ9Ec/m/Lmuw0U8mBwAJ"&gt;groups.google.com/g/racket-users/c/UD20HadJ9Ec/m/Lmuw0U8mBwAJ&lt;/a&gt;&lt;/p&gt;

&lt;h4 id="on-20200217-bertrand-augereau-wrote"&gt;On 2020&amp;ndash;02&amp;ndash;17, Bertrand Augereau wrote:&lt;/h4&gt;

&lt;blockquote&gt;
 &lt;p&gt;Hello everybody, I&amp;rsquo;m trying to gradually type my script to make it a proper app (yes I&amp;rsquo;m a static-ish guy) and I have an issue (Racket 7.6 CS).&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;; racket_mod.rkt:
#lang racket

(provide (struct-out s))
(provide list-of-s)
(provide set-list-of-s!)

(struct s (a))
(define list-of-s '())
(define (set-list-of-s! los)
  (set! list-of-s los))&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;; racket_mod_typed.rkt:
#lang typed/racket

(provide (struct-out s2))
(provide list-of-s2)
(provide set-list-of-s2!)

(struct s2 ([a : Natural]))
(define list-of-s2 '())
(define (set-list-of-s2! [los : (Listof s2)])
  (set! list-of-s2 los))&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;; racket_main.rkt:
#lang racket

(require "racket_mod.rkt")
(require "racket_mod_typed.rkt")

(define los (list (s 1) (s 2)))
(set-list-of-s! los)
(displayln list-of-s)

(define los2 (list (s2 1) (s2 2)))
(set-list-of-s2! los2)
(displayln list-of-s2)&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
 &lt;p&gt;list-of-s2 is empty and list-of-s is not, the only difference seems to be the type annotations. Can someone help me ? :)&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3 id="whats-going-on"&gt;What&amp;rsquo;s going on?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Deep&lt;/strong&gt; enforces the type of &lt;code&gt;list-of-s2&lt;/code&gt; with a listof contract, which  ends up making a copy of the original (empty) list as it traverses and  validates it. The original value does change in typed code, but the main module only has  access to the empty copy.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a step-by-step breakdown:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;the typed module creates an empty list-of-s2&lt;/li&gt;
 &lt;li&gt;the main module imports the list and receives a new copy&lt;/li&gt;
 &lt;li&gt;the main module calls set-list-of-s2! and the typed module updates the original list-of-s2 variable&lt;/li&gt;
 &lt;li&gt;the main module reads from its copy &amp;mdash; and it&amp;rsquo;s still empty&lt;/li&gt;&lt;/ol&gt;

&lt;h3 id="hows-transient"&gt;How&amp;rsquo;s transient?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Shallow&lt;/strong&gt; lets the original list travel to untyped code. There are no contracts in the way.&lt;/p&gt;

&lt;h2 id="discussion"&gt;Discussion&lt;/h2&gt;

&lt;p&gt;Wow! It&amp;rsquo;s great to see that Shallow Racket works &amp;ldquo;as expected&amp;rdquo; on these examples. I hope the Shallow option makes types more accessible to more Racket programmers  in the future.&lt;/p&gt;

&lt;p&gt;If you have a similar experience with a deep-types error, let me know.&lt;/p&gt;

&lt;p&gt;Keep in mind, though, the freedoms of shallow types allow silent failures. A value can pass by a mis-matched type annotation without Shallow raising an  error &amp;mdash; and if that happens, the end result may be really, really confusing. Of course you can always switch back to Deep Typed Racket for debugging.&lt;/p&gt;

&lt;p&gt;Shallow Typed Racket is coming soon. Follow the &lt;a href="https://github.com/racket/typed-racket/pull/948"&gt;pull request&lt;/a&gt;  or watch the Racket release notes for news.&lt;/p&gt;

&lt;h3 id="links"&gt;Links&lt;/h3&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://prl.ccs.neu.edu/blog/2019/10/31/complete-monitors-for-gradual-types/"&gt;Larger example&lt;/a&gt;  where Shallow misses an error that Deep catches&lt;/li&gt;
 &lt;li&gt;Michael M. Vitousek &lt;a href="http://hdl.handle.net/2022/23172"&gt;invented&lt;/a&gt;  the Transient semantics and implemented it in  &lt;a href="https://github.com/mvitousek/reticulated"&gt;Reticulated Python&lt;/a&gt;.&lt;/li&gt;
 &lt;li&gt;My &lt;a href="https://ccs.neu.edu/home/types/publications/publications.html#g-thesis-2020"&gt;upcoming dissertation&lt;/a&gt;  has lots more to say about Shallow Typed Racket.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Thanks to Artem Pelenitsyn for reading and criticizing an early version of this post.&lt;/em&gt;&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">The Typed Racket Optimizer vs. Transient</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2020/01/15/the-typed-racket-optimizer-vs-transient/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2020-01-15-the-typed-racket-optimizer-vs-transient</id>
  <published>2020-01-15T12:16:35Z</published>
  <updated>2020-01-15T12:16:35Z</updated>
  <author>
   <name>Ben Greenman</name></author>
  <content type="html">
&lt;p&gt;What type-directed optimizations does Typed Racket perform  and do any require full types?&lt;/p&gt;
&lt;!-- more--&gt;

&lt;blockquote&gt;
 &lt;p&gt;This post is based on a short talk. Slides from the talk are here: &lt;a href="http://ccs.neu.edu/home/types/resources/talks/prl-offsite-2019.pdf"&gt;http://ccs.neu.edu/home/types/resources/talks/prl-offsite-2019.pdf&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Standard Typed Racket guarantees full type soundness and uses higher-order  contracts to make sure that interactions between Typed Racket and untyped  Racket obey the types. These contracts can be very expensive [&lt;a href="https://doi.org/10.1017/S0956796818000217"&gt;JFP 2019&lt;/a&gt;]. And so, the standard types are very strong but (possibly) slow.&lt;/p&gt;

&lt;p&gt;Lately, I&amp;rsquo;ve been working on a &lt;a href="https://dl.acm.org/citation.cfm?id=3009849"&gt;transient&lt;/a&gt;  back-end for Typed Racket. Transient Typed Racket provides a weaker guarantee &amp;mdash; only that typed code  cannot get &amp;ldquo;stuck&amp;rdquo; &amp;mdash; via simpler run-time checks. Early data shows that these simple checks are often faster   than the standard boundary checks [&lt;a href="https://doi.org/10.1145/3236766"&gt;ICFP 2018&lt;/a&gt;],  hence we want both options for Typed Racket programmers: slow/correct  and fast/wrong.&lt;/p&gt;

&lt;p&gt;The implementation of Transient needs to re-use some parts of Standard Typed  Racket and modify others. Typed Racket comes with three major components:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;a static type checker,&lt;/li&gt;
 &lt;li&gt;a compiler from types to contracts, and&lt;/li&gt;
 &lt;li&gt;a type-driven optimizer [&lt;a href="https://www2.ccs.neu.edu/racket/pubs/padl12-stff.pdf"&gt;PADL 2012&lt;/a&gt;, &lt;a href="https://doi.org/10.1145/2384616.2384629"&gt;OOPSLA 2012&lt;/a&gt;].&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Transient Typed Racket can re-use all of the type checker  and parts of the type-to-contract compiler. The question for this post is: can Transient re-use the optimizer?&lt;/p&gt;

&lt;h2 id="q-can-transient-re-use-the-typed-racket-optimizer"&gt;Q. Can Transient re-use the Typed Racket optimizer?&lt;/h2&gt;

&lt;p&gt;The answer requires some thought because Standard Typed Racket and Transient  Typed Racket preserve different amounts of type information.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;In Standard Typed Racket, if an expression &lt;strong&gt;e&lt;/strong&gt; has type &lt;strong&gt;T&lt;/strong&gt; and reduces  to a value &lt;strong&gt;v&lt;/strong&gt; (for short, &lt;strong&gt;e : T &amp;mdash;&amp;gt;* v&lt;/strong&gt;), then the result &lt;strong&gt;v&lt;/strong&gt; definitely  matches the full type &lt;strong&gt;T&lt;/strong&gt;.&lt;/li&gt;
 &lt;li&gt;In Transient Typed Racket, if &lt;strong&gt;e : T &amp;mdash;&amp;gt;* v&lt;/strong&gt; then the result &lt;strong&gt;v&lt;/strong&gt; matches  the toplevel &amp;ldquo;shape&amp;rdquo; of &lt;strong&gt;T&lt;/strong&gt; but (maybe) nothing more.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The idea of a &amp;ldquo;shape&amp;rdquo; is that it corresponds to the outermost constructor of  a type. A shape check must be decidable, but otherwise finding the best shape for a type  is an engineering challenge. On one hand, deeper checks give stronger guarantees. On the other hand, shallower checks are quicker to validate.&lt;/p&gt;

&lt;p&gt;Here are a few shapes according to the current Transient prototype:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Shape(Natural)                = Natural
  Shape(Listof String)          = Listof Any
  Shape(Symbol -&amp;gt; Boolean)      = Any -&amp;gt; Any
  Shape(Vector Void Void)       = Vector Any Any
  Shape(U Void (Listof Symbol)) = U Void (Listof Any)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the current shapes, can we re-use the Typed Racket optimizer?&lt;/p&gt;

&lt;h2 id="optimization-topics"&gt;Optimization Topics&lt;/h2&gt;

&lt;p&gt;Typed Racket implements 15 kinds of type-directed transformation. Below, each gets: a short description, an example, and a verdict of &amp;ldquo;safe&amp;rdquo;  or &amp;ldquo;unsafe&amp;rdquo; for Transient.&lt;/p&gt;

&lt;p&gt;To be clear: some optimization topics perform many kinds of transformations, but this post picks only one example transformation for each.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-1-apply"&gt;Topic 1: apply&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/apply.rkt"&gt;apply.rkt&lt;/a&gt;  &amp;ldquo;inlines&amp;rdquo; expressions of the form &lt;code&gt;(apply f (map g xs))&lt;/code&gt; to map and fold  in one pass over the list (&lt;code&gt;xs&lt;/code&gt;). Currently, the pass only triggers when &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: xs (Listof Integer))

  ;; --------------------------------------------------
  ;; Before Optimization
  (apply + (map abs xs))

  ;; --------------------------------------------------
  ;; After Optimization
  (let loop ((v 0)
             (lst xs))
    (if (null? lst)
      v
      (loop (+ v (abs (unsafe-car lst)))
            (unsafe-cdr lst))))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe, but risky.&lt;/p&gt;

&lt;p&gt;Technically, this transformation is unsound for Transient because of how it uses &lt;code&gt;unsafe-car&lt;/code&gt;. The expansion of &lt;code&gt;(apply * (map g xs))&lt;/code&gt; applies &lt;code&gt;(g (unsafe-car xs))&lt;/code&gt; without  confirming that the first element of &lt;code&gt;xs&lt;/code&gt; matches its expected type. This unsoundness is no problem, though, as long as &lt;em&gt;every&lt;/em&gt; Transient-typed function  checks the shape of its input. (Typed functions that flow to untyped code already need to check inputs.)&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-2-box"&gt;Topic 2: box&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/box.rkt"&gt;box.rkt&lt;/a&gt;  safely applies unsafe box operations to expressions with &lt;code&gt;Box&lt;/code&gt; type.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: b (Boxof Symbol))

  ;; --------------------------------------------------
  ;; Before Optimization
  (unbox b)

  ;; --------------------------------------------------
  ;; After Optimization
  (unsafe-unbox b)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-3-dead-code"&gt;Topic 3: dead-code&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/dead-code.rkt"&gt;dead-code.rkt&lt;/a&gt;  uses type information to identify code that cannot run. Once identified, the TR optimizer makes the dead code obvious for the Racket  bytecode compiler. The pass deals with &lt;code&gt;if&lt;/code&gt; expressions, &lt;code&gt;lambda&lt;/code&gt; expressions, and &lt;code&gt;case-lambda&lt;/code&gt;;  the latter is the most interesting for Transient.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: f (-&amp;gt; Symbol Symbol)

  ;; --------------------------------------------------
  ;; Before Optimization
  (define f
    (case-lambda
      ((s) s)
      ((s i)
       (for/list ((_i (in-range i))) s))))

  ;; --------------------------------------------------
  ;; After Optimization
  (define f
    (case-lambda
      ((s) s)
      ((s i)
       ; dead code, replace with no-op
       (void))))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: unsafe, can change behavior&lt;/p&gt;

&lt;p&gt;The pass infers that some branches of a &lt;code&gt;case-lambda&lt;/code&gt; can never run because  the type says they do not exist. In Standard Typed Racket, this inference is correct because a run-time contract  seals off the &amp;ldquo;untyped&amp;rdquo; branches. In Transient, though, there is no need to add a contract and therefore no  guarantee these branches are inaccessible. An application in untyped code can enter the dead branch;  if it does, then adding Transient types to part of a program can change  its result to &lt;code&gt;(void)&lt;/code&gt; and thereby violate the graduality design goal [&lt;a href="http://drops.dagstuhl.de/opus/volltexte/2015/5031/"&gt;SNAPL 2015&lt;/a&gt;, &lt;a href="https://doi.org/10.1145/3236768"&gt;ICFP 2018&lt;/a&gt;]  &amp;mdash; that is, that adding types should only change behavior by introducing runtime  type mismatches.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-4-extflonum"&gt;Topic 4: extflonum&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/extflonum.rkt"&gt;extflonum.rkt&lt;/a&gt;  safely applies unsafe extflonum operations to expressions with &lt;code&gt;Extflonum&lt;/code&gt; type.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: e Extflonum)

  ;; --------------------------------------------------
  ;; Before Optimization
  (extflabs e)

  ;; --------------------------------------------------
  ;; After Optimization
  (unsafe-extflabs e)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-5-fixnum"&gt;Topic 5: fixnum&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/fixnum.rkt"&gt;fixnum.rkt&lt;/a&gt;  safely applies unsafe fixnum operations to expressions with &lt;code&gt;Fixnum&lt;/code&gt; type.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: f Fixnum)

  ;; --------------------------------------------------
  ;; Before Optimization
  (exact-&amp;gt;inexact f)

  ;; --------------------------------------------------
  ;; After Optimization
  (unsafe-fx-&amp;gt;fl f)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-6-float-complex"&gt;Topic 6: float-complex&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/float-complex.rkt"&gt;float-complex.rkt&lt;/a&gt;  unboxes complex numbers (into one real-part variable and one imaginary-part variable)  and rewrites operations to handle the unboxed numbers.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: f (-&amp;gt; Float-Complex Float-Complex Float-Complex))

  ;; --------------------------------------------------
  ;; Before Optimization
  (define (f n0 n1)
    (+ n0 n1))

  ;; --------------------------------------------------
  ;; After Optimization
  (define (f n0 n1)
    (let* ((unboxed-real-0 (unsafe-flreal-part n0))
           (unboxed-imag-0 (unsafe-flimag-part n0))
           (unboxed-real-1 (unsafe-flreal-part n1))
           (unboxed-imag-1 (unsafe-flimag-part n1))
           (unboxed-real-2 (unsafe-fl+ (real-&amp;gt;double-flonum unboxed-real-0)
                                       unboxed-real-1))
           (unboxed-imag-2 (unsafe-fl+ (real-&amp;gt;double-flonum unboxed-imag-0)
                                       unboxed-imag-1)))
      (unsafe-make-flrectangular unboxed-real-2 unboxed-imag-2)))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe, with caution&lt;/p&gt;

&lt;p&gt;The body of a Transient-typed function (that can flow to untyped code)  must first check that its inputs have the correct shape. Currently, the &lt;strong&gt;float-complex&lt;/strong&gt; pass creates functions that apply &lt;code&gt;unsafe-flreal-part&lt;/code&gt; before  anything else; to be safe, the pass needs to make sure that Transient checks  come first.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-7-float"&gt;Topic 7: float&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/float.rkt"&gt;float.rkt&lt;/a&gt;  safely applies unsafe flonum operations to expressions with &lt;code&gt;Flonum&lt;/code&gt; type  and also transforms some &lt;code&gt;random&lt;/code&gt; calls to use &lt;code&gt;unsafe-flrandom&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; --------------------------------------------------
  ;; Before Optimization
  (random)

  ;; --------------------------------------------------
  ;; After Optimization
  (unsafe-flrandom (current-pseudo-random-generator))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe, but a close call&lt;/p&gt;

&lt;p&gt;Accessing a parameter, as in &lt;code&gt;(current-pseudo-random-generator)&lt;/code&gt;, is an  elimination form that may require a shape check. This particular parameter, however, is protected by a contract that enforces  the precondition of &lt;code&gt;unsafe-flrandom&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-8-list"&gt;Topic 8: list&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/list.rkt"&gt;list.rkt&lt;/a&gt;  safely applies unsafe list operations to list expressions.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: lst (List Symbol Symbol))

  ;; --------------------------------------------------
  ;; Before Optimization
  (list-ref lst 0)

  ;; --------------------------------------------------
  ;; After Optimization
  (unsafe-list-ref lst 0)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe, with strong-enough shape checks&lt;/p&gt;

&lt;p&gt;The shape check for a &lt;code&gt;(Listof T)&lt;/code&gt; must check for proper lists (via &lt;code&gt;list?&lt;/code&gt;);  note that the cost of this check depends on the size of incoming values. The shape check for a &lt;code&gt;(List T ...)&lt;/code&gt; type must validate the length of incoming  values.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-9-number"&gt;Topic 9: number&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/number.rkt"&gt;number.rkt&lt;/a&gt;  performs simple transformations on &lt;code&gt;Real&lt;/code&gt;-valued expressions.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: r Real)

  ;; --------------------------------------------------
  ;; Before Optimization
  (+ r)

  ;; --------------------------------------------------
  ;; After Optimization
  r&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-10-pair"&gt;Topic 10: pair&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/pair.rkt"&gt;pair.rkt&lt;/a&gt;  safely applies pair-access operations to (possibly-nested) pairs.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: p (Pairof (Pairof Symbol Void) String))

  ;; --------------------------------------------------
  ;; Before Optimization
  (cdar p)

  ;; --------------------------------------------------
  ;; After Optimization
  (unsafe-cdr (unsafe-car p))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: unsafe&lt;/p&gt;

&lt;p&gt;Transient guarantees the first level of a type, but nothing more. Concretely, &lt;code&gt;Shape(Pairof (Pairof Symbol Void) String) = Pairof Any Any&lt;/code&gt;  and so the &lt;code&gt;unsafe-cdr&lt;/code&gt; above is not safe.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-11-sequence"&gt;Topic 11: sequence&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/sequence.rkt"&gt;sequence.rkt&lt;/a&gt;  safely applies unsafe sequence operations to expressions with &lt;code&gt;(Sequenceof T)&lt;/code&gt; type.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: s String)

  ;; --------------------------------------------------
  ;; Before Optimization
  (for ((c s))
    (void))

  ;; --------------------------------------------------
  ;; After Optimization (simplified)
  (for ((c (in-string s)))
    (void))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe, with strong enough shape checks (see &lt;strong&gt;list&lt;/strong&gt; and &lt;strong&gt;vector&lt;/strong&gt;)&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-12-string"&gt;Topic 12: string&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/string.rkt"&gt;string.rkt&lt;/a&gt;  safely applies unsafe string operations to expressions with &lt;code&gt;String&lt;/code&gt; type. (Note that &lt;code&gt;unsafe-string-ref&lt;/code&gt; is only safe when the result is sure to be  a Latin&amp;ndash;1 character.)&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: b Bytes)

  ;; --------------------------------------------------
  ;; Before Optimization
  (bytes-length b)

  ;; --------------------------------------------------
  ;; After Optimization
  (unsafe-bytes-length b)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-13-struct"&gt;Topic 13: struct&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/struct.rkt"&gt;struct.rkt&lt;/a&gt;  safely applies unsafe struct operations to struct expressions, using  Typed Racket&amp;rsquo;s &lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/types/struct-table.rkt"&gt;internal registry of struct info&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (struct open-interval ([lo : Real] [hi : Real]))
  (: ivl open-interval)

  ;; --------------------------------------------------
  ;; Before Optimization
  (open-interval-lo ivl)

  ;; --------------------------------------------------
  ;; After Optimization
  (unsafe-struct-ref ivl 0)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-14-unboxed-let"&gt;Topic 14: unboxed-let&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/unboxed-let.rkt"&gt;unboxed-let.rkt&lt;/a&gt;  cooperates with the &lt;code&gt;float-complex&lt;/code&gt; pass by transforming the binding-site  of some complex numbers. This pass may change a &lt;code&gt;let&lt;/code&gt;-expression into a &lt;code&gt;let-values&lt;/code&gt; that expects  a real-part and imag-part, and may change a function to expect twice as many  arguments &amp;mdash; provided the optimizer can find &lt;em&gt;all&lt;/em&gt; calls to the function.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: k Float-Complex)

  ;; --------------------------------------------------
  ;; Before Optimization
  (let ((f (lambda ((n : Float-Complex)) (+ n n))))
    (f k))

  ;; --------------------------------------------------
  ;; After Optimization
  (let ((f (lambda (real-part-n imag-part-n) ....)))
    (f (unsafe-flreal-part k) (unsafe-flimag-part k)))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe, thanks to the (conservative) escape analysis&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="topic-15-vector"&gt;Topic 15: vector&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/optimizer/vector.rkt"&gt;vector.rkt&lt;/a&gt;  safely applies vector operations to vector expressions.&lt;/p&gt;

&lt;h4 id="example"&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  ;; Type Assumptions
  (: v (Vector (Listof Symbol) String))
  (: lst (Listof Symbol))

  ;; --------------------------------------------------
  ;; Before Optimization
  (vector-set! v lst 0)

  ;; --------------------------------------------------
  ;; After Optimization
  (unsafe-vector-set! v lst 0)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Verdict&lt;/strong&gt;: safe, with strong-enough shape checks&lt;/p&gt;

&lt;p&gt;The check for &lt;code&gt;(Vector T ...)&lt;/code&gt; must check the length of incoming values.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;

&lt;p&gt;The Typed Racket optimizer implements 15 kinds of transformations. Two are definitely unsafe for Transient as-is (&lt;strong&gt;dead-code&lt;/strong&gt;, &lt;strong&gt;pair&lt;/strong&gt;). One must take care when rewriting a Transient function (&lt;strong&gt;float-complex&lt;/strong&gt;). One may limit our ability to reduce the number of run-time checks in a program (&lt;strong&gt;apply&lt;/strong&gt;). Two others require transient checks whose cost depends on the size of the input values (&lt;strong&gt;list&lt;/strong&gt;, &lt;strong&gt;sequence&lt;/strong&gt;).&lt;/p&gt;

&lt;p&gt;There may be other issues that I missed while reading the optimizer code. If so, I&amp;rsquo;ll try to remember to update this post.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">PRL Offsite 2019 Retrospective</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2019/12/12/prl-offsite-2019-retrospective/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2019-12-12-prl-offsite-2019-retrospective</id>
  <published>2019-12-12T12:51:53Z</published>
  <updated>2019-12-12T12:51:53Z</updated>
  <author>Ben Greenman</author>
  <author>Olek Gierczak</author>
  <author>
   <name>Ben Greenman, Olek Gierczak</name></author>
  <content type="html">
&lt;p&gt;On November 11th 2019, the PRL had a private offsite meeting at the  &lt;a href="https://mtwyouth.org"&gt;More Than Words bookstore&lt;/a&gt; in downtown Boston. For future offsite organizers, this post records what happened and how.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h2 id="early-planning-goals"&gt;Early Planning, Goals&lt;/h2&gt;

&lt;p&gt;Every Fall, the PRL holds a kickoff meeting to assign  &lt;a href="http://prl.ccs.neu.edu/contact"&gt;roles&lt;/a&gt; for the coming academic year. This year, Prof. Amal Ahmed led the meeting and expressed interest in having  a retreat at some point. Seconds later, Amal enlisted Olek Gierczak and Ben Greenman  to help plan a retreat.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Ben G. was on the (unsuccessful) 2018 retreat planning committee. The three lessons from that year were: (1) Veterans Day is a possible date in the Fall, (2) there are approximately zero possible dates in the Spring and Summer, (3) the &lt;a href="http://www.warrencenter.com"&gt;Warren Conference Center&lt;/a&gt; is &lt;a href="https://www.northeastern.edu/events/northeastern-owned-off-campus-venues"&gt;Northeastern University&amp;rsquo;s only franchised&lt;/a&gt; off-campus venue.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The &lt;strong&gt;motivation&lt;/strong&gt; for the retreat was to bring our growing department together  for one day in the hope that everyone has (at least) a small interaction with  everyone else. These little interactions are crucial for new Ph.D. students &amp;mdash; both to get  to know the group, and to become known. They&amp;rsquo;re also useful for everyone else to build a stronger community and  to open doors for collaboration. And yet, despite the fact that these interactions are an admittedly key benefit  of having a lab, the last time the PRL got all together in a big way (more  than a few hours for PL seminar or Ph.D. open house) was for the  &lt;a href="http://www.ccs.neu.edu/home/matthias/7480-s17/index.html"&gt;Spring 2017 edition&lt;/a&gt;  of HOPL.&lt;/p&gt;

&lt;p&gt;Our primary &lt;strong&gt;goal&lt;/strong&gt; this year was for every Ph.D student to present research. Time permitting, we wanted a keynote speaker, a panel discussion, and activities. Weather permitting, we wanted to go outside during lunch.&lt;/p&gt;

&lt;p&gt;In light of the main goal, we prefer to call the event an &amp;ldquo;offsite&amp;rdquo;  (or &amp;ldquo;offsite meeting&amp;rdquo;) rather than a &amp;ldquo;retreat&amp;rdquo; because the target was an  informative day rather than a relaxing one.&lt;/p&gt;

&lt;h2 id="booking-and-logistics"&gt;Booking and Logistics&lt;/h2&gt;

&lt;p&gt;Our planning went like this: (1) pick a date, (2) find a venue, (3) invite a keynote  speaker, (4) order food, and (5) arrange the technical program. The process took 2 months because that&amp;rsquo;s all we had.&lt;/p&gt;

&lt;h3 id="date--nov-11"&gt;Date = Nov 11&lt;/h3&gt;

&lt;p&gt;In the beginning, we chose Veterans&amp;rsquo; Day (2019&amp;ndash;11&amp;ndash;11) and Northeastern &lt;a href="https://registrar.northeastern.edu/app/uploads/2019-2020-University-Wide-Calendar-List.pdf"&gt;reading  day&lt;/a&gt;  (2019&amp;ndash;12&amp;ndash;05) as possible dates. We ended up with Veterans&amp;rsquo; Day.&lt;/p&gt;

&lt;p&gt;A small number of lab members were opposed to Veterans&amp;rsquo; Day. They gave two reasons: the Fall semester is especially busy, and Veterans&amp;rsquo; Day  is a federal holiday.&lt;/p&gt;

&lt;h3 id="venue--mtw"&gt;Venue = MTW&lt;/h3&gt;

&lt;p&gt;The first venue we tried was the &lt;a href="http://www.warrencenter.com"&gt;Warren Conference Center&lt;/a&gt; in  Framingham. The venue was difficult to contact. We submitted an online form; no response. We searched the website for contact email addresses; no luck. We called the office, got forwarded to the event manager, and left a message; no response. Lastly we asked the &lt;a href="https://www.khoury.northeastern.edu/people/chelsea-smith/"&gt;Khoury Events Team&lt;/a&gt;  to reach out on our behalf. They returned with an email address and  &lt;a href="/blog/static/warren-center-meetings-and-retreats.pdf"&gt;event menu&lt;/a&gt;  (Thank you Chelsea and Donald!)  and we decided the Warren Center was not a good fit for our small and short-notice offsite.&lt;/p&gt;
&lt;!-- Donald Pepple (Northeastern) made contact with Christine Barisano (Framingham)--&gt;

&lt;p&gt;Second, we contacted the &lt;a href="https://alumni.northeastern.edu/about/alumni-center/"&gt;Northeastern University Alumni Center&lt;/a&gt;. They were not open on Veterans&amp;rsquo; Day 2019.&lt;/p&gt;

&lt;p&gt;Third, we turned to Google and Yelp for venue options in New England. Most were at a corporate-level price range, but this search led to our  winner: &lt;a href="https://mtwyouth.org"&gt;More Than Words&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;More Than Words (MTW) is a bookstore and event space. We got in touch via email, visited the store, and then booked. Easy!&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;More Than Words is also a nonprofit social enterprise that offers job training for ~350 young adults each year. If you visit, you&amp;rsquo;ll see a mix of &amp;ldquo;employees&amp;rdquo; and &amp;ldquo;volunteers&amp;rdquo; helping out.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Booking was complicated, though, by the fact that Northeastern requires  &lt;a href="http://catalog.northeastern.edu/graduate/health-sciences/academic-policies-procedures/liability-insurance/"&gt;liability insurance&lt;/a&gt;  for all off-campus events. If &lt;strong&gt;you&lt;/strong&gt; are booking an event, get a contract from the venue well ahead  of time and allow 2 to 4 weeks for Northeastern to process and sign it. We received our contract with 1 week until the payment was due and were very  fortunate that the Northeastern administrative staff met the deadline.&lt;/p&gt;

&lt;p&gt;Here are more facts about MTW:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;the theater space seats 30 with lots of extra space&lt;/li&gt;
 &lt;li&gt;the two long tables in the reading room can seat about 20&lt;/li&gt;
 &lt;li&gt;the projector is 16:9 native and accepts HDMI input; bring your own HDMI adaptor&lt;/li&gt;
 &lt;li&gt;there&amp;rsquo;s no whiteboard, but MTW can supply an easel stand&lt;/li&gt;
 &lt;li&gt;much of the furniture in store is antique and for sale, so be careful using  it &amp;mdash; both to avoid damaging it, and because antiques can be oddly-shaped&lt;/li&gt;
 &lt;li&gt;the bookstore was closed on Veterans&amp;rsquo; Day, but we were able to have our  event and buy books&lt;/li&gt;
 &lt;li&gt;MTW may have fridge space to temporarily hold leftovers&lt;/li&gt;
 &lt;li&gt;closest T station: &lt;a href="https://www.mbta.com/stops/place-tumnl"&gt;Tufts Medical Center&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h3 id="keynote--none"&gt;Keynote = None&lt;/h3&gt;

&lt;p&gt;The original, ambitious plan was to invite two keynote speakers &amp;mdash; one working  in industry and one from academia &amp;mdash; to enrich the offsite  with new knowledge. And because this was the PRL&amp;rsquo;s first offsite, it was decided that these speakers  must have roughly-equal research overlap with every Ph.D. student. (Later meetings could specialize.)&lt;/p&gt;

&lt;p&gt;We failed to come up with many candidates that met our goal, and so we  fell back to a simpler plan: pick one. To this end, we sent out a Google Form to assess preferences and research overlap. The form responses indicated a clear favorite, who we invited.&lt;/p&gt;

&lt;p&gt;Our chosen speaker, however, was unable to attend. Rather than invite a different guest, we replaced the keynote time with a  morning activity (more on that later).&lt;/p&gt;
&lt;!-- to future planners: we invited Kathi Fisler; she had grant-writing plans for that day and would be interested in coming to a future offsite--&gt;

&lt;h3 id="food-coffee-tea"&gt;Food, Coffee, Tea&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://flourbakery.com/"&gt;Flour Bakery + Cafe&lt;/a&gt; provided lunch. For most days, you can order from Flour using an &lt;a href="https://flourbakery.com/menu/catering/catering-information/"&gt;online form&lt;/a&gt;. For holidays, you may need to send an email &amp;mdash; that&amp;rsquo;s what we did, and  the catering staff quickly helped us place an order. We ordered 16 assorted meat sandwiches, 16 assorted veggie sandwiches, 4 vegan hummus  sandwiches, and 2 vegan &amp;amp; gluten-free &lt;em&gt;everything spiced&lt;/em&gt; salads.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://www.trycuppacoffee.com/location/"&gt;Cuppacoffee&lt;/a&gt; provided coffee, tea,  and breakfast items. In the morning, that was: 3 gallons coffee, 1 gallon brewed black tea,  16 bagels, 12 muffins, and 10 croissants. In the afternoon, that was: 2 gallons coffee and 1 gallon brewed green tea. We were able to pick up everything &amp;mdash; the order + napkins, milk, cream cheese,  butter, and knives &amp;mdash; ourselves because Cuppacoffee is very close to MTW.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://www.cmartboston.com/"&gt;CMart&lt;/a&gt; sold us water and juices. (There is also a Whole Foods near MTW.)&lt;/p&gt;

&lt;p&gt;At the end of the day, the leftovers included ~2 gallons of coffee and ~8  sweet potato sandwiches. People asked for more meat sandwiches, more blueberry muffins,  and Flour&amp;rsquo;s &lt;a href="https://youtu.be/kIbhckqanHI"&gt;sticky buns&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id="event-program"&gt;Event Program&lt;/h3&gt;

&lt;p&gt;The following assumptions/goals constrained the schedule for the day:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;give all 17 on-campus Ph.D. students a talk slot;  talks must &lt;strong&gt;either&lt;/strong&gt; communicate one technical idea from recent  work &lt;strong&gt;or&lt;/strong&gt; say what led the speaker to apply to a PL Ph.D. program&lt;/li&gt;
 &lt;li&gt;allow at least 10 minutes per talk  (because the audience may have trouble following a day of 5-minute talks,  and the speakers may have trouble preparing informative 8-minute talks)&lt;/li&gt;
 &lt;li&gt;do not make the audience sit for more than 1 hour at a time&lt;/li&gt;
 &lt;li&gt;maximize the number and length of breaks (to encourage discussions)&lt;/li&gt;
 &lt;li&gt;include a relevant and fun welcome activity&lt;/li&gt;
 &lt;li&gt;save time for a panel discussion at the end, with everyone sitting around  a room able to freely ask questions&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;We decided to start with an hour-long activity, split the day into  hour-long blocks of three 15-minute talks (10 min. talk, 5 min. Q/A)  and one 15-minute break, and end with a 1.5-hour panel discussion. In total, we started the activity at 9:25am and ended the panel at 6:40pm.&lt;/p&gt;

&lt;p&gt;The activity was &lt;em&gt;codewalks&lt;/em&gt;. Before the offsite, we (the organizers) picked a few short and interesting programs  (for example, the &lt;a href="https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition/blob/master/src/main/java/com/seriouscompany/business/java/fizzbuzz/packagenamingpackage/impl/math/arithmetics/IntegerDivider.java"&gt;IntegerDivider&lt;/a&gt;  class from a silly FizzBuzz implementation and a solution to the  &lt;a href="https://en.wikipedia.org/wiki/Dutch_national_flag_problem"&gt;Dutch national flag problem&lt;/a&gt;). During breakfast, we made 2-person teams and gave each team a  printed copy of one program. Then, for the activity, we selected one team to present the code and three  panelists from the audience to lead a discussion. Discussions ran for about 10 minutes, and then we picked another team;  half the teams did not present. This activity ended up being fun (thanks to the great participants) and  definitely met its serious goals; namely, to practice reading, speaking, critical thinking, and  &lt;a href="https://blog.codinghorror.com/the-ten-commandments-of-egoless-programming/"&gt;egoless programming&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The talks ran conference-style. One organizer played &amp;ldquo;session chair&amp;rdquo; to help each speaker set up and  to announce each talk. Questions mid-talk were allowed, but most questions arrived after the speaker  finished.&lt;/p&gt;

&lt;p&gt;For the panel discussion, we put chairs around the room and asked people to  sit more-or-less comfortably. The panel moderator started by asking one question to the faculty, and  we took things from there as answers arrived and inspired new questions.&lt;/p&gt;

&lt;h2 id="looking-back-at-the-details"&gt;Looking Back at the Details&lt;/h2&gt;

&lt;p&gt;Reading Day in the Spring may be a good, free date for future retreats.&lt;/p&gt;

&lt;p&gt;We planned a 15-minute breakfast/welcome slot, but wound up needing 25 minutes  to give people time to prepare for the activity.&lt;/p&gt;

&lt;p&gt;The planned 15-minute breaks often had to be cut short because talks  ran longer. Next time, we&amp;rsquo;d keep the morning breaks short &amp;mdash; just enough to use the  restroom and grab a coffee &amp;mdash; and aim for 30-min breaks in the afternoon.&lt;/p&gt;

&lt;p&gt;Groups of three 15-minute talks worked well, but groups of four talks might  be equally good.&lt;/p&gt;

&lt;p&gt;Perhaps each speaker should get the chance to pick a talk length. &lt;a href="https://nepls.org/"&gt;NEPLS&lt;/a&gt;, for example, allows a choice between 5-min.  and 30-min. talks.&lt;/p&gt;

&lt;p&gt;The panel ended up too chaotic. People often had lots to say and it was difficult to queue questions during a  speech. One idea for next time is to seat the professors together and give each a time  limit to answer; this would organize the discussion, but may not improve the  quality. Another idea is to pick &amp;ldquo;topics&amp;rdquo; beforehand and have the moderator enforce a  time limit on each topic. Or maybe we should drop the panel unless we have a clear goal for what to discuss.&lt;/p&gt;
&lt;!-- to future organizers: the panel began asking faculty for a mistake in their career and wound up with a defensive flavor--&gt;

&lt;h2 id="looking-back-overall"&gt;Looking Back, Overall&lt;/h2&gt;

&lt;p&gt;This was a good offsite. Organizing was mostly easy and straightforward. We very much enjoyed hearing what everyone had been working on.&lt;/p&gt;

&lt;p&gt;There were two rough parts to the organizing. First, we faced some difficult initial choices about the date, venue, and program. Second, we feel that we put undue pressure on students to prepare talks  with short notice. Both challenges could easily be avoided next time &amp;mdash;  keep the same date &amp;amp; program, and announce the plan early! Maybe though, a different program could lead to a more effective use of time.&lt;/p&gt;

&lt;p&gt;With all that in mind, we recommend having a similar meeting next year or next  semester. It was extremely useful to sync up with the whole lab,  good practice to make a 10-minute talk,  and overall a rewarding (though stressful) day.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Complete Monitors for Gradual Types</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2019/10/31/complete-monitors-for-gradual-types/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2019-10-31-complete-monitors-for-gradual-types</id>
  <published>2019-10-31T21:58:26Z</published>
  <updated>2019-10-31T21:58:26Z</updated>
  <author>
   <name>Ben Greenman</name></author>
  <content type="html">
&lt;p&gt;Syntactic type soundness is too weak to tell apart different ways of running  a program that mixes typed and untyped code. Complete monitoring is a stronger property that captures a meaningful  distinction &amp;mdash; a language satisfies complete monitoring iff it checks  all interactions between typed and untyped code.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;blockquote&gt;
 &lt;p&gt;Note: this post is an extended abstract for the paper &lt;em&gt;Complete Monitors for Gradual Types&lt;/em&gt; by Ben Greenman, Matthias Felleisen, and Christos Dimoulas. For the full paper, proofs, and slides, &lt;a href="http://www.ccs.neu.edu/home/types/publications/publications.html#gfd-oopsla-2019"&gt;click here&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3 id="example-clickable-plot"&gt;Example: Clickable Plot&lt;/h3&gt;

&lt;p&gt;The program below has a subtle bug. Can you find it?&lt;/p&gt;

&lt;p&gt;&lt;img src="/img/complete-monitoring-0.png" alt="Untyped client code, a typed API, and untyped library code." /&gt;&lt;/p&gt;

&lt;p&gt;First of all, this pseudocode program combines three chunks of code:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;On the left, an &lt;strong&gt;untyped&lt;/strong&gt; client script defines a function &lt;code&gt;h&lt;/code&gt; that expects  a pair of numbers and returns an image. The client uses this function to  create a &lt;code&gt;ClickPlot&lt;/code&gt; object, and then displays the plot &amp;mdash; ideally in a new  GUI window.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;In the center, a &lt;strong&gt;typed&lt;/strong&gt; API file describes a &lt;code&gt;ClickPlot&lt;/code&gt; object as  something with one constructor and two methods. The constructor expects  a function; according to the type, such functions can expect a pair of  numbers and must compute an image. The &lt;code&gt;mouseHandler&lt;/code&gt; method expects  a &lt;code&gt;MouseEvt&lt;/code&gt; object and returns nothing. The &lt;code&gt;show&lt;/code&gt; method expects no arguments  and returns nothing. (Presumably, these methods have side effects.)&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;On the right, an &lt;strong&gt;untyped&lt;/strong&gt; library module implements a &lt;code&gt;ClickPlot&lt;/code&gt; object.  Most of the code is omitted (&lt;code&gt;...&lt;/code&gt;), but the &lt;code&gt;mouseHandler&lt;/code&gt; method sends  its input directly to the &lt;code&gt;onClick&lt;/code&gt; callback.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The &lt;strong&gt;bug&lt;/strong&gt; is in the API &amp;mdash; in the type &lt;code&gt;([N, N]) =&amp;gt; Image&lt;/code&gt;. This type promises that a given function can expect a pair of numbers,  and indeed the client function &lt;code&gt;h&lt;/code&gt; expects a pair. But the library code on the right sends a &lt;code&gt;MouseEvt&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;What happens when we run this program in a type-sound mixed-typed language? Does &lt;code&gt;h&lt;/code&gt; receive the invalid input?&lt;/p&gt;

&lt;p&gt;As it turns out, type soundness cannot say. A type sound language may choose to enforce or ignore the fact that the  API promises a pair of numbers to the client.&lt;/p&gt;

&lt;h3 id="type-soundness-is-not-enough"&gt;Type Soundness is Not Enough&lt;/h3&gt;

&lt;p&gt;Sound types are statements about the behavior of a program. A normal type soundness theorem for a typed language says that a well-typed  program can either compute a value of the same type, compute forever (diverge),  or stop with an acceptable error (perhaps division by zero). No other behaviors are possible.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;strong&gt;Classic Type Soundness&lt;/strong&gt;&lt;/p&gt;
 &lt;p&gt;If &lt;code&gt;e : T&lt;/code&gt; then one of the following holds:&lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;&lt;code&gt;e --&amp;gt;* v&lt;/code&gt; and &lt;code&gt;v : T&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;e&lt;/code&gt; diverges&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;e --&amp;gt;* OkError&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;

&lt;p&gt;A mixed-typed language needs two &amp;ldquo;type soundness&amp;rdquo; theorems:  one for typed code and one for untyped code. The &lt;strong&gt;typed&lt;/strong&gt; soundness theorem can resemble a classic theorem. The &lt;strong&gt;untyped&lt;/strong&gt; soundness theorem is necessarily a weaker statement due to  the lack of types:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;strong&gt;Mixed-Typed Soundness&lt;/strong&gt;&lt;/p&gt;
 &lt;p&gt;If &lt;code&gt;e : T&lt;/code&gt; then one of the following holds:&lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;&lt;code&gt;e --&amp;gt;* v&lt;/code&gt; and &lt;code&gt;v : T&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;e&lt;/code&gt; diverges&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;e --&amp;gt;* OkError&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
 &lt;p&gt;And if &lt;code&gt;e&lt;/code&gt; is untyped then one of the following holds:&lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;&lt;code&gt;e --&amp;gt;* v&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; is an untyped value&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;e&lt;/code&gt; diverges&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;e --&amp;gt;* OkError&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;

&lt;p&gt;Now we can see why mixed-typed soundness is not strong enough to guarantee that  the callback &lt;code&gt;h&lt;/code&gt; in the code above receives a pair value. We have an &lt;strong&gt;untyped&lt;/strong&gt; function called from an &lt;strong&gt;untyped&lt;/strong&gt; context &amp;mdash; since  there are no types sitting right there, type soundness has nothing to say  except that the untyped code can expect an untyped value!&lt;/p&gt;

&lt;p&gt;&lt;img height="200px" src="/img/complete-monitoring-1.png" alt="Untyped library sends input directly to untyped client." /&gt;&lt;/p&gt;

&lt;p&gt;Nevertheless, this channel of communication between the library and client  arose through the typed API. One might expect the type &lt;code&gt;[N, N]&lt;/code&gt; to restrict the values that can flow across  the channel; indeed, if types really are statements about the behavior of a program,  then the channel needs to be protected.&lt;/p&gt;

&lt;p&gt;The question is: what formal property separates languages thet check  all typed/untyped channels of communication (whether direct or derived)? One answer is complete monitoring.&lt;/p&gt;

&lt;h3 id="complete-monitoring"&gt;Complete Monitoring&lt;/h3&gt;

&lt;p&gt;A mixed-typed language satisfies complete monitoring iff evaluation never  lets a value flow un-checked across a type boundary. To make this idea precise, we need to enrich the syntax of the language  with a specification of &lt;em&gt;ownership&lt;/em&gt; to say what parts of the program are  responsible for different values, and to say how evalution changes  responsibilities. Relative to a specification, complete monitoring states that every expression  that arises during evaluation is made up of parts that each have a single  owner.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;Complete Monitoring&lt;/em&gt;&lt;/p&gt;
 &lt;p&gt;For all well-formed &lt;code&gt;e&lt;/code&gt; and all &lt;code&gt;e'&lt;/code&gt;, if &lt;code&gt;e --&amp;gt;* e'&lt;/code&gt; then every subexpression of &lt;code&gt;e'&lt;/code&gt; has a unique owner.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This property separates our two behaviors for the Clickable Plot code. A language that satisfies complete monitoring enforces the API types with  a runtime check. A language that merely satisfies type soundness may skip these checks.&lt;/p&gt;

&lt;h3 id="an-aid-to-debugging"&gt;An Aid to Debugging&lt;/h3&gt;

&lt;p&gt;The question raised by the Clickable Plot example is whether a language can  &lt;strong&gt;detect&lt;/strong&gt; one mismatch between a type and a value. A language that satisfies complete monitoring detects all such mis-matches. But we can say more. If a mismatch occurs, then programmer knows exactly where to start debugging  &amp;mdash; either the type is an incorrect specification, or the given value is  flawed. In other words, complete monitoring implies a concise 2-party explanation  for every type mismatch.&lt;/p&gt;

&lt;p&gt;The paper generalizes this goal of explaining a mismatch for languages  that fail to satisfy complete monitoring. There may be 2N parties to blame thanks to un-checked channels of communication,  and we want to be certain to report all these parties and no false positives.&lt;/p&gt;

&lt;p&gt;Also in the paper, you can find:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;a model of ownership, clear &lt;em&gt;laws&lt;/em&gt; for how ownership changes during evaluation;&lt;/li&gt;
 &lt;li&gt;examples of how to systematically add ownership to an operational semantics  to attempt a proof of complete monitoring;&lt;/li&gt;
 &lt;li&gt;definitions for &lt;strong&gt;blame soundness&lt;/strong&gt; and &lt;strong&gt;blame completeness&lt;/strong&gt;;&lt;/li&gt;
 &lt;li&gt;an analysis of three semantics, which correspond to &lt;a href="https://docs.racket-lang.org/ts-reference/index.html"&gt;Typed Racket&lt;/a&gt;,  &lt;a href="http://hdl.handle.net/2022/23172"&gt;Transient Reticulated&lt;/a&gt;, and a compromise;&lt;/li&gt;
 &lt;li&gt;and discussion of an alternative, heap-based model of ownership.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Paper: &lt;a href="https://www2.ccs.neu.edu/racket/pubs/oopsla19-gfd.pdf"&gt;https://www2.ccs.neu.edu/racket/pubs/oopsla19-gfd.pdf&lt;/a&gt;&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Four Kinds of Scoping in R</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2019/09/10/four-kinds-of-scoping-in-r/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2019-09-10-four-kinds-of-scoping-in-r</id>
  <published>2019-09-10T11:00:00Z</published>
  <updated>2019-09-10T11:00:00Z</updated>
  <author>
   <name>Ming-Ho Yee</name></author>
  <content type="html">
&lt;p&gt;In the &lt;a href="/blog/2019/09/05/lexical-and-dynamic-scope/"&gt;first&lt;/a&gt; and &lt;a href="/blog/2019/09/10/scoping-in-r/"&gt;second&lt;/a&gt; parts of this blog series, I defined lexical and dynamic scope, and demonstrated interesting cases of scoping in R.&lt;/p&gt;

&lt;p&gt;In this third and final part of my blog series, I&amp;rsquo;d like to discuss a paper by the creators of R, where they motivate the need for lexical scoping in a statistical programming language.&lt;/p&gt;

&lt;p&gt;This is a &amp;ldquo;bonus&amp;rdquo; blog post, because I&amp;rsquo;m going to dive into some of the hairier R features to show how four different kinds of scoping can be simulated in R.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h2 id="lexical-scope-and-statistical-computation"&gt;Lexical scope and statistical computation&lt;/h2&gt;

&lt;p&gt;In &lt;em&gt;Lexical Scope and Statistical Computation&lt;/em&gt;,&lt;sup&gt;&lt;a href="#2019-09-10-four-kinds-of-scoping-in-r-footnote-1-definition" name="2019-09-10-four-kinds-of-scoping-in-r-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt; Robert Gentleman and Ross Ihaka, the creators of R, discuss why they designed R with lexical scoping. The paper is written for a statistics audience, and they provide motivating examples for having lexical scoping in R.&lt;/p&gt;

&lt;p&gt;For the purpose of their discussion, they define four (slightly different) kinds of scoping rules:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;em&gt;trivial&lt;/em&gt;: no free variables allowed&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;static&lt;/em&gt;: a free variable takes its value from a set of global variables&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;lexical&lt;/em&gt;: a free variable takes the value of the binding that was in  effect when the function was defined&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;dynamic&lt;/em&gt;: a free variable takes the value of the most recent assignment to  that variable&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Note that under this set of definitions, &lt;em&gt;static scoping&lt;/em&gt; is a separate scoping rule and not another name for &lt;em&gt;lexical scoping&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;It is possible to simulate each of strategies in R. For fun, we can even construct &amp;ldquo;factories&amp;rdquo; that take a function, and then modify it to use the desired scoping rule! (Jan Ječmen originally provided these examples to me, and I adapted them for this blog post after some feedback from Artem Pelenitsyn.)&lt;/p&gt;

&lt;h3 id="template"&gt;Template&lt;/h3&gt;

&lt;p&gt;Our examples will follow the template given below:&lt;/p&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;factory&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="o"&gt;&amp;lt;???&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
  &lt;span class="nf"&gt;factory&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;h&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# error, 0, 1, or 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;We want to define a &lt;code&gt;factory&lt;/code&gt; that takes a function literal and returns a closure that implements the desired scoping rule.&lt;/p&gt;

&lt;p&gt;Our example consists of three definitions of &lt;code&gt;x&lt;/code&gt;. On line 5, we assign &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; at the top level. On line 7, we assign &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; inside function &lt;code&gt;h&lt;/code&gt;, where we also create the closure. On line 12, we assign &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; inside the function &lt;code&gt;f&lt;/code&gt; and right before we call &lt;code&gt;g&lt;/code&gt;, which is the closure.&lt;/p&gt;

&lt;p&gt;Finally, we call &lt;code&gt;f&lt;/code&gt; and observe the result:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Under trivial scoping, no free variables are allowed, so &lt;code&gt;f()&lt;/code&gt; should result  in an error.&lt;/li&gt;
 &lt;li&gt;Under static scoping, free variables may only refer to global variables, so  &lt;code&gt;f()&lt;/code&gt; should return &lt;code&gt;0&lt;/code&gt;.&lt;/li&gt;
 &lt;li&gt;Under lexical scoping, free variables refer to the variables in scope when  the function was defined, so &lt;code&gt;f()&lt;/code&gt; should return &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt;
 &lt;li&gt;Under dynamic scoping, free variables take the value from the most recent  assignment, so &lt;code&gt;f()&lt;/code&gt; should return &lt;code&gt;2&lt;/code&gt;.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;We will implement the body of &lt;code&gt;factory&lt;/code&gt; in only 3&amp;ndash;5 lines of code. The rest of the code snippet, from lines 7 to the end, will remain the same, other than the call to &lt;code&gt;factory&lt;/code&gt; on line 10.&lt;/p&gt;

&lt;h3 id="trivial-scoping"&gt;Trivial scoping&lt;/h3&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;makeTrivial&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substitute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="nf"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;baseenv&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;res&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
  &lt;span class="nf"&gt;makeTrivial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;h&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# Error in f(0) : object &amp;#39;x&amp;#39; not found&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code&gt;substitute&lt;/code&gt; returns the unevaluated parse tree for &lt;code&gt;fun&lt;/code&gt;. In other words, it obtains the literal argument that was passed for &lt;code&gt;fun&lt;/code&gt;. This works because of call-by-need semantics in R: function arguments are packaged up into &lt;em&gt;promises&lt;/em&gt;. As a result, the syntax tree of arguments is available for metaprogramming. A recent paper by Goel and Vitek&lt;sup&gt;&lt;a href="#2019-09-10-four-kinds-of-scoping-in-r-footnote-2-definition" name="2019-09-10-four-kinds-of-scoping-in-r-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt; discusses laziness in R in more detail.&lt;/p&gt;

&lt;p&gt;In this example, on line 8, we call &lt;code&gt;factory&lt;/code&gt; with &lt;code&gt;function(a) x+a&lt;/code&gt; as the argument for the formal parameter &lt;code&gt;fun&lt;/code&gt;. Then, we evaluate that parse tree with &lt;code&gt;eval&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;At this point, &lt;code&gt;res&lt;/code&gt; is the closure with expression &lt;code&gt;function(a) x+a&lt;/code&gt; and a reference to the environment of &lt;code&gt;makeTrivial&lt;/code&gt;. On line 3, we change that reference to &lt;code&gt;baseenv()&lt;/code&gt;, which is the environment containing library definitions. Since this environment is above the (user) top-level environment, global variables are not available.&lt;/p&gt;

&lt;p&gt;Therefore, variable lookup in the function literal will only search the base environment, so &lt;code&gt;f()&lt;/code&gt; results in an error.&lt;/p&gt;

&lt;h3 id="static-scoping"&gt;Static scoping&lt;/h3&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;makeStatic&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substitute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="nf"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;globalenv&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;res&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
  &lt;span class="nf"&gt;makeStatic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;h&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;For this example, on line 3, we update the environment of &lt;code&gt;res&lt;/code&gt; to refer to &lt;code&gt;globalenv()&lt;/code&gt;, which is the top-level environment where globals are defined.&lt;/p&gt;

&lt;p&gt;Therefore, variable lookup searches the top-level environment, so &lt;code&gt;f()&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id="lexical-scoping"&gt;Lexical scoping&lt;/h3&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;makeLexical&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substitute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="nf"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;parent.frame&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;res&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
  &lt;span class="nf"&gt;makeLexical&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;h&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Although lexical scoping is the default for R, our factory template requires some metaprogramming to work properly. We need to set the environment of &lt;code&gt;res&lt;/code&gt; to &lt;code&gt;parent.frame()&lt;/code&gt;, which is the environment of the function (&lt;code&gt;h&lt;/code&gt;) that called the current function (&lt;code&gt;makeLexical&lt;/code&gt;). This allows us to simulate lexical scoping, as if the function literal was evaluated inside &lt;code&gt;h&lt;/code&gt;, rather than &lt;code&gt;makeLexical&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Therefore, variable lookup searches the environment of &lt;code&gt;h&lt;/code&gt;, so &lt;code&gt;f()&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id="dynamic-scoping"&gt;Dynamic scoping&lt;/h3&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;makeDynamic&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substitute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="nf"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;parent.frame&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="nf"&gt;res&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
  &lt;span class="nf"&gt;makeDynamic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;h&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;For this example, we need another level of indirection. &lt;code&gt;makeDynamic&lt;/code&gt; returns an anonymous function literal. The anonymous function takes &lt;code&gt;...&lt;/code&gt;, which represents an arbitrary list of arguments, and then on line 5 we call &lt;code&gt;res&lt;/code&gt; with those exact arguments. Note that we set the environment of &lt;code&gt;res&lt;/code&gt; to be the environment of the &lt;em&gt;caller&lt;/em&gt; of the anonymous function. Because of the multiple levels of indirection, the caller is &lt;code&gt;f&lt;/code&gt;, on line 17.&lt;/p&gt;

&lt;p&gt;On line 12, &lt;code&gt;makeDynamic&lt;/code&gt; returns a closure for the anonymous function. &lt;code&gt;h&lt;/code&gt; returns that closure when it is called, and assigns it to &lt;code&gt;g&lt;/code&gt;. When &lt;code&gt;g&lt;/code&gt; is called on line 17, the function literal &lt;code&gt;function(a) x+a&lt;/code&gt; is finally evaluated, and its environment is set to the environment of &lt;code&gt;f&lt;/code&gt;, the caller of &lt;code&gt;g&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Therefore, variable lookup searches the environment of &lt;code&gt;f&lt;/code&gt;, so &lt;code&gt;f()&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Hopefully this blog post has shown another way of looking at scoping definitions. As discussed in the &lt;a href="/blog/2019/09/10/scoping-in-r/"&gt;previous post&lt;/a&gt;, it&amp;rsquo;s very easy to get confused because different definitions are used by different people. Here, Gentleman and Ihaka very clearly state what definitions they are using.&lt;/p&gt;

&lt;p&gt;And finally, while I am far from an expert on metaprogramming in R, I hope this post has given a taste of what is possible.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;I would like to thank Jan Ječmen for coming up with and showing me the original versions of these code examples, and Artem Pelenitsyn for his feedback to improve and not discard these examples from an earlier blog draft.&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id="references"&gt;References&lt;/h2&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2019-09-10-four-kinds-of-scoping-in-r-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;R. Gentleman and R. Ihaka. "Lexical Scope and Statistical Computing, &lt;em&gt;Journal of Computational and Graphical Statistics&lt;/em&gt;, vol. 9, no. 3, 2000. [&lt;a href="https://doi.org/10.1080/10618600.2000.10474895"&gt;DOI&lt;/a&gt;][&lt;a href="https://www.stat.auckland.ac.nz/~ihaka/downloads/lexical.pdf"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-10-four-kinds-of-scoping-in-r-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-10-four-kinds-of-scoping-in-r-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;A. Goel and J. Vitek. &amp;ldquo;On the Design, Implementation and Use of Laziness in R,&amp;rdquo; in &lt;em&gt;Proceedings of the ACM in Programming Languages (PACMPL)&lt;/em&gt;, vol. 3, no. OOPSLA, 2019. To appear. [&lt;a href="http://janvitek.org/pubs/oopsla19a.pdf"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-10-four-kinds-of-scoping-in-r-footnote-2-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content></entry>
 <entry>
  <title type="text">Scoping in R</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2019/09/10/scoping-in-r/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2019-09-10-scoping-in-r</id>
  <published>2019-09-10T10:00:00Z</published>
  <updated>2019-09-10T10:00:00Z</updated>
  <author>
   <name>Ming-Ho Yee</name></author>
  <content type="html">
&lt;p&gt;In the &lt;a href="/blog/2019/09/05/lexical-and-dynamic-scope/"&gt;previous post&lt;/a&gt; of this three-part blog series, we discussed lexical and dynamic scope. Now, in this second part, we can return to the original question: &lt;em&gt;is R lexically or dynamically scoped?&lt;/em&gt;&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;Recall the example program from before:&lt;/p&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# what does this return?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Let&amp;rsquo;s examine what happens when we run this example. First, we create a mapping for &lt;code&gt;x&lt;/code&gt; in the top-level environment. On line 2, we define a function &lt;code&gt;f&lt;/code&gt;, which returns the value of some &lt;code&gt;x&lt;/code&gt;. On line 3, we define a function &lt;code&gt;g&lt;/code&gt;, which creates a new mapping for &lt;code&gt;x&lt;/code&gt;, and then calls &lt;code&gt;f&lt;/code&gt;. Note that the assignment on line 4 does &lt;em&gt;not&lt;/em&gt; update the definition on line 1.&lt;/p&gt;

&lt;p&gt;When &lt;code&gt;f&lt;/code&gt; is called, it needs to look up the value of &lt;code&gt;x&lt;/code&gt;. In other words, does the reference of &lt;code&gt;x&lt;/code&gt; on line 2 refer to the assignment on line 1 or the assignment on line 4? If &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;, then the behaviour matches lexical scoping. If it returns &lt;code&gt;2&lt;/code&gt;, then the behaviour matches dynamic scoping.&lt;/p&gt;

&lt;p&gt;When we run this example, the result is &lt;code&gt;1&lt;/code&gt;. This implies that R is lexically scoped.&lt;/p&gt;

&lt;p&gt;But there&amp;rsquo;s more to this story. In the rest of this blog post, I&amp;rsquo;ll examine some interesting scoping examples in R, and discuss how the scoping definitions relate to R.&lt;/p&gt;

&lt;p&gt;The &lt;a href="/blog/2019/09/10/four-kinds-of-scoping-in-r/"&gt;next and final part&lt;/a&gt; of this blog series, published simultaneously with this one, is an appendix where I implement four different scoping disciplines in R.&lt;/p&gt;

&lt;h2 id="r-is-lexically-scoped-but"&gt;R is lexically scoped, but&amp;hellip;&lt;/h2&gt;

&lt;p&gt;In &lt;em&gt;Evaluating the Design of the R Language&lt;/em&gt;,&lt;sup&gt;&lt;a href="#2019-09-10-scoping-in-r-footnote-1-definition" name="2019-09-10-scoping-in-r-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt; Morandat, Hill, Osvald, and Vitek write:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;As is often the case, R is lexically scoped up to the point it is not. R is above all a dynamic language with full reflective access to the running program’s data and representation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In other words, R provides many different &amp;ldquo;escape hatches&amp;rdquo;&amp;mdash;ways to bypass lexical scoping. Additionally, even without escape hatches, some of R&amp;rsquo;s functionality can be surprising.&lt;/p&gt;

&lt;h3 id="functions-environments-and-variables-in-r"&gt;Functions, environments, and variables in R&lt;/h3&gt;

&lt;p&gt;Before we look at some examples, I think it&amp;rsquo;s useful to briefly discuss some of the core concepts in R that relate to scoping.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Functions.&lt;/strong&gt; R has first-class functions, and functions evaluate to  closures. In other words, a function value includes both the body of the  function as well as the environment that the function was evaluated in. In  R, the programmer can modify the environment of a closure. Note that R is  function scoped; there is no block scoping.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Environments.&lt;/strong&gt; An environment in R is a mapping from variables to  values. Each function has its own local environment. Furthermore, each  environment has a reference to the &amp;ldquo;enclosing&amp;rdquo; environment that it was  evaluated in. R environments are first-class, meaning the programmer can  add, modify, or removing variable mappings, and also change the reference to  the enclosing environment.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Variable lookup.&lt;/strong&gt; When R looks up a variable, it will search in the  current environment for a mapping. If no mapping is found, then it will  search in the enclosing environment. This process continues until a mapping  is found, or the topmost, empty environment is reached, in which case an  error is raised.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Variable assignment.&lt;/strong&gt; &lt;code&gt;&amp;lt;-&lt;/code&gt; is the variable assignment operator in R. The  expression &lt;code&gt;x &amp;lt;- 1&lt;/code&gt; assigns the value &lt;code&gt;1&lt;/code&gt; to the variable &lt;code&gt;x&lt;/code&gt; in the  current environment. If a mapping for &lt;code&gt;x&lt;/code&gt; already exists in the  environment, then the assignment will update and overwrite the existing  value. Otherwise, a new mapping is created in the environment. Note that  variable assignment can only update the current environment, and never  creates a scope.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;From this description, we can see that R implements lexical scoping (or at least, something that behaves a lot like lexical scoping): each function value is associated with the environment it was evaluated in, and variable lookup proceeds along the chain of enclosing environments. In fact, the creators of R have confirmed that lexical scoping was their intent.&lt;sup&gt;&lt;a href="#2019-09-10-scoping-in-r-footnote-2-definition" name="2019-09-10-scoping-in-r-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;On the other hand, variable lookup depends on the run-time state of the program&amp;mdash;names cannot be resolved statically. Furthermore, since R provides operations for environment manipulation, a programmer can easily circumvent lexical scoping.&lt;/p&gt;

&lt;p&gt;The following examples will make this clear.&lt;/p&gt;

&lt;h3 id="examples"&gt;Examples&lt;/h3&gt;

&lt;h4 id="adding-variable-mappings-at-run-time"&gt;Adding variable mappings at run time&lt;/h4&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;When &lt;code&gt;f&lt;/code&gt; is called, it creates a function &lt;code&gt;g&lt;/code&gt; that returns &lt;code&gt;x&lt;/code&gt;, assigns &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;, and then calls &lt;code&gt;g&lt;/code&gt;. When &lt;code&gt;g&lt;/code&gt; is called, it looks up &lt;code&gt;x&lt;/code&gt;. Since no mapping is found in &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s environment, it searches in the enclosing environment (&lt;code&gt;f&lt;/code&gt;&amp;rsquo;s), and finds that &lt;code&gt;x&lt;/code&gt; has value &lt;code&gt;2&lt;/code&gt;. Therefore, &lt;code&gt;g&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note that the &lt;code&gt;x&lt;/code&gt; on line 3 is resolved only when function &lt;code&gt;g&lt;/code&gt; is called, not when it is defined. However, when &lt;code&gt;g&lt;/code&gt; is defined, its environment has a reference to &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s environment. Therefore, as long as &lt;code&gt;x&lt;/code&gt; is defined &lt;em&gt;before&lt;/em&gt; &lt;code&gt;g&lt;/code&gt; is called, the lookup will always succeed.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a second example:&lt;/p&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nf"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# 2&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code&gt;f&lt;/code&gt; is a function that branches on its argument, &lt;code&gt;b&lt;/code&gt;. If &lt;code&gt;b&lt;/code&gt; evaluates to true, then the expression &lt;code&gt;x &amp;lt;- 2&lt;/code&gt; is evaluated, and a mapping for &lt;code&gt;x&lt;/code&gt; is created in &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s environment. Otherwise, no mapping is created.&lt;/p&gt;

&lt;p&gt;When we look up the value of &lt;code&gt;x&lt;/code&gt; on line 5, R will first search the function&amp;rsquo;s environment. If &lt;code&gt;b&lt;/code&gt; evaluated to true, then R will find a value for &lt;code&gt;x&lt;/code&gt;, which is &lt;code&gt;2&lt;/code&gt;. Otherwise, R will search in the enclosing environment of &lt;code&gt;f&lt;/code&gt;, and find that &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Both of these examples vaguely resemble dynamic scoping, in that &lt;code&gt;x&lt;/code&gt; takes the value of the most recent assignment. However, this is not how R is implemented, and it is not consistent with how R behaves in other examples.&lt;/p&gt;

&lt;h4 id="function-lookup"&gt;Function lookup&lt;/h4&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# not an error&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;42&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;R has slightly different lookup rules, if the variable is in function call position. Specifically, R will search the environment chain and skip non-function values.&lt;/p&gt;

&lt;p&gt;In this example, we call &lt;code&gt;g&lt;/code&gt; with the argument &lt;code&gt;42&lt;/code&gt;, which is not a function. Then, in the body of &lt;code&gt;g&lt;/code&gt;, we call &lt;code&gt;f(0)&lt;/code&gt; on line 3, which requires looking up &lt;code&gt;f&lt;/code&gt;. Although there is an &lt;code&gt;f&lt;/code&gt; in the environment of &lt;code&gt;g&lt;/code&gt;, its value is &lt;code&gt;42&lt;/code&gt;, which is not a function. R will then search the enclosing environment, where it finds the function defined on line 1. Therefore, the lookup on line 3 resolves to the function on line 1, so &lt;code&gt;f(0)&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This behaviour exists because &lt;code&gt;c&lt;/code&gt; is the built-in function that constructs vectors (in other words, one of the most commonly used functions in R), but it is also a commonly used argument name.&lt;/p&gt;

&lt;h4 id="super-assignment"&gt;Super assignment&lt;/h4&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 1&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt;   &lt;span class="c1"&gt;# 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; is the &amp;ldquo;super assignment&amp;rdquo; operator. It skips the current environment and then searches the chain of enclosing environments until it finds a variable to update. If no variable is found, then a new mapping is created at the top environment.&lt;/p&gt;

&lt;p&gt;In the above program, we define &lt;code&gt;x&lt;/code&gt; to be &lt;code&gt;0&lt;/code&gt; at the top level, and then define the function &lt;code&gt;f&lt;/code&gt;. When we call &lt;code&gt;f&lt;/code&gt; on line 7, it assigns &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; on line 3, which creates a mapping in the local environment. On line 4, the super assignment skips the mapping in the local environment and instead updates the mapping created on line 1. Next, &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;x&lt;/code&gt;, which is looked up from the local environment and has value &lt;code&gt;1&lt;/code&gt;. Finally, line 8 looks up &lt;code&gt;x&lt;/code&gt; from the top level environment, which has value &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id="evaluating-arbitrary-code"&gt;Evaluating arbitrary code&lt;/h4&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nf"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x &amp;lt;- 0"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;R has a mechanism for converting an arbitrary string to code and then executing it. On line 3, we parse and evaluate the argument &lt;code&gt;t&lt;/code&gt;, which happens to be the string &lt;code&gt;"x &amp;lt;- 0"&lt;/code&gt;. Then, when line 4 executes, the lookup of &lt;code&gt;x&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id="simulating-dynamic-scope"&gt;Simulating dynamic scope&lt;/h4&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;
&lt;span class="normal"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;envir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;parent.frame&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;On line 3, we perform an explicit variable lookup for &lt;code&gt;x&lt;/code&gt;, but we do so in the environment &lt;code&gt;parent.frame()&lt;/code&gt;, which refers to the calling function&amp;rsquo;s environment, in this case, &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s environment.. Therefore, the lookup returns &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note that R has a similarly named function, &lt;code&gt;parent.env(e)&lt;/code&gt; which returns the &lt;em&gt;enclosing environment&lt;/em&gt; of the given environment &lt;code&gt;e&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id="constructing-an-arbitrary-environment"&gt;Constructing an arbitrary environment&lt;/h4&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;new.env&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;
  &lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;envir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;When &lt;code&gt;f&lt;/code&gt; is called, it constructs a new environment, &lt;code&gt;e&lt;/code&gt;, which is initially empty. (By default, its enclosing environment is the current environment, which is &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s.) Next, on line 4, it directly adds a mapping to that environment, assigning &lt;code&gt;3&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. Then, on line 5, the lookup is explicitly done in environment &lt;code&gt;e&lt;/code&gt;, so &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id="deleting-mappings"&gt;Deleting mappings&lt;/h4&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nf"&gt;rm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;envir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;parent.env&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# Error in f() : object &amp;#39;x&amp;#39; not found&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Not only is it possible to dynamically add and modify mappings in R, but it is also possible to &lt;em&gt;delete&lt;/em&gt; mappings. This is what line 3 does: it explicitly removes the mapping for &lt;code&gt;x&lt;/code&gt; from the enclosing environment of the current environment. In other words, the definition on line 1 is deleted. Therefore, when &lt;code&gt;f&lt;/code&gt; is called, the lookup of &lt;code&gt;x&lt;/code&gt; fails and an error is raised.&lt;/p&gt;

&lt;h4 id="infinite-loop-during-variable-lookup"&gt;Infinite loop during variable lookup&lt;/h4&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;enva&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;new.env&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;envb&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;new.env&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;parent.env&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;enva&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;envb&lt;/span&gt;
&lt;span class="nf"&gt;parent.env&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;envb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;enva&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="nf"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;enva&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;In this final example, manipulation of environments allows us to create a function where variable lookup results in an infinite loop.&lt;/p&gt;

&lt;p&gt;On lines 1 and 2, we create new, empty environments. Both have the same enclosing environment, which is the top-level environment. However, on lines 3 and 4, we modify their enclosing environments to create a cycle: &lt;code&gt;enva&lt;/code&gt;&amp;rsquo;s enclosing environment is &lt;code&gt;envb&lt;/code&gt;, and &lt;code&gt;envb&lt;/code&gt;&amp;rsquo;s enclosing environment is &lt;code&gt;enva&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On line 5, we define a function with a free variable, &lt;code&gt;x&lt;/code&gt;, but on line 6, we set &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s environment to be &lt;code&gt;enva&lt;/code&gt;. Finally, we call &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When the body of &lt;code&gt;f&lt;/code&gt; is evaluated, it needs to look up &lt;code&gt;x&lt;/code&gt;. Lookup starts in &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s environment, which we set to be &lt;code&gt;enva&lt;/code&gt;. Since no mapping for &lt;code&gt;x&lt;/code&gt; is found, lookup continues in &lt;code&gt;enva&lt;/code&gt;&amp;rsquo;s enclosing environment, which is &lt;code&gt;envb&lt;/code&gt;. However, &lt;code&gt;envb&lt;/code&gt; is also empty, so lookup continues in its enclosing environment, which is &lt;code&gt;enva&lt;/code&gt;, and now lookup results in an infinite loop.&lt;/p&gt;

&lt;h3 id="an-intuition-for-scoping-in-r"&gt;An intuition for scoping in R&lt;/h3&gt;

&lt;p&gt;Some of the above examples appear to demonstrate dynamic scoping. Recall two of our examples:&lt;/p&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# example 1&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 2&lt;/span&gt;

&lt;span class="c1"&gt;# example 2&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nf"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# 2&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;It seems that &lt;code&gt;x&lt;/code&gt; takes on the value of the last assignment, but we know this is not the case, from the first example. This is also not how R is implemented. What&amp;rsquo;s missing from our intuition?&lt;/p&gt;

&lt;p&gt;The key insight is that R is &lt;em&gt;function scoped&lt;/em&gt;. In R, each function has an associated environment, and that environment implements a scope. In general, only a function definition can create a scope. Therefore, the assignment operator &lt;code&gt;&amp;lt;-&lt;/code&gt; &lt;em&gt;does not create a new scope&lt;/em&gt;, and it is more useful to think of it as a mutation &lt;em&gt;on the current environment&lt;/em&gt;. (In contrast, in most languages, a variable binding or definition creates a new scope, and an assignment mutates that variable.)&lt;/p&gt;

&lt;p&gt;In a sense, it might be more accurate to say that R &lt;em&gt;environments&lt;/em&gt; are lexically scoped, variables are scoped to functions (but a reference can occur syntactically before a definition), and variable assignment is an update to the environment.&lt;/p&gt;

&lt;h2 id="discussion"&gt;Discussion&lt;/h2&gt;

&lt;p&gt;All of this might make you a little uncomfortable, and uncertain about R&amp;rsquo;s scoping rules.&lt;/p&gt;

&lt;p&gt;On one hand, R passes the first example program as a lexically scoped language, the implementation of closures and variable lookup imply &amp;ldquo;lexical-like&amp;rdquo; behaviour, and the creators have confirmed that lexical scoping was the intent.&lt;/p&gt;

&lt;p&gt;On the other hand, variable lookup depends on the run-time state of the program, and variable bindings cannot be resolved statically. Some of the examples even resemble dynamic scoping, where a free variable takes the value of the most recent assignment&amp;mdash;but this is not consistent with R&amp;rsquo;s behaviour in other examples. Furthermore, the dynamic nature of R and its reflection and metaprogramming capabilities allow programmers to completely circumvent lexical scoping.&lt;/p&gt;

&lt;p&gt;This ambiguity shows up in a paper,&lt;sup&gt;&lt;a href="#2019-09-10-scoping-in-r-footnote-3-definition" name="2019-09-10-scoping-in-r-footnote-3-return"&gt;3&lt;/a&gt;&lt;/sup&gt; where the authors write:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Furthermore, because variable scoping in R is dynamic and can be modified at the language level [&amp;hellip;] it cannot be trivially guaranteed that &lt;code&gt;x&lt;/code&gt; is going to point to the same data structure throughout the entire execution of the loop.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It is true that a variable &lt;code&gt;x&lt;/code&gt; may not point to the same data structure during the execution of a loop. It is true that scoping in R can be modified at the language level.&lt;/p&gt;

&lt;p&gt;It is true that variable &lt;em&gt;lookup&lt;/em&gt; is dynamic, as it is performed at run time and depends on the run-time program state. If that is your definition of &lt;em&gt;dynamic scope&lt;/em&gt;, then it would be fair to say that R is dynamically scoped.&lt;/p&gt;

&lt;p&gt;But if your definition of &lt;em&gt;dynamic scope&lt;/em&gt; is &amp;ldquo;a variable is bound to the most recent assignment during the program&amp;rsquo;s execution,&amp;rdquo; then it is not correct to say R is dynamically scoped.&lt;/p&gt;

&lt;p&gt;I think we have this ambiguity because &lt;em&gt;scope&lt;/em&gt; (the places in a program where a variable can be referenced) and &lt;em&gt;variable lookup&lt;/em&gt; or &lt;em&gt;name resolution&lt;/em&gt; (determining which binding or definition a name refers to) are often considered together. For most lexically scoped languages, name resolution can be done at compile time. For most dynamically scoped languages, name resolution must be done at run time. R is lexically scoped, but must perform name resolution at run time.&lt;/p&gt;

&lt;p&gt;Personally, I prefer the definition of &lt;em&gt;scope&lt;/em&gt; that treats name resolution as an orthogonal issue. I think it is more useful to keep the two issues separate. In addition, I think it is confusing and unhelpful to say that R is &lt;em&gt;both&lt;/em&gt; lexically and dynamically scoped, or that R is &lt;em&gt;neither&lt;/em&gt; lexically and dynamically scoped.&lt;/p&gt;

&lt;p&gt;I think it is more helpful to treat R as a lexically scoped language (with certain exceptions and surprises) than as a dynamically scoped language&amp;mdash;when I read and write R code, I find it more convenient to think about nested function definitions and free variables in terms of lexical scoping rules. And I think that it is more accurate, based on the design and implementation, to classify R as a lexically scoped language.&lt;/p&gt;

&lt;p&gt;Regardless, it is very easy to miscommunicate, so I think it&amp;rsquo;s important to be very clear and make sure you and your audience know what definitions of scoping you&amp;rsquo;re using!&lt;/p&gt;

&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This entire adventure started when we were working on a paper,&lt;sup&gt;&lt;a href="#2019-09-10-scoping-in-r-footnote-4-definition" name="2019-09-10-scoping-in-r-footnote-4-return"&gt;4&lt;/a&gt;&lt;/sup&gt; and asked each other, is R lexically or dynamically scoped? Eventually, it became apparent that we had different definitions of lexical and dynamic scope, so of course we were unable to agree on an answer!&lt;/p&gt;

&lt;p&gt;This got me interested in exploring definitions of scope, the history of lexical scope, and how R fits with traditional definitions of lexical scope. The result was this mini blog series.&lt;/p&gt;

&lt;p&gt;To summarize, I would say that &lt;em&gt;scope&lt;/em&gt; refers to the places in a program where a variable is visible and can be referenced. Under &lt;em&gt;lexical scoping&lt;/em&gt;, the scope of a variable is determined by the lexical (&lt;em&gt;i.e.&lt;/em&gt;, textual) structure of a program. Under &lt;em&gt;dynamic scoping&lt;/em&gt;, a variable is bound to the most recent value assigned to that variable, &lt;em&gt;i.e.&lt;/em&gt;, the most recent assignment during the program&amp;rsquo;s execution.&lt;/p&gt;

&lt;p&gt;I would say that R &lt;em&gt;aims&lt;/em&gt; to be lexically scoped&amp;mdash;it was part of the design and implementation, but certain features make the situation more complicated. In particular, variables are function scoped, definitions do not introduce new scopes, and variable lookup is performed at run time. Furthermore, the dynamic nature of R and its metaprogramming capabilities allow programmers to completely circumvent lexical scoping.&lt;/p&gt;

&lt;p&gt;Finally, there are some definitions of lexical and dynamic scope that also consider variable lookup. Under these definitions, R might be considered a dynamically scoped language, since variable lookup happens at run time. Therefore, it is important to be precise about your definitions!&lt;/p&gt;

&lt;p&gt;If you want more content about R and scoping, the &lt;a href="/blog/2019/09/10/four-kinds-of-scoping-in-r/"&gt;third and final part&lt;/a&gt; of this blog series is already published. In it, I walk through four different examples of using metaprogramming to simulate different scoping disciplines in R.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Edited 2020/02/21:&lt;/strong&gt; For another discussion on R environments and lookups, (and also packages and namespaces, which I did not cover in my post), &lt;a href="http://blog.obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/"&gt;this blog post&lt;/a&gt; has some nice examples and diagrams.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;I would like to thank Sam Caldwell, Guido Chari, Oli Flückiger, Aviral Goel, Ben Greenman, Jakob Hain, Jan Ječmen, Hugo Musso Gualandi, Artem Pelenitsyn, and Jan Vitek for their comments, feedback, and discussions that have greatly improved and shaped this blog post.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;If you liked this post, you may also be interested in the following Twitter threads about R: &lt;a href="https://twitter.com/mhyee/status/1063983175163158531"&gt;one&lt;/a&gt;, &lt;a href="https://twitter.com/mhyee/status/1067818720532316166"&gt;two&lt;/a&gt; and &lt;a href="https://twitter.com/mhyee/status/1074744049951739905"&gt;three&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id="references"&gt;References&lt;/h2&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2019-09-10-scoping-in-r-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;F. Morandat, B. Hill, L. Osvald, J. Vitek. &amp;ldquo;Evaluating the Design of the R Language,&amp;rdquo; in &lt;em&gt;Proceedings of the European Conference on Object-Oriented Programming (ECOOP)&lt;/em&gt;, 2012. [&lt;a href="https://doi.org/10.1007/978-3-642-31057-7_6"&gt;DOI&lt;/a&gt;][&lt;a href="http://janvitek.org/pubs/ecoop12.pdf"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-10-scoping-in-r-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-10-scoping-in-r-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;R. Gentleman and R. Ihaka. &amp;ldquo;Lexical Scope and Statistical Computing&amp;rdquo;, &lt;em&gt;Journal of Computational and Graphical Statistics&lt;/em&gt;, vol. 9, no. 3, 2000. [&lt;a href="https://doi.org/10.1080/10618600.2000.10474895"&gt;DOI&lt;/a&gt;][&lt;a href="https://www.stat.auckland.ac.nz/~ihaka/downloads/lexical.pdf"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-10-scoping-in-r-footnote-2-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-10-scoping-in-r-footnote-3-definition" class="footnote-definition"&gt;
   &lt;p&gt;L. Stadler, A. Welc, C. Humer, and M. Jordan. &amp;ldquo;Optimizing R Language Execution via Aggressive Speculation,&amp;rdquo; in &lt;em&gt;Proceedings of the Symposium on Dynamic Languages (DLS)&lt;/em&gt;, 2016. [&lt;a href="https://doi.org/10.1145/2989225.2989236"&gt;DOI&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-10-scoping-in-r-footnote-3-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-10-scoping-in-r-footnote-4-definition" class="footnote-definition"&gt;
   &lt;p&gt;O. Flückiger, G. Chari, J. Ječmen, M.-H. Yee, J. Hain, and J. Vitek. &amp;ldquo;R Melts Brains: An IR for First-Class Environments and Lazy Effectful Arguments,&amp;rdquo; in &lt;em&gt;Proceedings of the Symposium on Dynamic Languages (DLS)&lt;/em&gt;, 2019. To appear. [&lt;a href="http://janvitek.org/pubs/dls19.pdf"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-10-scoping-in-r-footnote-4-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content></entry>
 <entry>
  <title type="text">Lexical and Dynamic Scope</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2019/09/05/lexical-and-dynamic-scope/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2019-09-05-lexical-and-dynamic-scope</id>
  <published>2019-09-05T10:00:00Z</published>
  <updated>2019-09-05T10:00:00Z</updated>
  <author>
   <name>Ming-Ho Yee</name></author>
  <content type="html">
&lt;p&gt;This all started with a simple question about the R programming language: &lt;em&gt;is R lexically or dynamically scoped?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;To answer that question, we need to understand what &lt;em&gt;scope&lt;/em&gt; is, along with &lt;em&gt;lexical scope&lt;/em&gt; and &lt;em&gt;dynamic scope&lt;/em&gt;.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;In this blog post, I&amp;rsquo;d like to explain the differences between lexical scope and dynamic scope, and also explore some of the history behind those ideas. In a &lt;a href="/blog/2019/09/10/scoping-in-r/"&gt;subsequent post&lt;/a&gt;, I&amp;rsquo;ll discuss scoping in R and why it can be confusing.&lt;/p&gt;

&lt;h2 id="what-is-scope"&gt;What is scope?&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Scope&lt;/em&gt; refers to the places in a program where a variable is visible and can be referenced.&lt;/p&gt;

&lt;p&gt;An interesting situation is when a function has free variables. Consider the example below:&lt;/p&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# what does this return?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;On line 1, we create a mapping for &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;1&lt;/code&gt;. On line 2, we define a function &lt;code&gt;f&lt;/code&gt; whose body uses the parameter &lt;code&gt;a&lt;/code&gt;, but also the free variable &lt;code&gt;x&lt;/code&gt;. On line 3, we define a function &lt;code&gt;g&lt;/code&gt;, whose body creates a new mapping for &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;2&lt;/code&gt;, and then calls &lt;code&gt;f(0)&lt;/code&gt;. (Note that line 4 does not update the mapping created on line 1.) Finally, on line 7, we call &lt;code&gt;g()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What value does &lt;code&gt;g&lt;/code&gt; return when it is called? What mapping does the free variable &lt;code&gt;x&lt;/code&gt; on line 2 refer to? Does it refer to the mapping on line 1 that was visible when &lt;code&gt;f&lt;/code&gt; was defined? Or does it refer to the mapping on line 4 that was created just before &lt;code&gt;f&lt;/code&gt; was called?&lt;/p&gt;

&lt;h3 id="lexical-scoping"&gt;Lexical scoping&lt;/h3&gt;

&lt;p&gt;Under &lt;em&gt;lexical scoping&lt;/em&gt; (also known as &lt;em&gt;static scoping&lt;/em&gt;), the scope of a variable is determined by the lexical (&lt;em&gt;i.e.&lt;/em&gt;, textual) structure of a program.&lt;/p&gt;

&lt;p&gt;In the example above, the definition of &lt;code&gt;x&lt;/code&gt; on line 1 creates a scope that starts after its definition and extends &lt;em&gt;into&lt;/em&gt; the bodies of &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;. However, the second definition of &lt;code&gt;x&lt;/code&gt; on line 4 creates a new scope that (1) shadows the previous definition of &lt;code&gt;x&lt;/code&gt;, and (2) does not extend into the call &lt;code&gt;f(0)&lt;/code&gt; on line 5. Looking at this from another direction, the use of &lt;code&gt;x&lt;/code&gt; on line 2 is within the scope created by the definition on line 1, and thus refers to that definition.&lt;/p&gt;

&lt;p&gt;Therefore, under lexical scoping, the example program returns &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Most programming languages we use today are lexically scoped. Intuitively, a human (or compiler) can determine the scope of a variable by just examining the source code of a program. In other words, a compiler can determine which &lt;em&gt;definition&lt;/em&gt; each variable refers to&amp;mdash;but it may not be able to determine the &lt;em&gt;values&lt;/em&gt; of each variable.&lt;/p&gt;

&lt;h3 id="dynamic-scoping"&gt;Dynamic scoping&lt;/h3&gt;

&lt;p&gt;Under &lt;em&gt;dynamic scoping&lt;/em&gt;, a variable is bound to the most recent value assigned to that variable, &lt;em&gt;i.e.&lt;/em&gt;, the most recent assignment &lt;em&gt;during the program&amp;rsquo;s execution&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In the example above, the free variable &lt;code&gt;x&lt;/code&gt; in the body of &lt;code&gt;f&lt;/code&gt; is evaluated when &lt;code&gt;f(0)&lt;/code&gt; is called on line 5. At that point (during program execution), the most recent assignment was on line 4.&lt;/p&gt;

&lt;p&gt;Therefore, under dynamic scoping, the example program returns &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Dynamically scoped programming languages include bash, LaTeX, and the original version of Lisp. Emacs Lisp is dynamically scoped, but allows the programmer to select lexical scoping. Conversely, Perl and Common Lisp are lexically scoped by default, but allow the programmer to select dynamic scoping.&lt;/p&gt;

&lt;p&gt;(&lt;strong&gt;Edited 2020/08/13:&lt;/strong&gt; As of &lt;a href="https://www.gnu.org/savannah-checkouts/gnu/emacs/news/NEWS.27.1"&gt;Emacs 27.1&lt;/a&gt;, &amp;ldquo;lexical binding is now used by default when evaluating interactive Elisp.&amp;rdquo; Thanks to Artem Pelenitsyn for bringing this to my attention.)&lt;/p&gt;

&lt;h2 id="now-for-a-digression"&gt;Now for a digression&lt;/h2&gt;

&lt;p&gt;These are the definitions I learned from my classes and textbooks, and should be similar to other definitions and explanations you might find online.&lt;/p&gt;

&lt;p&gt;However, it took me many drafts and attempts before arriving at the current version. I had difficulty writing an explanation that I was satisfied with&amp;mdash;a definition that was not circular, did not appeal to some intuition or familiarity, and did not conflate terms. Even some of the resources I consulted had these issues.&lt;sup&gt;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-1-definition" name="2019-09-05-lexical-and-dynamic-scope-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;I am much happier with my current version, but it still bothers me slightly. If lexical scope and dynamic scope are related concepts, then why are the definitions so different? Why does the definition for &lt;em&gt;dynamic scope&lt;/em&gt; not mention scope at all? If &lt;em&gt;scope&lt;/em&gt; is about &amp;ldquo;where a variable is visible,&amp;rdquo; and that definition is with respect to a &lt;em&gt;variable definition&lt;/em&gt;, then why do so many explanations and examples define lexical and dynamic scope in terms of &lt;em&gt;variable use&lt;/em&gt;?&lt;/p&gt;

&lt;h2 id="scope-and-extent"&gt;Scope and Extent&lt;/h2&gt;

&lt;p&gt;I found some answers in Guy Steele&amp;rsquo;s &lt;em&gt;Common Lisp the Language, 2nd Edition&lt;/em&gt;,&lt;sup&gt;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-2-definition" name="2019-09-05-lexical-and-dynamic-scope-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt; which Matthias Felleisen recommended to me.&lt;/p&gt;

&lt;p&gt;In chapter 3, Steele introduces the concepts of &lt;em&gt;scope&lt;/em&gt; and &lt;em&gt;extent&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;Scope&lt;/em&gt; refers to the spatial or textual region of the program within which references may occur. &lt;em&gt;Extent&lt;/em&gt; refers to the interval of time during which references may occur.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In addition, there are four interesting cases of scope and extent, with respect to Common Lisp:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;em&gt;Lexical scope&lt;/em&gt;: a reference can only occur within certain textual regions  of the program, which are determined by the establishing construct, &lt;em&gt;e.g.&lt;/em&gt;,  the body of a variable definition.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;em&gt;Indefinite scope&lt;/em&gt;: a reference can occur anywhere in the program.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;em&gt;Dynamic extent&lt;/em&gt;: a reference can occur during the time between an entity&amp;rsquo;s  creation and its explicit destruction, &lt;em&gt;e.g.&lt;/em&gt;, when a local variable is  created upon entering a function and destroyed when returning from that  function.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;em&gt;Indefinite extent&lt;/em&gt;: an entity may exist as long as it is possible to be  referenced. (Note that this is the idea behind garbage collection: an  entity can be destroyed once references to it are impossible.)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Steele points out that &lt;em&gt;dynamic scope&lt;/em&gt; is a misnomer, even though it is both a traditional and useful concept. It can be defined as &lt;em&gt;indefinite scope and dynamic extent&lt;/em&gt;. In other words, references to a variable may occur anywhere in a program, as long as that variable has been initialized and has not yet been explicitly destroyed. Furthermore, a later initialization hides an earlier one.&lt;/p&gt;

&lt;h3 id="discussion"&gt;Discussion&lt;/h3&gt;

&lt;p&gt;I found this approach very informative, because it explicitly distinguishes between space (scope) and time (extent), which further implies a separation between compile time and run time. This explains my unease with the definition of &amp;ldquo;dynamic scope&amp;rdquo;&amp;mdash;it is nominally about textual regions in a program, but also requires consideration of run-time behaviour. Dynamic scope is a misnomer!&lt;/p&gt;

&lt;p&gt;The above definitions are specifically for Common Lisp, but I believe we can learn from them and adapt them for other programming languages.&lt;/p&gt;

&lt;h2 id="a-brief-and-incomplete-history-of-lexical-scope"&gt;A brief and incomplete history of lexical scope&lt;/h2&gt;

&lt;p&gt;During my research of different definitions of lexical scope, I began to wonder if there was an &amp;ldquo;original&amp;rdquo; definition of lexical scope. I did not find one, but I was able to trace some of the connections between Lisp, Scheme, and ALGOL 60. This history is certainly incomplete, but I hope it is somewhat useful and interesting.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;1960&lt;/strong&gt;. John McCarthy publishes the original paper on Lisp.&lt;sup&gt;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-3-definition" name="2019-09-05-lexical-and-dynamic-scope-footnote-3-return"&gt;3&lt;/a&gt;&lt;/sup&gt; In  &lt;em&gt;History of Lisp&lt;/em&gt;,&lt;sup&gt;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-4-definition" name="2019-09-05-lexical-and-dynamic-scope-footnote-4-return"&gt;4&lt;/a&gt;&lt;/sup&gt; McCarthy writes that he borrowed the λ-notation from  Alonzo Church&amp;rsquo;s lambda calculus, but none of the other ideas. He also  recounts an incident where a programmer desired lexical scoping, but Lisp  used dynamic scoping. McCarthy considered this to be a bug, which Steve  Russell later fixed by developing the &amp;ldquo;FUNARG device.&amp;rdquo;&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;1963&lt;/strong&gt;. After a few years of work, the &lt;em&gt;Revised Report on Algorithm  Language ALGOL 60&lt;/em&gt; is published.&lt;sup&gt;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-5-definition" name="2019-09-05-lexical-and-dynamic-scope-footnote-5-return"&gt;5&lt;/a&gt;&lt;/sup&gt; While &amp;ldquo;lexical scope&amp;rdquo; is not explicitly  mentioned, it is recognizable in the specification.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;1964&lt;/strong&gt;. Peter Landin shows how expressions in programming languages can  be modelled in Church&amp;rsquo;s λ-notation.&lt;sup&gt;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-6-definition" name="2019-09-05-lexical-and-dynamic-scope-footnote-6-return"&gt;6&lt;/a&gt;&lt;/sup&gt; He also introduces the concept of a  &lt;em&gt;closure&lt;/em&gt;, which pairs a lambda expression with the environment it was  evaluated in.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;1970&lt;/strong&gt;. Joel Moses describes the problem of free variables in  functions.&lt;sup&gt;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-7-definition" name="2019-09-05-lexical-and-dynamic-scope-footnote-7-return"&gt;7&lt;/a&gt;&lt;/sup&gt; He considers both the &amp;ldquo;downward&amp;rdquo; case (where a function is  passed to another function) and the &amp;ldquo;upward&amp;rdquo; case (where a function returns  a function), and remarks on the correspondence between Lisp&amp;rsquo;s FUNARG device  and Landin&amp;rsquo;s closures.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;1975&lt;/strong&gt;. Gerald Sussman and Guy Steele publish the first Scheme paper.&lt;sup&gt;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-8-definition" name="2019-09-05-lexical-and-dynamic-scope-footnote-8-return"&gt;8&lt;/a&gt;&lt;/sup&gt;  They describe their goal of a Lisp-like language that is based on the  lambda calculus. As a consequence, they implement lexical scoping with  closures, to preserve the substitution semantics of the lambda calculus.  They compare this scoping discipline to ALGOL&amp;rsquo;s.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;1978&lt;/strong&gt;. Steele and Sussman describe various programming language design  choices, by developing an interpreter for each programming language  variation.&lt;sup&gt;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-9-definition" name="2019-09-05-lexical-and-dynamic-scope-footnote-9-return"&gt;9&lt;/a&gt;&lt;/sup&gt; In particular, they provide a detailed discussion on  lexical and dynamic scoping.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="next-stop-r"&gt;Next stop, R&lt;/h2&gt;

&lt;p&gt;Now that we have examined the definitions of lexical and dynamic scope, and also explored some history, we are ready to return to the original question. &lt;em&gt;Is R lexically or dynamically scoped?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In the &lt;a href="/blog/2019/09/10/scoping-in-r/"&gt;next blog post&lt;/a&gt;, we&amp;rsquo;ll answer that question, and also see how R can be very confusing.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;I would like to thank Sam Caldwell, Ben Greenman, and Artem Pelenitsyn for their comments and feedback on this blog post.&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2019-09-05-lexical-and-dynamic-scope-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;For example, at one point I defined lexical/dynamic scoping in terms of a &amp;ldquo;lexical environment&amp;rdquo; and a &amp;ldquo;dynamic environment.&amp;rdquo; But (1) that&amp;rsquo;s a circular definition, (2) it assumes the reader has some intuition of how a &amp;ldquo;lexical environment&amp;rdquo; is different from a &amp;ldquo;dynamic environment,&amp;rdquo; and (3) it conflates two different kinds of &amp;ldquo;environment.&amp;rdquo;&amp;nbsp;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-05-lexical-and-dynamic-scope-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;G. Steele. &amp;ldquo;Scope and Extent,&amp;rdquo; in &lt;em&gt;Common Lisp the Language&lt;/em&gt;, 2nd ed. 1990. [&lt;a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node43.html#SECTION00700000000000000000"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-2-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-05-lexical-and-dynamic-scope-footnote-3-definition" class="footnote-definition"&gt;
   &lt;p&gt;J. McCarthy. &amp;ldquo;Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I,&amp;rdquo; &lt;em&gt;Communications of the ACM&lt;/em&gt;, vol. 3, no. 4, April 1960. [&lt;a href="https://doi.org/10.1145/367177.367199"&gt;DOI&lt;/a&gt;][&lt;a href="http://jmc.stanford.edu/articles/recursive/recursive.pdf"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-3-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-05-lexical-and-dynamic-scope-footnote-4-definition" class="footnote-definition"&gt;
   &lt;p&gt;J. McCarthy. &amp;ldquo;History of LISP,&amp;rdquo; in &lt;em&gt;History of Programming Languages&lt;/em&gt;, 1978. [&lt;a href="https://doi.org/10.1145/800025.1198360"&gt;DOI&lt;/a&gt;][&lt;a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-4-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-05-lexical-and-dynamic-scope-footnote-5-definition" class="footnote-definition"&gt;
   &lt;p&gt;P. Naur (ed.). &amp;ldquo;Revised Report on Algorithmic Language ALGOL 60,&amp;rdquo; &lt;em&gt;Communications of the ACM&lt;/em&gt;, vol. 6, no. 1, January 1963. [&lt;a href="http://dx.doi.org/10.1145/366193.366201"&gt;DOI&lt;/a&gt;][&lt;a href="https://www.masswerk.at/algol60/report.htm"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-5-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-05-lexical-and-dynamic-scope-footnote-6-definition" class="footnote-definition"&gt;
   &lt;p&gt;P. Landin. &amp;ldquo;The mechanical evaluation of expressions,&amp;rdquo; &lt;em&gt;The Computer Journal&lt;/em&gt;, vol. 6, no. 4, January 1964. [&lt;a href="https://doi.org/10.1093/comjnl/6.4.308"&gt;DOI&lt;/a&gt;][&lt;a href="https://www.cs.cmu.edu/~crary/819-f09/Landin64.pdf"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-6-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-05-lexical-and-dynamic-scope-footnote-7-definition" class="footnote-definition"&gt;
   &lt;p&gt;J. Moses. &amp;ldquo;The Function of FUNCTION in LISP or Why the FUNARG Problem Should be Called the Environment Problem,&amp;rdquo; &lt;em&gt;SIGSAM Bulletin 15&lt;/em&gt;, July 1970. [&lt;a href="https://doi.org/10.1145/1093410.1093411"&gt;DOI&lt;/a&gt;][&lt;a href="https://dspace.mit.edu/handle/1721.1/5854"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-7-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-05-lexical-and-dynamic-scope-footnote-8-definition" class="footnote-definition"&gt;
   &lt;p&gt;G. Sussman and G. Steele. &amp;ldquo;SCHEME: An Interpreter for Extended Lambda Calculus.&amp;rdquo; 1975. [&lt;a href="https://dspace.mit.edu/handle/1721.1/5794"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-8-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-05-lexical-and-dynamic-scope-footnote-9-definition" class="footnote-definition"&gt;
   &lt;p&gt;G. Steele and G. Sussman. &amp;ldquo;The Art of the Interpreter or, The Modularity Complex (Parts Zero, One, and Two).&amp;rdquo; 1978. [&lt;a href="https://dspace.mit.edu/handle/1721.1/6094"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-9-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content></entry>
 <entry>
  <title type="text">[Conversational Concurrency (cross-post)](https://eighty-twenty.org/2018/01/24/conversational-concurrency)</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2019/05/11/-conversational-concurrency-cross-post-https-eighty-twenty-org-2018-01-24-conversational-concurrency/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2019-05-11-conversational-concurrency-cross-post-https-eighty-twenty-org-2018-01-24-conversational-concurrency</id>
  <published>2019-05-11T00:03:16Z</published>
  <updated>2019-05-11T00:03:16Z</updated>
  <author>
   <name>Tony Garnock-Jones</name></author>
  <content type="html"></content></entry>
 <entry>
  <title type="text">Forgetful and Heedful contracts</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2019/04/07/forgetful-and-heedful-contracts/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2019-04-07-forgetful-and-heedful-contracts</id>
  <published>2019-04-07T23:15:11Z</published>
  <updated>2019-04-07T23:15:11Z</updated>
  <author>
   <name>Ben Greenman</name></author>
  <content type="html">
&lt;p&gt;&lt;em&gt;Forgetful&lt;/em&gt; and &lt;em&gt;heedful&lt;/em&gt; are two methods for space-efficient contracts  developed by &lt;a href="http://www.cs.pomona.edu/~michael/"&gt;Michael Greenberg&lt;/a&gt; in &lt;a href="https://arxiv.org/abs/1410.2813"&gt;2014&lt;/a&gt;. These methods were born in the shadow of a third method, &lt;em&gt;eidetic&lt;/em&gt;,  with stronger theoretic properties. Since then, however, the forgetful method has been re-invented at least twice. Both deserve a second look.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;hr /&gt;

&lt;p&gt;Contracts are a tool for specifying and dynamically-enforcing the behavior  of a program. In a language with contracts, a programmer can annotate an API with  code that documents the intended use for other readers. When client code interacts with such an API, the annotations ensure that the  actual behavior matches the expected. If there is a mismatch, the contract annotations can report an issue  in terms of &lt;a href="https://www2.ccs.neu.edu/racket/pubs/popl11-dfff.pdf"&gt;three parties&lt;/a&gt;:  the API code, the client code, and the contract between them.&lt;/p&gt;

&lt;p&gt;For example, a Racket module that exports a sorting function can use a contract  to describe the kind of input it expects. If a client module sends invalid input, the contract blames the client  module for the error, assuming that the contract is bug-free:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #lang racket/base

  (module sort racket
    (provide
      (contract-out
        [quicksort
          (-&amp;gt; (vectorof point/c) void?)]))

    (define point/c (vectorof integer?))

    (define (quicksort points)
      ....))

  (module client racket
    (require (submod ".." sort))
    (quicksort '()))

  (require 'client)&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;quicksort: contract violation;
 expected a vector
  given: '()
  in: the 1st argument of
      (-&amp;gt; (vectorof (vectorof integer?)) void?)
  contract from: 
      (file.rkt sort)
  blaming: (file.rkt client)
   (assuming the contract is correct)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That covers the basics. For an extended introduction to contracts, visit  &lt;a href="https://docs.racket-lang.org/guide/contracts.html"&gt;The Racket Guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The quicksort example and the related figures are from the paper  &lt;a href="http://users.cs.northwestern.edu/~robby/pubs/papers/oopsla2018-fgsfs.pdf"&gt;&lt;em&gt;Collapsible Contracts: Fixing a Pathology of Gradual Typing&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id="classic-contracts-and-space-efficiency"&gt;Classic contracts and &amp;ldquo;Space Efficiency&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;(vectorof point/c)&lt;/code&gt; contract used above describes a possibly-mutable  array whose elements match the &lt;code&gt;point/c&lt;/code&gt; contract. Since the array can be mutated, this contract has implications for two parties:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;the client module must supply a good array, and&lt;/li&gt;
 &lt;li&gt;the sorting module must not insert a bad element.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;To enforce the second condition, the &lt;code&gt;vectorof&lt;/code&gt; contract wraps incoming  vectors in a proxy that checks future writes. Suppose the client sends a vector with four points:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(quicksort (vector (vector 4 4)
                   (vector 2 2)
                   (vector 1 1)
                   (vector 3 3)))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After applying the contract, the vector is wrapped in a proxy that checks  incoming writes and outgoing reads. The following picture illustrates the wrapper with a &lt;strong&gt;solid&lt;/strong&gt; blue bar  for the &lt;strong&gt;write&lt;/strong&gt; checks against the sort module and a &lt;em&gt;striped&lt;/em&gt; blue bar  for the &lt;em&gt;read&lt;/em&gt; checks against the client.&lt;/p&gt;

&lt;p&gt;&lt;img src="/img/vector-chaperone-0.png" alt="A wrapped vector" /&gt;&lt;/p&gt;

&lt;p&gt;In a straightforward implementation, these wrappers can stack up if multiple  contracts are applied to the same value. For our quicksort in particular, the elements of the vector are mutable  vectors and may accumulate wrappers as the vector is sorted &amp;mdash;  because every &lt;strong&gt;write&lt;/strong&gt; and &lt;em&gt;read&lt;/em&gt; applies a contract to the element.&lt;/p&gt;

&lt;p&gt;&lt;img src="/img/vector-chaperone-1.png" alt="Layers of element wrappers" /&gt;&lt;/p&gt;

&lt;p&gt;On the bright side, these wrappers enforce the contracts and help the  programmer understand the source of the error if any contract is violated.&lt;/p&gt;

&lt;p&gt;Unfortunately, the wrappers also affect the performance of the program. There are prices to pay for:  (1) checking values against the contracts,  (2) allocating new wrappers,  (3) and &amp;ldquo;indirecting&amp;rdquo; future writes/reads through wrappers. These space and time costs can add up.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&amp;ldquo;on a randomly ordered vector of 1,000 points, a call to quicksort can wrap the inner vectors an average of 21 times&amp;rdquo; &amp;mdash; &lt;a href="http://users.cs.northwestern.edu/~robby/pubs/papers/oopsla2018-fgsfs.pdf"&gt;&lt;em&gt;Collapsible Contracts&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;To fix the problem, researchers have been exploring &lt;em&gt;space-efficient&lt;/em&gt;  implementations of contracts that attach a bounded number of wrappers to any  value. Michael Greenberg is one of these researchers, and &lt;em&gt;eidetic&lt;/em&gt;, &lt;em&gt;forgetful&lt;/em&gt;,  and &lt;em&gt;heedful&lt;/em&gt; are his names for three implementations.&lt;/p&gt;

&lt;p&gt;(Although the goal of this post is to promote &lt;em&gt;forgetful&lt;/em&gt; and &lt;em&gt;heedful&lt;/em&gt;,  we will review all three.)&lt;/p&gt;

&lt;h3 id="eidetic-space-efficiency"&gt;Eidetic space-efficiency&lt;/h3&gt;

&lt;p&gt;The eidetic method introduces a data structure to represent higher-order  contracts. The structure supports a &lt;em&gt;merge&lt;/em&gt; operation;  when two contracts meet, they are merged in a way that avoids duplication. Eidetic contracts have the same behavior as normal &amp;ldquo;wrapping&amp;rdquo; contracts  and their size is bounded by the number (and height) of source-code  contracts in the program.&lt;/p&gt;

&lt;p&gt;An eidetic contract is an &lt;code&gt;N&lt;/code&gt;-ary tree (for &lt;code&gt;N &amp;gt; 0&lt;/code&gt;):&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;each node represents a higher-order contract combinator, such as &lt;code&gt;vectorof&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;the &lt;code&gt;N&lt;/code&gt; children of a node represent the different interactions that the  value supports&lt;/li&gt;
 &lt;li&gt;each leaf is a list of non-higher-order, or &lt;em&gt;flat&lt;/em&gt;, contracts&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;For example, the &lt;code&gt;(vectorof point/c)&lt;/code&gt; source-code contract describes an  eidetic tree with 3 nodes and 4 singleton-list leaves. Section 3.1 of the &lt;a href="http://users.cs.northwestern.edu/~robby/pubs/papers/oopsla2018-fgsfs.pdf"&gt;Collapsible Contracts&lt;/a&gt; paper has an illustration. Each tree node represents a &lt;code&gt;vectorof&lt;/code&gt; contract;  these nodes have &lt;code&gt;N=2&lt;/code&gt; children because vectors support reads and writes.&lt;/p&gt;

&lt;p&gt;A successful merge combines two trees of the same shape  by re-using half the nodes  and appending the leaf lists. Re-using nodes saves some space, and helps reduce the overhead of trees  relative to simple wrapping contracts. The main savings comes from filtering the leaf lists &amp;mdash; if an  implementation comes with a &lt;code&gt;contract-stronger?&lt;/code&gt; predicate that tests  whether one flat contract accepts fewer values than a second, then it  can remove leaf-list contracts that are preceded by stronger ones. Trees make this filtering possible.&lt;/p&gt;

&lt;p&gt;Suffice to say, eidetic is an ideal solution in theory but comes with  practical challenges. Are trees more expensive than wrappers in the common case? Can the leaf-lists in a tree share elements? Should &lt;code&gt;contract-stronger?&lt;/code&gt; try to solve problems that lack polynomial-time  solutions?&lt;/p&gt;

&lt;p&gt;Thankfully, there are at least two &amp;ldquo;compromise&amp;rdquo; alternatives.&lt;/p&gt;

&lt;h3 id="forgetful-space-efficiency"&gt;Forgetful space-efficiency&lt;/h3&gt;
&lt;!-- "no operation relies on e being a T2, skipping the check doesn't risk soundness" p.12--&gt;
&lt;!-- "In forgetful \lambda_H, we offer a simple solution to space inefficient casts: just forget about them" p.11--&gt;
&lt;!-- "Just the same, when accumulating casts on the stack, we throw away all but the last cast" p.11--&gt;
&lt;!-- "forgetful ... skip[s] checks and change[s] blame labels" p.3--&gt;

&lt;blockquote&gt;
 &lt;p&gt;&amp;ldquo;Forgetful is an interesting middle ground: if contracts exist to make partial operations safe (and not abstraction or information hiding), forgetfulness may be a good strategy.&amp;rdquo; &amp;mdash; &lt;a href="https://arxiv.org/abs/1410.2813"&gt;&lt;em&gt;Space-Efficient Manifest Contracts&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;!-- Section 10, bottom of page 23--&gt;&lt;/blockquote&gt;

&lt;p&gt;The forgetful method is exceptionally simple. When applying a new contract to a value, first check whether it is  wrapped in a similar contract. If so, then replace the existing wrapper with one that combines:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;the client obligations from the old contract, and&lt;/li&gt;
 &lt;li&gt;the server obligations from the new contract&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;If not, proceed as usual &amp;mdash; by wrapping (an unwrapped value)  or raising an error. Every value receives at most &lt;strong&gt;one&lt;/strong&gt; wrapper;  this wrapper changes as the value flows to different clients.&lt;/p&gt;

&lt;p&gt;Forgetful is safe in the sense that every piece of code can trust the  top-level shape of the values it receives. Suppose module &lt;code&gt;A&lt;/code&gt; exports a function &lt;code&gt;f&lt;/code&gt; with contract &lt;code&gt;(-&amp;gt; T1 T2)&lt;/code&gt; to  module &lt;code&gt;B&lt;/code&gt;, and suppose module &lt;code&gt;B&lt;/code&gt; shares this function with a few other  client modules using different contracts. As &lt;code&gt;f&lt;/code&gt; flows to a new client, it keeps the &lt;code&gt;T1&lt;/code&gt; domain check and gets a  replacement for the &lt;code&gt;T2&lt;/code&gt; codomain check.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Keeping &lt;code&gt;T1&lt;/code&gt; ensures that the code inside the function  (defined by module &lt;code&gt;A&lt;/code&gt;) receives input that matches its expectation.&lt;/li&gt;
 &lt;li&gt;Replacing &lt;code&gt;T2&lt;/code&gt; ensures that each new client receives output that it expects.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Unfortunately, replacing &lt;code&gt;T2&lt;/code&gt; also means that clients of module &lt;code&gt;B&lt;/code&gt; cannot  trust the &lt;code&gt;T2&lt;/code&gt; contract. This contract is not checked, and so forgetful contracts &lt;strong&gt;miss&lt;/strong&gt; some  errors that would be caught by standard contracts. For the same reason, a bug in module &lt;code&gt;B&lt;/code&gt; may go undetected by its clients  &amp;mdash; even if a later contract reports an issue, the contract system has  no memory that &lt;code&gt;B&lt;/code&gt; was partly-responsible.&lt;/p&gt;

&lt;p&gt;Despite these changes in behavior, forgetful is a straightforward  method for saving space and time relative to classic contracts.&lt;/p&gt;

&lt;h3 id="heedful-space-efficiency"&gt;Heedful space-efficiency&lt;/h3&gt;

&lt;p&gt;A heedful contract is a set of classic higher-order contracts. When applying a new contract to a value, check whether the new contract  is in the set. If so, ignore the new contract. If not, add the new contract to the set &amp;mdash; or raise an error. Every value gets at most one set-wrapper, and each member of a set-wrapper  represents a new constraint.&lt;/p&gt;

&lt;p&gt;To check a value against a set, for example when reading from a vector, check  each of the elements in any order. If an element raises an error, report it.* Alternatively, an implementation can check all the elements and report  all that disagree with the value.&lt;/p&gt;

&lt;p&gt;The heedful method is a compromise between forgetful and eidetic.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Unlike forgetful, heedful uses a new data structure to represent contacts  and requires some kind of &lt;code&gt;contract-stronger?&lt;/code&gt; predicate.  Heedful also remembers (some of) the history of a value and catches the  same errors as classic and eidetic contracts.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Unlike eidetic, heedful uses a simpler data structure with  no need to keep duplicate flat contracts  depending on the order they are encountered.  Heedful cannot, however, uniquely identify the two parties involved in a  contract error.  In general, there are multiple contracts that a programmer  must inspect to find the source of a mismatch.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;For details, see &lt;a href="https://arxiv.org/abs/1410.2813"&gt;the extended version&lt;/a&gt;  of Michael&amp;rsquo;s POPL 2015 paper. Don&amp;rsquo;t bother searching &lt;a href="http://www.cs.pomona.edu/~michael/papers/popl2015_space.pdf"&gt;the conference version&lt;/a&gt;  &amp;mdash; aside from one remark  in Appendix B, heedful and forgetful are nowhere to be found.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt; If an implementation promises to report one mismatch, instead of all  mismatches, then it does not need to keep the full set of contracts. Thanks to &lt;a href="http://mballantyne.net/"&gt;Michael Ballantyne&lt;/a&gt; for explaining  this to me.&lt;/p&gt;

&lt;h3 id="priorities-and-appearances"&gt;Priorities and Appearances&lt;/h3&gt;

&lt;p&gt;The extended version of &lt;em&gt;Space-Efficient Manifest Contracts&lt;/em&gt; introduces  the forgetful and heedful methods with extreme modesty. It&amp;rsquo;s tempting to skip past them and focus on the eidetic method.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&amp;ldquo;Since eidetic and classic contracts behave the same, why bother with forgetful and heedful? First and foremost, the calculi offer insights into the semantics of contracts: the soundness of forgetful depends on a certain philosophy of contracts; heedful relates to threesomes without blame [&lt;a href="https://dl.acm.org/citation.cfm?doid=1706299.1706342"&gt;Siek and Wadler 2010&lt;/a&gt;]. Second, we offer them as alternative points in the design space. Finally and perhaps cynically, they are strawmen&amp;mdash;warm up exercises for eidetic.&amp;rdquo; &amp;mdash; &lt;a href="https://arxiv.org/abs/1410.2813"&gt;&lt;em&gt;Space-Efficient Manifest Contracts&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;!-- Section 1, bottom of page 2--&gt;&lt;/blockquote&gt;

&lt;p&gt;And yet, at least two other research papers rely on these &amp;ldquo;strawmen&amp;rdquo; &amp;mdash; or  rather, the ideas behind the names.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://dl.acm.org/citation.cfm?id=3110285"&gt;&lt;em&gt;Gradual Typing with Union and Intersection Types&lt;/em&gt;&lt;/a&gt;,  at ICFP 2017,  demonstrates one technique for adding two varieties of types to a gradual  language. The semantics in the paper is forgetful;  if a higher-order value crosses multiple type boundaries,  the intermediate server obligations disappear.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&amp;ldquo;if a lambda abstraction is preceded by multiple casts, then the rule erases all of them, except for the last one&amp;rdquo; &amp;mdash; &lt;a href="https://dl.acm.org/citation.cfm?id=3110285"&gt;&lt;em&gt;Gradual Typing with Union and Intersection Types&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;!-- page 21--&gt;&lt;/blockquote&gt;

&lt;p&gt;This forgetfulness was a deliberate choice. A classic semantics would satisfy the same type soundness theorem,  but the authors picked forgetful for its simplicity and performance  implications.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&amp;ldquo;removing these casts preserves the soundness of the evaluation while reducing the number of them&amp;rdquo;&lt;/p&gt;
 &lt;p&gt;&amp;ldquo;while this choice makes the calculus simpler without hindering soundness, it yields a formalism unfit to finger culprits&amp;rdquo; &amp;mdash; &lt;a href="https://dl.acm.org/citation.cfm?id=3110285"&gt;&lt;em&gt;Gradual Typing with Union and Intersection Types&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;!-- p.27--&gt;&lt;!-- page 21--&gt;&lt;/blockquote&gt;
&lt;!-- The followup at POPL 2019 is not forgetful.--&gt;
&lt;!-- It's similar to eager coercions ... keep all types around and error--&gt;
&lt;!--  if there's a new type that doesn't match the old ones.--&gt;
&lt;!-- Also, that paper chooses not to let functions have intersection types,--&gt;
&lt;!--  which kind-of-avoids the questions ... but really the eagerness is key.--&gt;

&lt;p&gt;&lt;a href="https://dl.acm.org/citation.cfm?id=3009849"&gt;&lt;em&gt;Big Types in Little Runtime&lt;/em&gt;&lt;/a&gt;, at POPL 2017,  presents a gradual typing system that avoids the use of wrappers. Instead, their &lt;em&gt;transient&lt;/em&gt; semantics rewrites typed code ahead of time  to mimic the checks that forgetful contracts would perform. These checks suffice for a shallow type soundness theorem.&lt;/p&gt;

&lt;p&gt;That paper also introduces a heedful-like strategy for improving the error  messages produced by a forgetful check. The strategy adds a global map to the semantics;  keys in the map are unique identifiers for values (heap addresses),  and values are sets of types. When a value meets a compatible type, the type is added to the value&amp;rsquo;s set. When a mismatch occurs, the semantics &lt;a href="https://www.ccs.neu.edu/home/types/resources/notes/transient-undefined-blame-extract.pdf"&gt;tries to report&lt;/a&gt;  every type in the set that relates to the mismatch.&lt;/p&gt;

&lt;p&gt;And so, forgetful and heedful were edged out of POPL 2015 but managed to sneak in  to POPL 2017. Since then, forgetful appeared in ICFP 2017 and, briefly, in  &lt;a href="https://www2.ccs.neu.edu/racket/pubs/icfp18-gf.pdf"&gt;ICFP 2018&lt;/a&gt;. Where will we see them next?&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">PLISS: Learn About PL Implementation in a Castle</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2019/03/09/pliss-learn-about-pl-implementation-in-a-castle/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2019-03-09-pliss-learn-about-pl-implementation-in-a-castle</id>
  <published>2019-03-09T14:40:16Z</published>
  <updated>2019-03-09T14:40:16Z</updated>
  <author>
   <name>Alexi Turcotte</name></author>
  <content type="html">
&lt;p&gt;We love programming languages (PLs), and we should all be in on the ins and outs of implementing them. If you&amp;rsquo;re interested in learning the tricks of the trade of PL design and implementation, what better opportunity than the second Programming Languages Implementation Summer School (&lt;a href="https://pliss2019.github.io/"&gt;PLISS&lt;/a&gt; for short).&lt;/p&gt;

&lt;p&gt;PLISS will be held from May 19th to 24th 2019, and the deadline to express your interest is &lt;em&gt;March 29th, 2019&lt;/em&gt; at &lt;em&gt;17:00 GMT&lt;/em&gt;. More details can be found &lt;a href="https://pliss2019.github.io/registration.html"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;&lt;img src="/img/pliss_summer_school_2017_logo.png" alt="PLISS logo" /&gt;&lt;/p&gt;

&lt;p&gt;The school will feature &lt;a href="https://pliss2019.github.io/speakers.html"&gt;ten speakers&lt;/a&gt; from both academia and industry, each well-versed in the practical side of programming languages. The lectures cover current research as well as future trends in programming language design and implementation, including:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Developing Security-Aware Languages with Cristina Cifuentes;&lt;/li&gt;
 &lt;li&gt;Semantics-First Language Design with Sylvan Clebsch;&lt;/li&gt;
 &lt;li&gt;Compiler Design Patterns for Machine Learning by Albert Cohen;&lt;/li&gt;
 &lt;li&gt;Design and Analysis of Configuration Languages by Arjun Guha;&lt;/li&gt;
 &lt;li&gt;A Survey of V8 and WebAssembly by Ben L. Titzer;&lt;/li&gt;
 &lt;li&gt;Crafting User-Friendly Compilers by Nicholas Matsakis;&lt;/li&gt;
 &lt;li&gt;Static Program Analysis by Anders Møller;&lt;/li&gt;
 &lt;li&gt;How Industry Approaches Language and Compiler Design by Joe Pamer;&lt;/li&gt;
 &lt;li&gt;What an End to Non-Volatile RAM Means for Researchers by Mario Wolczko.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Besides attending lectures, students will also be able to get to know the speakers and attendees and think of new research problems. A week-long stay in beautiful Bertinoro, Italy is an ideal setting for socializing with other PL enthusiasts and building lasting relationships.&lt;/p&gt;

&lt;p&gt;If I may, I attended the first PLISS in 2017 and can&amp;rsquo;t recommend it enough. The atmosphere at summer schools is truly unparalleled, and I made friends there that have stood the test of time. For what it&amp;rsquo;s worth to any prospective graduate students, PLISS is also where I met my PhD advisor. Students will be surprised at how many faces they recognize at future conferences, and in a sense summer schools are nice introduction to the research community. You can read another attendee&amp;rsquo;s testimonial &lt;a href="http://prl.ccs.neu.edu/blog/2017/06/05/report-pliss-2017/"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;More information can be found at:&lt;/p&gt;

&lt;p&gt;&lt;a href="https://pliss2019.github.io"&gt;https://pliss2019.github.io&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(No, really, it&amp;rsquo;s in a castle. Look at the pictures.)&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Writing a paper with Scribble</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2019/02/17/writing-a-paper-with-scribble/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2019-02-17-writing-a-paper-with-scribble</id>
  <published>2019-02-17T16:20:50Z</published>
  <updated>2019-02-17T16:20:50Z</updated>
  <author>
   <name>Ben Greenman</name></author>
  <content type="html">
&lt;p&gt;This post explains how to get started using Scribble to write a research paper.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
 &lt;p&gt;This post was written using &lt;a href="http://download.racket-lang.org/all-versions.html"&gt;Racket 7.1&lt;/a&gt; and &lt;a href="https://github.com/racket/scribble/releases/tag/v7.1"&gt;Scribble 1.29&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Writing about research is always difficult,  but a compile-to-LaTeX tool can make the task easier. If your research code is written in the same language as the paper, then:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;the paper can import definitions from the research,  keeping a single point of control;&lt;/li&gt;
 &lt;li&gt;the language&amp;rsquo;s functional abstractions can help manage the writing;&lt;/li&gt;
 &lt;li&gt;the language&amp;rsquo;s drawing and/or plotting libraries can replace &lt;a href="https://ctan.org/pkg/pgf?lang=en"&gt;TikZ&lt;/a&gt;;&lt;/li&gt;
 &lt;li&gt;and you can write unit tests to validate the claims made in the paper.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Scribble, &lt;a href="http://docs.racket-lang.org/scribble/index.html"&gt;the Racket documentation tool&lt;/a&gt;,  comes with a to-LaTeX compiler and a &lt;a href="http://docs.racket-lang.org/scribble/ACM_Paper_Format.html"&gt;scribble/acmart&lt;/a&gt;  library tailored to the new &lt;a href="https://ctan.org/pkg/acmart?lang=en"&gt;ACM paper format&lt;/a&gt;. I have been a pretty happy user of these tools. In the interest of attracting more happy users, this post  presents a short &amp;ldquo;getting started&amp;rdquo; guide  and links to some larger examples.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;For a Scribble tutorial, see the links in: &lt;a href="/blog/2017/05/23/building-a-website-with-scribble/index.html"&gt;Building a Website with Scribble&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2 id="getting-started-with-"&gt;Getting started with &lt;a href="http://docs.racket-lang.org/scribble/ACM_Paper_Format.html"&gt;scribble/acmart&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;The first line of a &lt;a href="http://docs.racket-lang.org/scribble/ACM_Paper_Format.html"&gt;scribble/acmart&lt;/a&gt; document sets the formatting options (similar to a LaTeX file using &lt;code&gt;acmart.cls&lt;/code&gt;). For example, the &lt;a href="https://conf.researchr.org/track/gpce-2018/gpce-2018#Call-for-Papers"&gt;GPCE 2018 call for papers&lt;/a&gt;  asks for anonymized &lt;code&gt;sigplan&lt;/code&gt;-format submissions with line numbers and 10 point font. The proper Scribble incantation is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#lang scribble/acmart @sigplan @anonymous @review @10pt&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, you may want to import some definitions. If we have a file &lt;code&gt;references.rkt&lt;/code&gt; (see below for a definition), we can import it as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@require{references.rkt}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The third main ingredient is the title and author information:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@(define neu (affiliation #:institution "Northeastern University"))
@(define anon (email "anon@anon.net"))

@title{Writing a paper with Scribble}
@author[#:affiliation neu #:email anon]{Ben Greenman}

@; optional: set the author names in the page headers
@elem[#:style "Sshortauthors"]{B. Greenman}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The paper is now ready to be written. You can forge ahead with a new &lt;a href="http://docs.racket-lang.org/scribble/base.html#%28def._%28%28lib._scribble%2Fbase..rkt%29._section%29%29"&gt;section&lt;/a&gt;  and start adding content to the same file;  alternatively, you can organize the writing across different modules. In this post, we will use the main document as an outline and &lt;a href="http://docs.racket-lang.org/scribble/base.html#%28form._%28%28lib._scribble%2Fbase..rkt%29._include-section%29%29"&gt;import&lt;/a&gt;  content from other modules:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@include-abstract{abstract.scrbl}
@include-section{introduction.scrbl}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, the main page is a good place to &lt;a href="https://docs.racket-lang.org/scriblib/autobib.html"&gt;generate the bibliography&lt;/a&gt;. Assuming this document imports a file like the &lt;code&gt;references.rkt&lt;/code&gt; below,  this expression inserts a bibliography titled &amp;ldquo;References&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@generate-bibliography[#:sec-title "References"]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To build the document, invoke &lt;code&gt;scribble&lt;/code&gt; on the command-line with the &lt;code&gt;--pdf&lt;/code&gt; or &lt;code&gt;--latex&lt;/code&gt;  options:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ raco scribble --pdf FILE.scrbl&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If all goes well, this command generates a &lt;code&gt;FILE.pdf&lt;/code&gt; with properly-linked cross references.&lt;/p&gt;

&lt;h3 id="auxiliary-files"&gt;Auxiliary Files&lt;/h3&gt;

&lt;p&gt;If you save the code above to a file &lt;code&gt;example.scrbl&lt;/code&gt; and save the files below  in the same directory, then you should be able to build an &lt;code&gt;example.pdf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;These files are available in a slightly different format at this link:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://gitlab.com/bengreenman/scribble-acmart-example"&gt;https://gitlab.com/bengreenman/scribble-acmart-example&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h4 id="referencesrkt"&gt;&lt;code&gt;references.rkt&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#lang racket/base

(provide
  ~cite citet generate-bibliography
  fbf-icfp-2009)

(require
  scriblib/autobib)

(define-cite ~cite citet generate-bibliography
  #:style author+date-square-bracket-style)

(define icfp "ICFP")

(define fbf-icfp-2009
  (make-bib
    #:title "Scribble: Closing the Book on Ad Hoc Documentation Tools"
    #:author (authors "Matthew Flatt" "Eli Barzilay" "Robert Bruce Findler")
    #:location (proceedings-location icfp #:pages '(109 120))
    #:date 2017))&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="abstractscrbl"&gt;&lt;code&gt;abstract.scrbl&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#lang scribble/acmart

A simple Scribble document.&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="introductionscrbl"&gt;&lt;code&gt;introduction.scrbl&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#lang scribble/acmart
@require{references.rkt}

@; start with `title` instead of `section`, because importing via
@;  `include-section` shifts all title/section/subsections down one level
@title{Introduction}

Scribble creates a connection between a stand-alone document and the artifact
it describes@~cite[fbf-icfp-2009].&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-how-to-debug-scribble-error-messages"&gt;Q. How to debug Scribble error messages?&lt;/h3&gt;

&lt;p&gt;If something goes wrong building a Scribble document, Racket is usually able to give a helpful error message.&lt;/p&gt;

&lt;p&gt;As a compile-time example, adding &lt;code&gt;@ foo&lt;/code&gt; to a document produces the message  &lt;code&gt;unexpected whitespace after @&lt;/code&gt; and you can either delete the whitespace  or change the &lt;code&gt;@&lt;/code&gt; to &lt;code&gt;@"@"&lt;/code&gt; for a literal &lt;code&gt;@&lt;/code&gt;-sign.&lt;/p&gt;

&lt;p&gt;As a run-time example, adding &lt;code&gt;@(+ 2 2)&lt;/code&gt; produces this message:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;not valid in document body (need a pre-part for decode) in: 4&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One fix is to convert &lt;code&gt;4&lt;/code&gt; to a string, as in &lt;code&gt;@~a[(+ 2 2)]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But if something goes wrong when Scribble renders a generated document to  PDF, the default error output is &lt;strong&gt;not&lt;/strong&gt; likely to help. For example, adding &lt;code&gt;@elem[#:style "oops"]&lt;/code&gt; to a document produces a giant  message:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ raco scribble --pdf FILE.scrbl
[[ ... 84K of output ... ]]
Output written on example.pdf (1 page, 277876 bytes).
PDF statistics:
 53 PDF objects out of 1000 (max. 8388607)
 37 compressed objects within 1 object stream
 7 named destinations out of 1000 (max. 500000)
 36877 words of extra memory for PDF output out of 42996 (max. 10000000)

run-pdflatex: got error exit code
  context...:
  [[ ... 17 more lines ... ]]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The best way to debug these messages is to &lt;strong&gt;ignore them&lt;/strong&gt; and use a LaTeX  compiler directly. For the &amp;ldquo;oops&amp;rdquo; mistake, LaTeX stops at the undefined control sequence &amp;mdash; giving  a hint about how to find the problem:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ raco scribble --latex FILE.scrbl
$ pdflatex FILE.tex
[[ ... 12KB of output ... ]]
! Undefined control sequence.
l.549 \oops
           {}
? &lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-how-to-add-a-latex-style-file"&gt;Q. How to add a LaTeX style file?&lt;/h3&gt;

&lt;p&gt;To add extra LaTeX code to the final document, create a new file and include  it with the &lt;code&gt;++style&lt;/code&gt; command-line flag. This copies the contents of the style file into the generated document  (the copy appears near the top of the generated code).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ raco scribble ++style style.tex --pdf FILE.scrbl&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is an example style file.&lt;/p&gt;

&lt;h4 id="styletex"&gt;&lt;code&gt;style.tex&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;\settopmatter{printfolios=true,printccs=true,printacmref=true}
% add page numbers etc.

\overfullrule=1mm
% draw a black rectangle near lines that overflow the margin&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another way to add extra LaTeX code is to add a &lt;a href="https://docs.racket-lang.org/scribble/core.html#%28def._%28%28lib._scribble%2Flatex-properties..rkt%29._tex-addition%29%29"&gt;&lt;code&gt;tex-addition&lt;/code&gt;&lt;/a&gt;  style property to the main title. This second approach makes it easy to include more than one file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#lang scribble/acmart

@require[
  (only-in scribble/core make-style)
  (only-in scribble/latex-properties make-tex-addition)]

@(define extra-style-files
   (list (make-tex-addition "style.tex")))

@title[#:style (make-style #f extra-style-files)]{Writing a paper with Scribble}

@; ....&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-how-to-make-a-figure"&gt;Q. How to make a figure?&lt;/h3&gt;

&lt;p&gt;Use the &lt;a href="http://docs.racket-lang.org/scriblib/figure.html#%28def._%28%28lib._scriblib%2Ffigure..rkt%29._figure%29%29"&gt;scriblib/figure&lt;/a&gt;  library to add figures to a document.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@require[pict scriblib/figure]
@figure[
  "fig:fish"  @; figure tag, see `figure-ref`
  @elem{A Standard Fish}  @; figure caption, appears below the content
  @elem{fish = @(standard-fish 90 40)}]  @; content&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The content of a figure can be almost anything that would work in the toplevel  of the document.&lt;/p&gt;

&lt;h3 id="q-how-to-include-extra-files-pictures-latex"&gt;Q. How to include extra files (pictures, LaTeX)?&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;++extra&lt;/code&gt; command-line flag names an auxilliary file that Scribble should  include when rendering the document. This flag may be supplied more than once.&lt;/p&gt;

&lt;p&gt;For example, if a document includes the content of an external LaTeX file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@elem[#:style "input"]{inline-this.tex}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then make sure to build the document with a command like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ raco scribble ++style style.tex ++extra inline-this.tex FILE.scrbl&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="inline-thistex"&gt;&lt;code&gt;inline-this.tex&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;% Raw LaTeX allowed here
$\lambda x.\, x$&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="q-what-about-in-line-latex"&gt;Q. What about in-line LaTeX?&lt;/h3&gt;

&lt;p&gt;An &lt;a href="https://docs.racket-lang.org/scribble/core.html#%28def._%28%28lib._scribble%2Fcore..rkt%29._element%29%29"&gt;element&lt;/a&gt;  with the &lt;a href="https://docs.racket-lang.org/scribble/core.html#%28idx._%28gentag._60._%28lib._scribblings%2Fscribble%2Fscribble..scrbl%29%29%29"&gt;&lt;code&gt;'exact-chars&lt;/code&gt;&lt;/a&gt;  &lt;a href="https://docs.racket-lang.org/scribble/core.html#%28tech._style._property%29"&gt;style property&lt;/a&gt;  renders directly to LaTeX.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@(define (exact . stuff)
   @; the style name "relax" puts a `\relax` no-op in front of the stuff
   (make-element (make-style "relax" '(exact-chars)) stuff))

@exact|{$\lambda x.\, x$}|
@; ==&amp;gt; \relax{$\lambda x.\, x$}

@(define ($ . math-stuff)
   (apply exact (list "$" math-stuff "$")))

@${\lambda x.\, x}
@; ==&amp;gt; \relax{$\lambda x.\, x$}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="creating-a-httpdocsracket-langorgguidemodulesyntaxhtml28parthash-lang29lang-for-a-paper"&gt;Creating a &lt;a href="http://docs.racket-lang.org/guide/Module_Syntax.html#%28part._hash-lang%29"&gt;#lang&lt;/a&gt; for a paper&lt;/h2&gt;

&lt;p&gt;For a Scribble document that is split across multiple files, it can be helpful  to make a &lt;code&gt;#lang&lt;/code&gt; that &lt;a href="http://blog.racket-lang.org/2017/03/languages-as-dotfiles.html"&gt;provides a common environment&lt;/a&gt;. Instead of starting each file with a &lt;code&gt;require&lt;/code&gt;, e.g.:&lt;/p&gt;

&lt;h4 id="paperscrbl"&gt;&lt;code&gt;paper.scrbl&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#lang scribble/acmart
@require["references.rkt" "helper-functions.rkt" scriblib/figure]

....&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;files can start with a name that describes their common purpose:&lt;/p&gt;

&lt;h4 id="paperscrbl"&gt;&lt;code&gt;paper.scrbl&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#lang conference-2018-submission

....&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a bonus, if the language is defined as a package then the Scribble document  can use Racket&amp;rsquo;s dependency management tools:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# to install the paper and interactively install dependencies:
$ cd conference-2018-submission;
$ raco pkg install

# To check that the paper builds with no dependency issues:
$ raco setup --check-pkg-deps conference-2018-submission

# To run all unit tests
$ raco test -c conference-2018-submission&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To create a package and language:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;Move the Scribble document to a directory with the language name, i.e.,  &lt;code&gt;conference-2018-submission/&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;Write a simple &lt;code&gt;info.rkt&lt;/code&gt; to configure the package&lt;/li&gt;
 &lt;li&gt;Create a normal Racket module that exports the common environment&lt;/li&gt;
 &lt;li&gt;Create a &lt;code&gt;conference-2018-submission/lang/reader.rkt&lt;/code&gt; module&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Details below. For a full example, visit:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://gitlab.com/bennn/scribble-acmart-example"&gt;https://gitlab.com/bennn/scribble-acmart-example&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id="conference-2018-submissioninforkt"&gt;&lt;code&gt;conference-2018-submission/info.rkt&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;This file defines the basic metadata for a package. For more about &lt;code&gt;info.rkt&lt;/code&gt;, see: &lt;a href="http://blog.racket-lang.org/2017/10/tutorial-creating-a-package.html"&gt;Tutorial: Creating a Package&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#lang info
(define collection "conference-2018-submission")
(define deps '("base" "scribble-lib" "at-exp-lib"))
(define build-deps '("racket-doc" "scribble-doc"))
(define pkg-desc "Paper for Conference 2018")
(define version "0.1")&lt;/code&gt;&lt;/pre&gt;

&lt;br /&gt;

&lt;h4 id="conference-2018-submissionmainrkt"&gt;&lt;code&gt;conference-2018-submission/main.rkt&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;This file defines and exports the common environment for every file in our  Scribble document. In this example, the common environment is:  the &lt;a href="http://docs.racket-lang.org/scribble/ACM_Paper_Format.html"&gt;scribble/acmart&lt;/a&gt; language,  the file &amp;ldquo;references.rkt&amp;rdquo;,  and the &lt;a href="http://docs.racket-lang.org/scriblib/figure.html#%28def._%28%28lib._scriblib%2Ffigure..rkt%29._figure%29%29"&gt;scriblib/figure&lt;/a&gt; library.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#lang racket/base

(provide
  (all-from-out
    scribble/acmart
    scribble/acmart/lang
    scriblib/figure
    "references.rkt"))

(require
  scribble/acmart
  scribble/acmart/lang
  scriblib/figure
  "references.rkt")&lt;/code&gt;&lt;/pre&gt;

&lt;br /&gt;

&lt;h4 id="conference-2018-submissionlangreaderrkt"&gt;&lt;code&gt;conference-2018-submission/lang/reader.rkt&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;This file:  (1) tells Racket to use the Scribble reader on &lt;code&gt;#lang conference-2018-submission&lt;/code&gt;  modules, and (2) wraps the result of such modules in a shape that Scribble  expects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#lang s-exp scribble/base/reader
conference-2018-submission
#:wrapper1 (lambda (t) (cons 'doc (t)))&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="links-to-example-documents"&gt;Links to Example Documents&lt;/h2&gt;

&lt;p&gt;These documents use the &lt;code&gt;#lang&lt;/code&gt; approach to writing a paper with Scribble. Check their &lt;code&gt;main.rkt&lt;/code&gt; for example formatting functions and unit tests,  and check the &lt;code&gt;.scrbl&lt;/code&gt; files to see how the ideas above look in a larger document.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/retic_performance/tree/master/gm-pepm-2018"&gt;https://github.com/nuprl/retic_performance/tree/master/gm-pepm-2018&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/tag-sound/tree/master/gf-icfp-2018"&gt;https://github.com/nuprl/tag-sound/tree/master/gf-icfp-2018&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Finally, this repository provides a tool to start a new Scribble document:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://pkgd.racket-lang.org/pkgn/package/gtp-paper"&gt;https://pkgd.racket-lang.org/pkgn/package/gtp-paper&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="further-reading"&gt;Further Reading&lt;/h2&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://project.inria.fr/coqexchange/checking-machine-checked-proofs/"&gt;Checking Machine-Checked Proofs&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</content></entry>
 <entry>
  <title type="text">On-Stack Replacement</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2019/01/28/on-stack-replacement/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2019-01-28-on-stack-replacement</id>
  <published>2019-01-28T10:29:57Z</published>
  <updated>2019-01-28T10:29:57Z</updated>
  <author>
   <name>Ming-Ho Yee</name></author>
  <content type="html">
&lt;p&gt;Last semester, I took &lt;a href="https://course.ccs.neu.edu/cs7600/"&gt;a course&lt;/a&gt; where the final project was to write a survey paper on &amp;ldquo;a topic in the intersection between computer systems and your area.&amp;rdquo; So I wrote about on-stack replacement.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;&lt;strong&gt;Abstract&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;On-stack replacement (OSR) is a programming language implementation technique that allows a running program to switch to a different version of code. For example, a program could start executing optimized code, and then transfer to and start executing unoptimized code. This was the original use case for OSR, to facilitate debugging of optimized code.&lt;/p&gt;
 &lt;p&gt;After its original use was established, OSR shifted to a different use case: optimizing programs. OSR allows the run-time system to detect if a program is executing an inefficient loop, recompile and optimize the method that contains the loop, and then transfer control to the newly compiled method. Another strategy is to optimize code based on some assumptions, then, if the assumptions are invalidated at run-time, transfer control back to the original, unoptimized code.&lt;/p&gt;
 &lt;p&gt;In this survey paper, we study how OSR was first introduced as a means for debugging, how it came to be used for program optimizations, its implementation as a reusable library, and other directions of research.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If you&amp;rsquo;re interested, you can find a copy &lt;a href="/img/cs7600-mhyee-survey-paper-osr.pdf"&gt;here&lt;/a&gt; or on &lt;a href="https://www.overleaf.com/read/smcmsnksxfdk"&gt;Overleaf&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;If you liked this post, you may also be interested in &lt;a href="http://prl.ccs.neu.edu/blog/2017/03/15/tracing-jits-for-dynamic-languages/"&gt;tracing JITs for dynamic languages&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">The Behavior of Gradual Types: A User Study</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2018/12/11/the-behavior-of-gradual-types-a-user-study/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2018-12-11-the-behavior-of-gradual-types-a-user-study</id>
  <published>2018-12-11T19:50:33Z</published>
  <updated>2018-12-11T19:50:33Z</updated>
  <author>
   <name>Ben Greenman</name></author>
  <content type="html">&lt;!-- more--&gt;

&lt;blockquote&gt;
 &lt;p&gt;Note: this post is an extended abstract for the paper &lt;em&gt;The Behavior of Gradual Types: A User Study&lt;/em&gt; by Preston Tunnell&amp;mdash;Wilson, Ben Greenman, Justin Pombrio, and Shriram Krishnamurthi. For the full paper, datasets, and slides, &lt;a href="http://www.ccs.neu.edu/home/types/publications/publications.html#tgpk-dls-2018"&gt;click here&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The long-term goal of gradual typing is to build languages that offer the  &amp;ldquo;best&amp;rdquo; of both static and dynamic typing. Researchers disagree, however, on what the semantics of a mixed-typed language  should be; there are &lt;a href="/blog/2018/10/06/a-spectrum-of-type-soundness-and-performance/"&gt;at least three competing proposals&lt;/a&gt;  for combining a dynamically-typed language with a similar statically-typed language.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;It&amp;rsquo;s an interesting situation. There are dozens of papers on the semantics of gradual types&amp;mdash;and &lt;a href="http://www.ccs.neu.edu/home/types/resources/talks/tgpk-dls-2018.pdf"&gt;many claim&lt;/a&gt; to have developers in mind&amp;mdash;but zero papers that ask developers what they think.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;To help inform the discussion, we recently designed a &lt;a href="http://cs.brown.edu/research/plt/dl/dls2018"&gt;survey&lt;/a&gt;  to see what programmers think of three mixed-typed semantics. The survey is based on 8 example programs; we selected these 8 programs because the set as a whole tells the three mixed-typed semantics apart. For each program, the survey presents a few possible outcomes of running the  program and asks participants for their opinion on each outcome.&lt;/p&gt;

&lt;p&gt;The image below shows one program from the survey:&lt;/p&gt;

&lt;p&gt; &lt;img src="/img/gtsurvey-example-program.png" alt="Figure 1: example program" /&gt;&lt;/p&gt;

&lt;p&gt;This program creates an array, passes it between typed and untyped variables,  and performs write &amp;amp; read operations. What should happen when we run this program? One option is to ignore the type annotations and return the second element  of the array (&lt;code&gt;"bye"&lt;/code&gt;). A second option is to reject the write operation (on line 4) because it attempts  to write a number to a variable of type &lt;code&gt;Array(String)&lt;/code&gt;. A third option is to reject the assignment after the read operation (on line 5)  because it attempts to assign a string to a variable of type &lt;code&gt;Number&lt;/code&gt;. These are the three behaviors in the survey:&lt;/p&gt;

&lt;p&gt; &lt;img src="/img/gtsurvey-example-behaviors.png" alt="Figure 2: behaviors for the example question" /&gt;&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;A fourth option is to reject the assignment of an &lt;code&gt;Array(String)&lt;/code&gt; to a variable of type &lt;code&gt;Array(Number)&lt;/code&gt;. A few participants left comments asking for this behavior. See the &lt;a href="http://cs.brown.edu/research/plt/dl/dls2018"&gt;anonymized responses&lt;/a&gt; for their comments, and see &lt;a href="http://cs.brown.edu/~sk/Publications/Papers/Published/tgpk-beh-grad-types-user-study"&gt;the paper&lt;/a&gt; for why we left that behavior out.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For each behavior, we asked for respondents&amp;rsquo; preference along two independent dimensions:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Do you &lt;em&gt;like&lt;/em&gt; or &lt;em&gt;dislike&lt;/em&gt; this behavior?&lt;/li&gt;
 &lt;li&gt;Does it match your &lt;em&gt;expectation&lt;/em&gt; as a programmer?&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Combined, the dimensions lead to four possible &lt;em&gt;attitudes&lt;/em&gt;: Like and Expected,  Like and Unexpected, Dislike and Expected, Dislike and Unexpected. The full example question, with attitudes and space for comments, is below.&lt;/p&gt;

&lt;p&gt; &lt;img src="/img/gtsurvey-example-question.png" alt="Figure 3: complete question" /&gt;&lt;/p&gt;

&lt;p&gt;We administered the survey to three populations &amp;mdash; software engineers,  students, and Mechanical Turk workers &amp;mdash; and thereby collected three sets of  attitudes for each question. The results for the running example are below:&lt;/p&gt;

&lt;p&gt; &lt;img src="/img/gtsurvey-example-data.png" alt="Figure 4: results for Question 7" /&gt;&lt;/p&gt;

&lt;p&gt;The figure is a matrix of three columns (one for each population)  and three rows (one for each behavior). Each cell of the matrix contains a bar chart showing the attitudes  that we collected.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Unlike the survey question, the behaviors in the results are labeled as &lt;strong&gt;Deep&lt;/strong&gt;, &lt;strong&gt;Erasure&lt;/strong&gt;, and &lt;strong&gt;Shallow&lt;/strong&gt;. These names describe the three mixed-typed semantics.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For this question, the software engineers (left column, green bars)  mostly picked the &amp;ldquo;Dislike and Unexpected&amp;rdquo; attitude for every behavior. The students (mid column, blue bars) also show consensus on &amp;ldquo;Dislike and  Unexpected&amp;rdquo; for the &lt;strong&gt;Deep&lt;/strong&gt; and &lt;strong&gt;Erasure&lt;/strong&gt; behaviors; however, they are split  for the &lt;strong&gt;Shallow&lt;/strong&gt; behavior. The Mechanical Turk workers are divided on every behavior.&lt;/p&gt;

&lt;p&gt;See &lt;a href="http://cs.brown.edu/~sk/Publications/Papers/Published/tgpk-beh-grad-types-user-study"&gt;the paper&lt;/a&gt; for the other questions and responses.&lt;/p&gt;

&lt;p&gt;Overall, our main finding is that respondents preferred behaviors that enforced  full types and reported runtime mismatches as early as possible. The takeaway is thus:&lt;/p&gt;

&lt;p style="margin-left: 40px; margin-right: 40px"&gt;if you are designing a mixed-typed language and choose &lt;strong&gt;not&lt;/strong&gt; to enforce full types, then make sure to explain this behavior to users!&lt;/p&gt;

&lt;p&gt;Put lots of example programs in the language&amp;rsquo;s documentation. The programs in the survey can be adapted to explain how your chosen  behavior differs from alternatives.&lt;/p&gt;

&lt;h2 id="questions"&gt;Questions&lt;/h2&gt;

&lt;p&gt;Here are some good questions we&amp;rsquo;ve gotten that are not clearly answered in the paper.&lt;/p&gt;

&lt;h4 id="q-did-any-respondents-expect-more-than-one-behavior"&gt;Q. Did any respondents &amp;ldquo;expect&amp;rdquo; more than one behavior?&lt;/h4&gt;

&lt;p&gt;Yes, 59% &lt;!-- 20/34--&gt; of the software engineers and 82% &lt;!-- 14/17--&gt; of the students selected &amp;ldquo;Liked and Expected&amp;rdquo; and/or &amp;ldquo;Dislike and Expected&amp;rdquo; for different behaviors on the same program.&lt;/p&gt;
&lt;!-- They probably interpreted "Expected" as--&gt;
&lt;!--  "the program does something that makes sense", rather than--&gt;
&lt;!--  "the program does the one thing that I believe it should do".--&gt;
&lt;!-- ids for "double-expect" S.Es : R_24bz47lgcAOkCux R_2R4dZ1l0t3yx6fW R_b7yMVe7VtmmsrHb R_31MXSUfCyDE8FdG R_6LGXyOirYNtYWd3 R_2qyMZBAs74PrsSz R_2ASFRBh2jfuRgP1 R_1PUc0AUEzdXKGt8 R_2dL60N9oPIkbvWY R_1BXXqYyxH7R4r9l R_1ON2sxGalcODyAd R_1oyZasBudU5gKPS R_1FIHgkQbWGaxuHd R_b1s2YMBWCrCRvxf R_29t0zWxkQsfb9FT R_2fevZOrFGzS6JLf R_8Dn6NMjDyigT59n R_2pRG370z3cBUaKv R_2qDXTFI53ntWMu4 R_ZI8AwATueqyWwOR--&gt;
&lt;!-- ids for "double-expect" students : R_9B6WHWEX5l0DskN R_22VAu37cGWQPQx1 R_3hgYSaGy2tbyY3G R_3rTbAqgn1rhQK4d R_r3HqAP1yGRXHaZX R_1l05qvQ1sYOCcCF R_3qaMT9xR7CRYg2Y R_1Li0sGHkxk1VfcA R_24ITtgvBzg9RpE3 R_3HzshHbDWkayp4t R_5mtEFLtSX0iPVOp R_1IR6vdpmVw4OCqV R_2XpWlkKjH9LQqln R_DoQrROe0dcb1YJz--&gt;

&lt;h4 id="q-did-the-respondents-have-a-prior-preference-for-static-or-dynamic-typing"&gt;Q. Did the respondents have a prior preference for static or dynamic typing?&lt;/h4&gt;

&lt;p&gt;Near the end of the survey we asked: &amp;ldquo;Which do you prefer, typed or untyped programming?&amp;rdquo;. See table 2 of &lt;a href="http://cs.brown.edu/~sk/Publications/Papers/Published/tgpk-beh-grad-types-user-study"&gt;the paper&lt;/a&gt; for coded responses to this question,  or the &lt;a href="http://cs.brown.edu/research/plt/dl/dls2018"&gt;anonymized responses&lt;/a&gt; for the ground truth. Most preferred typed programming.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Java and Migratory Typing</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2018/12/02/java-and-migratory-typing/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2018-12-02-java-and-migratory-typing</id>
  <published>2018-12-02T14:41:53Z</published>
  <updated>2018-12-02T14:41:53Z</updated>
  <author>
   <name>Ben Greenman</name></author>
  <content type="html">
&lt;p&gt;The &lt;em&gt;transient&lt;/em&gt; approach to migratory typing (circa &lt;a href="http://homes.sice.indiana.edu/mvitouse/papers/dls14.pdf"&gt;2014&lt;/a&gt;)  is similar to type erasure in Java (circa &lt;a href="https://docs.oracle.com/javase/1.5.0/docs/relnotes/features.html"&gt;2004&lt;/a&gt;)  in a few interesting ways.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h2 id="migratory-typing"&gt;Migratory typing&lt;/h2&gt;

&lt;p&gt;The goal of &lt;em&gt;migratory typing&lt;/em&gt; is to enrich the type system of a language  without breaking backwards compatibility. Ideally, code that uses the enriched types:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;(G1) benefits from new ahead-of-time checks,&lt;/li&gt;
 &lt;li&gt;(G2) benefits from stronger run-time guarantees, and&lt;/li&gt;
 &lt;li&gt;(G3) may interact with all kinds of existing code.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;There are tradeoffs involved in the implementation of a migratory typing  system, however, and (as we will see) different implementations may focus on  different goals than the three above.&lt;/p&gt;

&lt;p&gt;A typical migratory typing system adds a static type checker to a dynamically  typed language (&lt;a href="/blog/2018/10/06/a-spectrum-of-type-soundness-and-performance/index.html"&gt;examples&lt;/a&gt;),  but one could also extend the type system of a statically-typed language;  for example, by &lt;a href="https://hal.inria.fr/hal-01629909v2"&gt;adding dependent types&lt;/a&gt;. In this sense, Java 1.5.0 is a migratory typing system for pre-generics Java. The addition of generic types enabled new ahead-of-time checks and maintained backwards  compatibility with existing Java code.&lt;/p&gt;

&lt;p&gt;Java&amp;rsquo;s implementation of migratory typing has some interesting things in common  with the &lt;em&gt;transient&lt;/em&gt; implementation strategy recently proposed by  Michael Vitousek and collaborators (&lt;a href="http://homes.sice.indiana.edu/mvitouse/papers/dls14.pdf"&gt;DLS&amp;rsquo;14&lt;/a&gt;, &lt;a href="https://mail.google.com/mail/u/0/h/1atrn21qlyrrh/?&amp;amp;"&gt;POPL&amp;rsquo;17&lt;/a&gt;). The goal of this post is to demonstrate the connections.&lt;/p&gt;

&lt;h2 id="erasure-migratory-typing"&gt;Erasure migratory typing&lt;/h2&gt;

&lt;p&gt;Before we compare Java 1.5.0 to transient, let&amp;rsquo;s review a simpler strategy:  the &lt;em&gt;erasure&lt;/em&gt; approach to migratory typing.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://www.typescriptlang.org/"&gt;TypeScript&lt;/a&gt; is a great (modern) example of the erasure approach. TypeScript is a migratory typing system for JavaScript. A TypeScript module gets validated by an ahead-of-time type checker and  compiles to JavaScript. After compilation, any JavaScript program may import bindings  from the generated code. Conversely, a TypeScript module may import bindings from a JavaScript module  by declaring a static type for each binding.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;The &lt;a href="http://definitelytyped.org/"&gt;DefinitelyTyped&lt;/a&gt; repository provides TypeScript type definitions for many JavaScript libraries.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The TypeScript compiler erases types;  every type &lt;code&gt;T&lt;/code&gt; in the source code translates to the universal &amp;ldquo;JavaScript type&amp;rdquo;. For instance, a TypeScript function declaration compiles to an untyped  JavaScript function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function (n0 : number, n1 : number) { return n0 + n1; })

// ==(compiles to)==&amp;gt;

(function (n0, n1) { return n0 + n1; })&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TypeScript satisfies goals &lt;strong&gt;G1&lt;/strong&gt; and &lt;strong&gt;G3&lt;/strong&gt; for a migratory typing system  because its type checker adds ahead-of-time checks and its  compiler outputs JavaScript. TypeScript does not satisfy goal &lt;strong&gt;G2&lt;/strong&gt; because the compiler erases types. In terms of the example above, the compiled function may be invoked with any  pair of JavaScript values; the variable &lt;code&gt;n0&lt;/code&gt; is not guaranteed to point  to a &lt;code&gt;number&lt;/code&gt; at run-time. On one hand, this means the type annotations have no effect on the behavior  of a program &amp;mdash; and in particular, cannot be trusted for debugging. On the other hand, it means that an experienced JavaScript programmer can  re-use their knowledge to predict the behavior of a TypeScript program.&lt;/p&gt;

&lt;p&gt;In an ordinary program, the run-time guarantees of TypeScript are simply  the run-time guarantees of JavaScript:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;if a TypeScript expression &lt;code&gt;e&lt;/code&gt; has the static type &lt;code&gt;T&lt;/code&gt; and evaluates to  a value &lt;code&gt;v&lt;/code&gt;,  then the only guarantee is that &lt;code&gt;v&lt;/code&gt; is a valid JavaScript value  (e.g., &lt;code&gt;T&lt;/code&gt; could be &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; could be an incompatible object).&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="transient-migratory-typing"&gt;Transient migratory typing&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/mvitousek/reticulated"&gt;Reticulated&lt;/a&gt; is a migratory typing  system for Python that follows a &lt;em&gt;transient&lt;/em&gt; implementation strategy. A Reticulated module gets type-checked and compiles to a Python module that  defends itself from certain type-invalid inputs through the use of  assertions that run in near-constant time. The type-checking addresses goal &lt;strong&gt;G1&lt;/strong&gt;,  the compilation to Python provides interoperability (goal &lt;strong&gt;G3&lt;/strong&gt;),  and the assertions partially meet goal &lt;strong&gt;G2&lt;/strong&gt;.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;These &lt;em&gt;certain&lt;/em&gt; inputs are the ones that would cause a standard typed operational semantics to reach an undefined state. For a discussion of &lt;em&gt;near-constant&lt;/em&gt;, see &lt;a href="http://www.ccs.neu.edu/home/types/publications/publications.html#gm-pepm-2018"&gt;&lt;em&gt;On the Cost of Type-Tag Soundness&lt;/em&gt;, section 2&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For example, here is a Reticulated function  that computes the average of a list of numbers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Reticulated (commit e478343)
def average(nums : List(Float)) -&amp;gt; Float:
  if ns:
    return sum(ns) / len(ns)
  else:
    raise ValueError("average: expected non-empty list")&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and here is the Python code it compiles to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from retic.runtime import *
from retic.transient import *
from retic.typing import *

def average(nums):
    check_type_list(nums)
    if ns:
        return check_type_float((check_type_function(sum)(ns) / check_type_function(len)(ns)))
    else:
        raise check_type_function(ValueError)('average: expected non-empty list')&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
 &lt;p&gt;Note: the Reticulated syntax for type annotations is similar to the one proposed in &lt;a href="https://www.python.org/dev/peps/pep-0484/"&gt;PEP 484&lt;/a&gt;, but not identical. For example, Reticulated does not require forward references to be embedded in strings.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The Reticulated compiler removes all type annotations and inserts &lt;code&gt;check_type&lt;/code&gt;  assertions throughout the code. In &lt;code&gt;average&lt;/code&gt;, these assertions check that: (1) the input is a list,  (2) the output is a &lt;code&gt;float&lt;/code&gt;, (3) and the names &lt;code&gt;sum&lt;/code&gt; &lt;code&gt;len&lt;/code&gt; and  &lt;code&gt;ValueError&lt;/code&gt; point to callable values. That&amp;rsquo;s all. The assertions &lt;strong&gt;do not check&lt;/strong&gt; that &lt;code&gt;nums&lt;/code&gt; contains only floating-point  numbers.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;The assertions also do not check that the function bound to &lt;code&gt;sum&lt;/code&gt; is defined for a single argument, which is arguably a bug. Scaling a model to an implementation is always challenging.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If &lt;code&gt;nums&lt;/code&gt; contains something other than floating point numbers, then the  call to &lt;code&gt;average&lt;/code&gt; may cause &lt;code&gt;sum&lt;/code&gt; to raise an exception or it may silently  compute a nonsense result. The behavior depends on the implementation of &lt;code&gt;sum&lt;/code&gt; in the same way that  the behavior of a TypeScript function depends on any JavaScript functions  that it invokes.&lt;/p&gt;

&lt;p&gt;Reticulated does not erase types, nor does it fully enforce types. Every type in a Reticulated module translates to its  top-level type constructor &lt;code&gt;C(T)&lt;/code&gt;, e.g.:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  C(Float)                = Float
  C(List(Float))          = List
  C(List(Float) -&amp;gt; Float) = -&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Consequently, Reticulated has a slightly stronger run-time guarantee than Python:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;if &lt;code&gt;e&lt;/code&gt; is an expression with static type &lt;code&gt;T&lt;/code&gt; that evaluates to a value &lt;code&gt;v&lt;/code&gt;,  then &lt;code&gt;v&lt;/code&gt; is guaranteed to have a top-level shape that matches the &lt;code&gt;C(T)&lt;/code&gt;  constructor.&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="java-migratory-typing"&gt;Java migratory typing&lt;/h2&gt;

&lt;p&gt;Java 1.5.0 added &lt;a href="https://www.jcp.org/en/jsr/detail?id=14"&gt;generic types&lt;/a&gt;  to the Java 1.4.0 type system. The benefit of generics is that a programmer can:  write one class definition,  use the definition in a few different contexts,  and receive specific feedback from the type checker in each context.&lt;/p&gt;

&lt;h3 id="review-generic-types"&gt;Review: generic types&lt;/h3&gt;

&lt;p&gt;Suppose we want to write a &lt;code&gt;Box&lt;/code&gt; class that holds some kind of value;  the value could be an &lt;code&gt;Integer&lt;/code&gt; or a &lt;code&gt;String&lt;/code&gt; or anything else. Here is a pre-generics definition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Box {
  private Object val;

  public Box(Object val) { this.set(val); }

  public void set(Object val) { this.val = val; }

  public Object get() { return this.val; }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this definition is it possible to make boxes that hold different types  of values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// good!
Box iBox = new Box(new Integer(4));
Box sBox = new Box(new String("X"));&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but it is also possible to &amp;ldquo;change the type&amp;rdquo; of the contents of a &lt;code&gt;Box&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// maybe bad!
iBox.set(new String("not a number"));&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and some calls to &lt;code&gt;get&lt;/code&gt; must be followed by a type cast:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// annoying!
((String) sBox.get()).charAt(0);&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;With generics, we can give a name (e.g. &lt;code&gt;ValType&lt;/code&gt;) to &amp;ldquo;the type of the value inside a box&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class GBox&amp;lt;ValType&amp;gt; {
  private ValType val;

  public GBox(ValType val) { this.set(val); }

  public void set(ValType val) { this.val = val; }

  public ValType get() { return this.val; }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and now we can tell the type checker to check different boxes differently (satisfying goal &lt;strong&gt;G1&lt;/strong&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GBox&amp;lt;Integer&amp;gt; iBox = new GBox&amp;lt;Integer&amp;gt;(new Integer(0));
GBox&amp;lt;String&amp;gt; sBox = new GBox&amp;lt;String&amp;gt;(new String("A"));

// iBox.set(new String("not a number")); // Type Error, good!

sBox.get().charAt(0); // no cast, good!&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="backwards-compatibility--danger"&gt;Backwards compatibility &amp;amp; danger&lt;/h3&gt;

&lt;p&gt;Java generics are backwards-compatible with older code (goal &lt;strong&gt;G3&lt;/strong&gt;). This means that pre-generics code can interact with instances of a generic  class. Vice-versa, generic code can interact with pre-generics classes. Since pre-generics code is not aware of type parameters, these interactions  are potentially unsafe. For example, a pre-generics method can change the type of a &lt;code&gt;GBox&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Java 1.4.0 method
public static void evil(GBox b) { b.set(666); }

// Java 1.5.0 method
public static void test() {
  GBox&amp;lt;String&amp;gt; sBox = new GBox&amp;lt;String&amp;gt;(new String("A"));
  evil(sBox); // OK, but generates unchecked warning
  sBox.get().charAt(0);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above passes the type checker (with a warning about the &lt;code&gt;evil&lt;/code&gt; method),  and so it &lt;em&gt;seems&lt;/em&gt; as though running the code will run the nonsense  method call &lt;code&gt;666.charAt(0)&lt;/code&gt; and lead to evil behavior. The actual result, however, is a cast error immediately after the call  &lt;code&gt;sBox.get()&lt;/code&gt; returns.&lt;/p&gt;

&lt;p&gt;Based on the cast error, we can tell that  the compiler does not trust the type &lt;code&gt;GBox&amp;lt;String&amp;gt;&lt;/code&gt; and  inserts a run-time check that the result of the &lt;code&gt;.get()&lt;/code&gt; is a string object.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&amp;ldquo;Calling legacy code from generic code is inherently dangerous; once you mix generic code with non-generic legacy code, all the safety guarantees that the generic type system usually provides are void.&amp;rdquo; &lt;a href="https://www.oracle.com/technetwork/java/javase/generics-tutorial-159168.pdf"&gt;Generics in the Java Programming Language, Section 6.1&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3 id="java-type-erasure"&gt;Java Type Erasure&lt;/h3&gt;

&lt;p&gt;In order to support pre-generics and post-generics code on the same  &lt;a href="https://docs.oracle.com/javase/specs/jvms/se11/html/index.html"&gt;virtual machine&lt;/a&gt;,  the Java compiler &lt;a href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.6"&gt;erases&lt;/a&gt;  generic type parameters after type-checking. Everywhere that the compiled code depends on an erased type, such as the  &lt;code&gt;String&lt;/code&gt; in &lt;code&gt;GBox&amp;lt;String&amp;gt;&lt;/code&gt; above, Java adds a cast to prove to the Java Virtual Machine (JVM)  that the erased bytecode is type-safe. (A smarter JVM type system might be able to prove that some casts are  unnecessary via &lt;a href="https://www2.ccs.neu.edu/racket/pubs/icfp10-thf.pdf"&gt;occurrence typing&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;After erasure, the &lt;code&gt;GBox&amp;lt;ValType&amp;gt;&lt;/code&gt; class declaration loses its parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Erase `ValType`, replace with `Object`
class GBox {
  private Object val;

  public GBox(Object val) { this.set(val); }

  public void set(Object val) { this.val = val; }

  public Object get() { return this.val; }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the client code gains a cast:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GBox sBox = new GBox(new String("A"));

((String) sBox.get()).charAt(0);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, so good. But it&amp;rsquo;s worth noting that erasure can cause problems with Java arrays. An array needs to know the run-time type of its elements, so the following &amp;ldquo;natural&amp;rdquo; definition of an &lt;code&gt;ArrayList&lt;/code&gt; is not permitted:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class ArrayList&amp;lt;T&amp;gt; {
  private T[] data;
  private int size;

  public ArrayList(int capacity) {
    data = new T[capacity];
    size = 0;
  }

  public T get(int ix) {
    // TODO bounds check
    return data[ix]
  }

  // ....
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The trouble is that &lt;code&gt;T&lt;/code&gt; does not say anything about the data that a new array needs to handle:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ArrayList.java:6: error: generic array creation
    data = new T[capacity];&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only work-arounds require an array of objects and unchecked casts. One solution is to unsafely cast the array to the generic type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  // possibly dangerous, if `data` is aliased to an `Object[]`
  public ArrayList(int capacity) {
    data = (T[]) new Object[capacity];
    size = 0;
  }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The other is to unsafely cast array elements in the &lt;code&gt;get&lt;/code&gt; method, and elsewhere:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class ArrayList&amp;lt;T&amp;gt; {
  private Object[] data;
  private int size;

  public ArrayList(int capacity) {
    data = new Object[capacity];
    size = 0;
  }

  public T get(int ix) {
    boundsCheck(ix);
    return (T) data[ix];
  }

  // ....
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both may potentially lead to &lt;a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/TechnicalDetails.html#FAQ050"&gt;heap pollution&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;"The decision not to make all generic types [not erased] is one of the most crucial, and controversial design decisions involving the type system of the Java programming language.&lt;/p&gt;
 &lt;p&gt;"Ultimately, the most important motivation for this decision is compatibility with existing code." &lt;a href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.7"&gt;Java Language Specification, section 4.7&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3 id="run-time-guarantees"&gt;Run-time guarantees&lt;/h3&gt;

&lt;p&gt;By contrast to Reticulated&amp;rsquo;s &lt;code&gt;C(T)&lt;/code&gt; transformation, the following &lt;code&gt;G(T)&lt;/code&gt;  transformation describes generic-type erasure,  where &lt;code&gt;T&amp;lt;T1&amp;gt;&lt;/code&gt; describes a type &lt;code&gt;T&lt;/code&gt; with parameter &lt;code&gt;T1&lt;/code&gt;  and &lt;code&gt;A[T1, T2]&lt;/code&gt; describes a type variable &lt;code&gt;A&lt;/code&gt; with lower bound &lt;code&gt;T1&lt;/code&gt; and upper bound &lt;code&gt;T2&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  G(T&amp;lt;T1&amp;gt;)     = G(T)
  G(A[T1, T2]) = G(T1)
  G(T)         = T      otherwise&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If generic-type erasure results in a type mismatch (e.g., in &lt;code&gt;sBox.get().charAt(0)&lt;/code&gt; above),  the compiler inserts a cast. The inserted casts led to the run-time error in the previous example, and  provide the following run-time guarantee:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;if &lt;code&gt;e&lt;/code&gt; is an expression with static type &lt;code&gt;T&lt;/code&gt; that evaluates to a value &lt;code&gt;v&lt;/code&gt;,  then &lt;code&gt;v&lt;/code&gt; is guaranteed to match the (bytecode) type &lt;code&gt;G(T)&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="discussion"&gt;Discussion&lt;/h2&gt;

&lt;p&gt;TypeScript, Reticulated Python, and Java 1.5.0 each improved the type system  of an existing language, but maintained backwards compatibility with existing  code. The name &lt;a href="http://drops.dagstuhl.de/opus/volltexte/2017/7120/"&gt;migratory typing&lt;/a&gt;  describes this kind of language extension.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;a href="http://drops.dagstuhl.de/opus/volltexte/2015/5031/"&gt;Gradual typing&lt;/a&gt; is a similar; a gradual type system starts with a statically-typed language and adds dynamic typing in a principled way (&lt;a href="https://pleiad.cl/papers/2016/garciaAl-popl2016.pdf"&gt;example&lt;/a&gt;).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The TypeScript team had a choice between erasing types and enforcing types. They chose to erase types and run all code (typed or untyped) at the level  of JavaScript. (Some TypeScript &lt;a href="https://lorefnon.tech/2018/03/25/typescript-and-validations-at-runtime-boundaries/"&gt;libraries&lt;/a&gt;, however, can enforce some types.)&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;TypeScript is not the only erasure language, nor is it the first. The oldest (I think) is &lt;a href="http://www.softwarepreservation.org/projects/LISP/maclisp_family/"&gt;MACLISP&lt;/a&gt;. For an erasure manifesto, see &lt;a href="http://bracha.org/pluggableTypesPosition.pdf"&gt;Pluggable Type Systems&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The Reticulated team faced an analogous choice, and chose to enforce the top-level  shape of values in typed code (&lt;a href="http://homes.sice.indiana.edu/mvitouse/papers/popl17.pdf"&gt;POPL 2017&lt;/a&gt;). It will be interesting to see if this guarantee helps developers maintain programs,  or if it is too shallow to be much use. The &lt;a href="https://www.pyret.org/index.html"&gt;Pyret&lt;/a&gt; language has been successful with  comparable shallow checks.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Note: the POPL 2017 paper advertises an &amp;ldquo;open-world soundness&amp;rdquo;, but I do not see how this idea is different from the older idea of soundness in a multi-language system (&lt;a href="https://www.eecs.northwestern.edu/~robby/pubs/papers/toplas09-mf.pdf"&gt;TOPLAS 2009&lt;/a&gt;, &lt;a href="https://www2.ccs.neu.edu/racket/pubs/dls06-tf.pdf"&gt;DLS 2006&lt;/a&gt;).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Similarly, the Java team chose to erase generic types in Java 1.5.0 and use shallow casts in the JVM. The casts around type-erased generics provide a minimal level of safety &amp;mdash;  enough to prevent the use of a generic object from corrupting the state of a  VM instance.&lt;/p&gt;

&lt;p&gt;Alternatively, Java could enforce full generic types at run-time. Over the years there have been a few proposals to do so (&lt;a href="http://gafter.blogspot.com/2006/11/reified-generics-for-java.html"&gt;example 1&lt;/a&gt;,  &lt;a href="https://wiki.openjdk.java.net/display/valhalla/Main"&gt;example 2&lt;/a&gt;). The C# language has a similar type system and enforces  generics at run-time (sources:  &lt;a href="https://mattwarren.org/2018/03/02/How-generics-were-added-to-.NET/"&gt;blog post&lt;/a&gt;,  &lt;a href="https://www.microsoft.com/en-us/research/publication/design-and-implementation-of-generics-for-the-net-common-language-runtime/"&gt;PLDI 2001 paper&lt;/a&gt;,  &lt;a href="https://dl.acm.org/citation.cfm?doid=378795.378797"&gt;backup link to paper&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id="acknowledgments"&gt;Acknowledgments&lt;/h2&gt;

&lt;p&gt;Thank you to &lt;a href="https://github.com/rmculpepper"&gt;Ryan Culpepper&lt;/a&gt; and &lt;a href="http://users.eecs.northwestern.edu/~jesse/"&gt;Jesse Tov&lt;/a&gt; for noticing the similarity between  Java&amp;rsquo;s generic-type erasure and transient migratory typing. Jesse commented on an early version of this post, supplied new Java example code, and explained the trouble with generics and arrays.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Turnstile Mailing List</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2018/11/30/turnstile-mailing-list/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2018-11-30-turnstile-mailing-list</id>
  <published>2018-11-30T14:55:30Z</published>
  <updated>2018-11-30T14:55:30Z</updated>
  <author>
   <name>Stephen Chang</name></author>
  <content type="html">
&lt;p&gt;&lt;a href="https://docs.racket-lang.org/turnstile/The_Turnstile_Guide.html"&gt;Turnstile&lt;/a&gt; now has a mailing list: &lt;a href="https://groups.google.com/forum/#!forum/turnstile-users"&gt;https://groups.google.com/forum/#!forum/turnstile-users&lt;/a&gt;&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;There is also a &lt;code&gt;#turnstile&lt;/code&gt; channel on &lt;a href="https://racket.slack.com"&gt;the Racket Slack&lt;/a&gt;.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Disappearing Code</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2018/11/24/disappearing-code/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2018-11-24-disappearing-code</id>
  <published>2018-11-24T09:52:58Z</published>
  <updated>2018-11-24T09:52:58Z</updated>
  <author>
   <name>Ben Greenman</name></author>
  <content type="html">
&lt;p&gt;Two experiences at &lt;a href="https://2018.splashcon.org/home"&gt;SPLASH 2018&lt;/a&gt; reminded me that software gets thrown away and replaced.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h3 id="story-1"&gt;Story 1&lt;/h3&gt;

&lt;p&gt;The first reminder came near the end of a &lt;a href="https://conf.researchr.org/event/sle-2018/papers-a-new-approach-for-software-correctness-and-reliability"&gt;talk&lt;/a&gt; by  &lt;a href="https://people.csail.mit.edu/rinard/"&gt;Martin Rinard&lt;/a&gt;. Once upon a time, Martin was working as a consultant and a firm asked him to  review a software package. (The firm wanted a second opinion about how the software computed its results.) The firm sent a zipfile; Martin found six versions of the code inside; the  firm said &amp;ldquo;well, please check all six versions&amp;rdquo;; and it turned out:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;strong&gt;Version 1&lt;/strong&gt; : the source code was written in a domain-specific language  (DSL) that generated code for the application&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Version 2&lt;/strong&gt; : the DSL source was the same as version 1, but the generated  code was slightly modified&lt;/li&gt;
 &lt;li&gt;&amp;hellip;&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Version 6&lt;/strong&gt; : the generated code was the source code and the DSL was gone&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The moral of Martin&amp;rsquo;s story was:   (1) the creators of a software system are often different from the maintainers,  and (2) researchers need to build tools to help these maintainers.&lt;/p&gt;

&lt;h3 id="story-2"&gt;Story 2&lt;/h3&gt;

&lt;p&gt;The second reminder came from a teaching assistant who said the  &lt;a href="https://www.cs.cornell.edu/courses/cs3110/2018fa/"&gt;functional programming course&lt;/a&gt;  at their institution was currently using a Python script  to test students&amp;rsquo; code. Once upon a time, I was a teaching assistant for the  &lt;a href="https://www.cs.cornell.edu/courses/cs3110/2014sp/"&gt;same course&lt;/a&gt; at the same  institution. We had trouble testing students&amp;rsquo; code via the Python script  left by the pre&amp;ndash;2013 course staff, so I wrote a  &lt;a href="https://gitlab.com/bengreenman/ocaml_tools/"&gt;command-line tool&lt;/a&gt; to handle the tests and other  compile/run/grade tasks. To keep history from repeating itself, I used the same language the course  teaches (OCaml) and wrote some documentation &amp;mdash; but it seems like that was  not enough. At any rate, writing the tool was a good exercise.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;In the end, everybody must understand for himself.&lt;/em&gt; &amp;mdash; &lt;a href="https://dl.acm.org/citation.cfm?id=3731"&gt;Per Martin-Löf&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3 id="reflection"&gt;Reflection&lt;/h3&gt;

&lt;p&gt;In each story, the maintainers of a software system threw away some old  code to make their job easier in the short term. How can we stop this &amp;ldquo;re-inventing the wheel&amp;rdquo; from happening?&lt;/p&gt;

&lt;p&gt;Martin Rinard&amp;rsquo;s solution is to let maintenance programmers keep their current  habits, but provide tools to make the short-term, pragmatic solutions into a  more robust systems. Search for "&lt;a href="https://people.csail.mit.edu/rinard/paper/osdi04.pdf"&gt;failure-oblivious computing&lt;/a&gt;"  to learn more (this was the topic of his &lt;a href="https://conf.researchr.org/event/sle-2018/papers-a-new-approach-for-software-correctness-and-reliability"&gt;talk&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;In Story 1, the maintainers were able to avoid the DSL by modifying an  inherited blob of DSL-generated code. If the DSL did not generate code, history might have taken a different course;  it might be best to start with a language that offers tools for linguistic  re-use, and to build a DSL from these tools &amp;mdash; so there is no generated code. The Racket programming language is exploring this path. For a recent example, see the &lt;a href="https://www2.ccs.neu.edu/racket/pubs/icfp17-acf.pdf"&gt;video-lang paper&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The Story 2 test harness, however, was not generating code. Its maintainers discarded a &amp;ldquo;big&amp;rdquo; program written in a typed  functional language in favor of a script. Perhaps we need a language that allows mixing statically-typed and  dynamically-typed code (shouts out to  &lt;a href="https://www2.ccs.neu.edu/racket/pubs/icfp18-gf.pdf"&gt;my own research&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;The best solution is probably to start with a team and keep the culture alive. Always pair program!&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id="addendum-comment-from-mitch-wand"&gt;Addendum: comment from Mitch Wand&lt;/h4&gt;

&lt;blockquote&gt;
 &lt;p&gt;The best solution is probably to start with a team and keep the culture alive. Always pair program!&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ermm, this works better for sourdough bread than for people.&lt;/p&gt;

&lt;p&gt;Even in the not-so-real world of checking student solutions, there&amp;rsquo;s often no way of guaranteeing that one half of a pair will be around for the second round. They may be on co-op. Or the course will not be offered the next semster/year/etc. Or the course will change at the next offering (from OCaml to Python or from Racket to Java) so that large chunks of the infrastructure will have to be discarded or rewritten.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;real&amp;rdquo; solution is to write literate code (as we preached incessantly in PDP), so that the next reader will have at least some clue as about what you wrote. This just may be sufficient incentive to modify rather than rebuild from scratch.&lt;/p&gt;

&lt;p&gt;Ever the optimist, &amp;mdash;Mitch&lt;/p&gt;</content></entry></feed>