<?xml version="1.0" encoding="utf-8"?> 
<rss version="2.0">
 <channel>
  <title>PRL Blog: Posts tagged 'category theory'</title>
  <description>PRL Blog: Posts tagged 'category theory'</description>
  <link>http://prl.ccs.neu.edu/blog/tags/category-theory.html</link>
  <lastBuildDate>Wed, 27 Sep 2017 15:44:57 UT</lastBuildDate>
  <pubDate>Wed, 27 Sep 2017 15:44:57 UT</pubDate>
  <ttl>1800</ttl>
  <item>
   <title>Final Algebra Semantics is Observational Equivalence</title>
   <link>http://prl.ccs.neu.edu/blog/2017/09/27/final-algebra-semantics-is-observational-equivalence/?utm_source=category-theory&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-09-27-final-algebra-semantics-is-observational-equivalence</guid>
   <pubDate>Wed, 27 Sep 2017 15:44:57 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;Recently, &amp;ldquo;final encodings&amp;rdquo; and &amp;ldquo;finally tagless style&amp;rdquo; have become popular techniques for defining embedded languages in functional languages. In a recent discussion in the Northeastern PRL lab, &lt;a href="https://github.com/michaelballantyne"&gt;Michael Ballantyne&lt;/a&gt;, &lt;a href="http://ccs.neu.edu/home/ryanc"&gt;Ryan Culpepper&lt;/a&gt; and I asked &amp;ldquo;in what category are these actually final objects&amp;rdquo;? As it turns out our very own &lt;a href="http://www.ccs.neu.edu/home/wand/"&gt;Mitch Wand&lt;/a&gt; wrote one of the first papers to make exactly this idea precise, so I read it &lt;a href="https://www.cs.indiana.edu/ftp/techreports/TR65.pdf"&gt;available here&lt;/a&gt; and was pleasantly surprised to see that the definition of a final algebra there is essentially equivalent to the definition of observational equivalence.&lt;/p&gt;

&lt;p&gt;In this post, I&amp;rsquo;ll go over some of the results of that paper and explain the connection to observational equivalence. In the process we&amp;rsquo;ll learn a bit about categorical logic, and I&amp;rsquo;ll reformulate some of the category theory in that paper to be a bit more modern in presentation, cleaning some things up in the process.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="intuition-implementing-a-signature"&gt;Intuition: Implementing a Signature&lt;/h1&gt;

&lt;p&gt;As a running example, say we wanted to implement a datatype of finite maps whose keys and values are both integers, i.e., finite multisets of integers.&lt;/p&gt;

&lt;p&gt;We could specify such a datatype by specifying a little language of numbers and finite multisets. We&amp;rsquo;ll have two &amp;ldquo;sorts&amp;rdquo; &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;multiset&lt;/code&gt;, a constant for every integer, and an addition function&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;'n : () -&amp;gt; num;
add : (num, num) -&amp;gt; num&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;subject to the silly-looking equation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;add('n,'m) = '(n + m)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and some operations on multisets&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;empty : () -&amp;gt; multiset;
singleton : (num) -&amp;gt; multiset;
union : (multiset, multiset) -&amp;gt; multiset;
remove : (num, multiset) -&amp;gt; multiset;
count : (num, multiset) -&amp;gt; num&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;subject to the computational equations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;count('n, empty) = '0
count('n, singleton('n)) = '1
count('n, singleton('m)) = '0
count('n, union(s,t)) = add(count('n,s), count('n, t))
count('n, remove('n,s)) = '0
count('n, remove('m,s)) = count('n,s)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are &amp;ldquo;all&amp;rdquo; of the equations we need to actually run our programs and get a number out, but not all the equations we intuitively &lt;em&gt;want&lt;/em&gt; for reasoning about our programs. For instance, clearly &lt;code&gt;union&lt;/code&gt; should be commutative, and &lt;code&gt;remove&lt;/code&gt; should be idempotent, but it&amp;rsquo;s impossible to prove that with just the equations specified. In fact, we can make a model of this theory that refutes them by constructing the &amp;ldquo;initial algebra&amp;rdquo;. In Haskell, we could say&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Empty&lt;/span&gt; 
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Singleton&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Union&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Remove&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Eq&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;count&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt;
&lt;span class="nf"&gt;count&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="kt"&gt;Empty&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="nf"&gt;count&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Singleton&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nf"&gt;count&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Singleton&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;/=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="nf"&gt;count&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Union&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;count&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Remove&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="nf"&gt;count&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Remove&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;/=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Then it is completely obvious that all of our equations hold, but then &lt;code&gt;Union&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; commutative, as ghci will tell us:&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Singleton&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;Union&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;Singleton&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Singleton&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;Union&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;Singleton&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="kt"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;However, there is another encoding that will give us that &lt;code&gt;union&lt;/code&gt; is commutative and &lt;code&gt;remove n&lt;/code&gt; is idempotent and actually every equation we could possibly want! It&amp;rsquo;s called the &amp;ldquo;final encoding&amp;rdquo; or &amp;ldquo;final algebra&amp;rdquo;. In Haskell, this looks like:&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;_count&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nf"&gt;count&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt;
&lt;span class="nf"&gt;count&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_count&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;

&lt;span class="nf"&gt;empty&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;
&lt;span class="nf"&gt;empty&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;_count&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nf"&gt;singleton&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;
&lt;span class="nf"&gt;singleton&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;_count&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kr"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
                                         &lt;span class="kr"&gt;then&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
                                         &lt;span class="kr"&gt;else&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nf"&gt;union&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;
&lt;span class="nf"&gt;union&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;_count&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nf"&gt;remove&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt;
&lt;span class="nf"&gt;remove&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;_count&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kr"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
                                        &lt;span class="kr"&gt;then&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
                                        &lt;span class="kr"&gt;else&lt;/span&gt; &lt;span class="n"&gt;count&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nf"&gt;test&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;count&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;count&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;span class="nf"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;singleton&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;union&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;singleton&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="nf"&gt;t&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;singleton&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;union&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;singleton&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Now we can verify that &lt;code&gt;union&lt;/code&gt; is commutative because&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;union&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;_count&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
          &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;MultiSet&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;_count&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
		  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;union&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;since &lt;code&gt;+&lt;/code&gt; is commutative. Equality isn&amp;rsquo;t decidable anymore so I can&amp;rsquo;t give you a simple piece of code to witness this, but we can test our example before and we won&amp;rsquo;t be able to distinguish them, no surprise:&lt;/p&gt;

&lt;div class="brush: Haskell"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;singleton&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;union&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;singleton&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;singleton&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;union&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;singleton&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;count&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;count&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;span class="kt"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;How do we know this is the &amp;ldquo;best&amp;rdquo; or at least &amp;ldquo;most canonical&amp;rdquo; implementation of our datatype? The intuition is that we really don&amp;rsquo;t care at all &lt;em&gt;how&lt;/em&gt; our multisets are implemented as long as they behave the right way with respect to &lt;code&gt;count&lt;/code&gt; since &lt;code&gt;count&lt;/code&gt; returns an &lt;code&gt;Integer&lt;/code&gt;, a type we do understand. Our encoding accomplishes this by representing a multiset &lt;code&gt;s&lt;/code&gt; by the partially applied function &lt;code&gt;\n -&amp;gt; count n s&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The formal name for this idea is &lt;em&gt;observational equivalence&lt;/em&gt;. We say that two closed terms &lt;code&gt;s,t&lt;/code&gt; of sort &lt;code&gt;multiset&lt;/code&gt; are &lt;em&gt;observationally equivalent&lt;/em&gt; if for any term &lt;code&gt;C&lt;/code&gt; of type &lt;code&gt;num&lt;/code&gt; that has &lt;code&gt;s&lt;/code&gt; as a subterm, we can swap &lt;code&gt;t&lt;/code&gt; in for &lt;code&gt;s&lt;/code&gt; and prove that the two terms are equal. For instance &lt;code&gt;C&lt;/code&gt; might be &lt;code&gt;count(3, union(s, singleton(3)))&lt;/code&gt; or &lt;code&gt;add(4,remove(5,s))&lt;/code&gt;. Then we&amp;rsquo;ve reduced the possibly complicated equality for &lt;code&gt;multiset&lt;/code&gt; to the simple equality of &lt;code&gt;num&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Proving that the final encoding above satisfies all observational equivalences is beyond the scope of this blog post (see &lt;a href="https://hal.inria.fr/inria-00076514/document"&gt;here&lt;/a&gt;), but let&amp;rsquo;s see what all this talk about &amp;ldquo;algebras&amp;rdquo;, initial or final is all about.&lt;/p&gt;

&lt;h1 id="formalization-attempt-1-algebras-of-a-theory"&gt;Formalization Attempt 1: Algebras of a Theory&lt;/h1&gt;

&lt;p&gt;First, our little language of numbers and multisets is called a &lt;em&gt;theory&lt;/em&gt;. The specific category gadget that we&amp;rsquo;ll use to describe it is a &lt;em&gt;multi-sorted Lawvere theory&lt;/em&gt;, or just &lt;em&gt;Lawvere theory&lt;/em&gt; for short.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;Lawvere theory&lt;/em&gt; is a category with finite products all of whose objects are finite products of a collection of &lt;em&gt;sorts&lt;/em&gt; 
 &lt;script type="math/tex"&gt;S&lt;/script&gt;. We can construct this category from our little language above by making the objects be &lt;em&gt;contexts&lt;/em&gt; 
 &lt;script type="math/tex"&gt;x:num,y:multiset,...&lt;/script&gt; and morphisms 
 &lt;script type="math/tex"&gt;\Gamma \to
x_1:s_1,...,x_n:s_n&lt;/script&gt; to be 
 &lt;script type="math/tex"&gt;n&lt;/script&gt;-tuples of terms 
 &lt;script type="math/tex"&gt;\Gamma \vdash t_1 : s_1,...,
\Gamma \vdash t_n :  s_n&lt;/script&gt; &lt;em&gt;modulo&lt;/em&gt; the equations we&amp;rsquo;ve specified. We&amp;rsquo;ll use the letter 
 &lt;script type="math/tex"&gt;T&lt;/script&gt; to mean a Lawvere theory.&lt;/p&gt;

&lt;p&gt;Then a &lt;em&gt;
  &lt;script type="math/tex"&gt;T&lt;/script&gt;-algebra&lt;/em&gt; is a denotational semantics of our theory 
 &lt;script type="math/tex"&gt;T&lt;/script&gt;, i.e., a product preserving functor 
 &lt;script type="math/tex"&gt;A : T \to Set&lt;/script&gt;. This means for every sort we get a set 
 &lt;script type="math/tex"&gt;A(s)&lt;/script&gt; and for every term 
 &lt;script type="math/tex"&gt;x_1:s_1,...,x_n:s_n
\vdash t : s&lt;/script&gt; a function 
 &lt;script type="math/tex"&gt;A(t) : A(s_1)\times\cdots \times A(s_n) \to
A(s)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Finally a &lt;em&gt;morphism of 
  &lt;script type="math/tex"&gt;T&lt;/script&gt;-algebras&lt;/em&gt; from 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;B&lt;/script&gt; is a way to translate one algebra into another. Briefly, it is a natural transformation from 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;B&lt;/script&gt;, but concretely this means for every sort 
 &lt;script type="math/tex"&gt;s&lt;/script&gt; we get a function 
 &lt;script type="math/tex"&gt;\alpha_s : A(s) \to B(s)&lt;/script&gt; that translates 
 &lt;script type="math/tex"&gt;A&lt;/script&gt;s interpretation of 
 &lt;script type="math/tex"&gt;s&lt;/script&gt; as a set into 
 &lt;script type="math/tex"&gt;B&lt;/script&gt;s. The key property that we want is that the operations according to 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;B&lt;/script&gt; do the same thing as determined by 
 &lt;script type="math/tex"&gt;\alpha&lt;/script&gt;. Specifically, for any term 
 &lt;script type="math/tex"&gt;x_1:s_1,...,x_n:s_n \vdash t :
s&lt;/script&gt;, and inputs 
 &lt;script type="math/tex"&gt;x_1 \in A(s_1),...,x_n \in A(s_n)&lt;/script&gt; we should get the same result if we evaluate 
 &lt;script type="math/tex"&gt;A(t)(x_1,\ldots,x_n)&lt;/script&gt; and then apply 
 &lt;script type="math/tex"&gt;\alpha_s&lt;/script&gt; as if we first translate 
 &lt;script type="math/tex"&gt;x_1,\ldots,x_n&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;B(s_1),\ldots,B(s_n)&lt;/script&gt; and then apply 
 &lt;script type="math/tex"&gt;B(t)&lt;/script&gt;. If you unwind the definitions, this is exactly what naturality says.&lt;/p&gt;

&lt;p&gt;Then we have a category we&amp;rsquo;ll call 
 &lt;script type="math/tex"&gt;T-Alg&lt;/script&gt; of 
 &lt;script type="math/tex"&gt;T&lt;/script&gt;-algebras and we can ask if there are initial or final algebra. It turns out that both of them &lt;em&gt;always&lt;/em&gt; exist.&lt;/p&gt;

&lt;p&gt;The initial algebra is most famous here, we define for each sort 
 &lt;script type="math/tex"&gt;In(T)(s) = \cdot \vdash s&lt;/script&gt;, the closed terms of that sort modulo the equivalence of the theory, and 
 &lt;script type="math/tex"&gt;In(T)(s_1,\ldots,s_n) =
In(T)(s_1)\times\ldots,In(T)(s_n)&lt;/script&gt;. Then the terms are just interpreted as the functions you get by plugging closed inputs into them. Then if we look at what what a morphism of 
 &lt;script type="math/tex"&gt;T&lt;/script&gt;-algebras from 
 &lt;script type="math/tex"&gt;In(T) \to A&lt;/script&gt; is, we see that we don&amp;rsquo;t have any choice, the only one is the one that maps 
 &lt;script type="math/tex"&gt;\cdot \vdash t : s&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;A(t)&lt;/script&gt; and this makes all the right diagrams to commute. This is pretty similar to our definition of &amp;ldquo;initial algebra&amp;rdquo; before, except that this time we defined &lt;code&gt;count&lt;/code&gt; as a function, not just a case of an ADT, but that was just an easy way to satisfy the computational equations for &lt;code&gt;count&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;However, an egregious flaw presents itself when we look at what the &lt;em&gt;final&lt;/em&gt; algebra is. It&amp;rsquo;s completely trivial! We can define 
 &lt;script type="math/tex"&gt;Fin(T)&lt;/script&gt; to take every sort to a one element set 
 &lt;script type="math/tex"&gt;Fin(T)(s) = \{*\}&lt;/script&gt; and every term to the trivial function 
 &lt;script type="math/tex"&gt;\{*\}^n \to \{*\}&lt;/script&gt;. What the hell? This interprets numbers and multisets as trivial one-element sets. To rule this one out, we need to add some conditions to our algebras.&lt;/p&gt;

&lt;h1 id="formalization-algebras-of-a-theory-extension"&gt;Formalization: Algebras of a Theory Extension&lt;/h1&gt;

&lt;p&gt;To rule out these boring algebras, and get a nice final algebra, we have to recognize that the sorts &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;multiset&lt;/code&gt; in our theory are not really on equal footing. While we are not sure how multisets should be defined, we know &lt;em&gt;exactly&lt;/em&gt; what numbers are!&lt;/p&gt;

&lt;p&gt;To formalize this we&amp;rsquo;ll call the full theory 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt; and the theory with just numbers 
 &lt;script type="math/tex"&gt;T_0&lt;/script&gt;. Then there should be a map from 
 &lt;script type="math/tex"&gt;T_0&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt; that is the inclusion of theories. We&amp;rsquo;ll formalize this as a &lt;em&gt;morphism of theories&lt;/em&gt;. A morphism of theories is a &lt;em&gt;strict&lt;/em&gt; product-preserving functor from one theory to another. The strictness ensures that we don&amp;rsquo;t mix up our sorts and our contexts, a morphim of theories has to map sorts to sorts, whereas a non-strict functor could map a sort to a context with two sorts it&amp;rsquo;s equivalent to. What this really amounts to is a translation of one theory into another. It maps sorts to sorts and terms to terms of the appropriate sorts in a compositional way. However, we don&amp;rsquo;t want to consider &lt;em&gt;all&lt;/em&gt; such morphisms, only the ones that are &amp;ldquo;conservative extensions&amp;rdquo;, which means&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;there are no new closed terms at old types&lt;/li&gt;
 &lt;li&gt;closed terms that were different before remain different.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;In our example (1) ensures that we don&amp;rsquo;t add any new exotic numbers like &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;∞&lt;/code&gt;, and (2) ensures that we keep 
 &lt;script type="math/tex"&gt;0&lt;/script&gt; different from 
 &lt;script type="math/tex"&gt;1&lt;/script&gt;, like the final algebra did before by having all numbers have the same interpreation 
 &lt;script type="math/tex"&gt;*&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We can formalize this in the following way. Note that any morphism of Lawvere theories 
 &lt;script type="math/tex"&gt;m : T \to S&lt;/script&gt; induces a &lt;em&gt;functor&lt;/em&gt; on the category of algebras 
 &lt;script type="math/tex"&gt;m^* : S-Alg \to T-Alg&lt;/script&gt; by just composing functors. An 
 &lt;script type="math/tex"&gt;S&lt;/script&gt;-algebra is a functor from 
 &lt;script type="math/tex"&gt;S&lt;/script&gt; to sets, and 
 &lt;script type="math/tex"&gt;m&lt;/script&gt; is a functor from 
 &lt;script type="math/tex"&gt;T&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;S&lt;/script&gt; so we can compose to get 
 &lt;script type="math/tex"&gt;m^*(A)(t) = A(m(t))&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Now, we can express the idea of a conservative extension by saying that the canonical arrow from 
 &lt;script type="math/tex"&gt;In(T)&lt;/script&gt; to 
 &lt;script type="math/tex"&gt;m^*(In(S))&lt;/script&gt; is an isomorphism. Recalling the definition of initial algebras, this says exactly that the closed terms in 
 &lt;script type="math/tex"&gt;T&lt;/script&gt; up to 
 &lt;script type="math/tex"&gt;T&lt;/script&gt;-equivalence are isomorphic to the closed terms of the type provided by 
 &lt;script type="math/tex"&gt;m&lt;/script&gt; in 
 &lt;script type="math/tex"&gt;S&lt;/script&gt; up to 
 &lt;script type="math/tex"&gt;S&lt;/script&gt;-equivalence. This is an equivalent formulation to the definition in Mitch&amp;rsquo;s paper, but there it is separated into two properties fullness and faithfulness, and doesn&amp;rsquo;t use the initial algebras and 
 &lt;script type="math/tex"&gt;m^*&lt;/script&gt; explicitly.&lt;/p&gt;

&lt;p&gt;Now we can verify that the inclusion 
 &lt;script type="math/tex"&gt;i : T_0 \to T_1&lt;/script&gt; of the number theory into the number-multiset theory is an extension in this sense.&lt;/p&gt;

&lt;p&gt;Finally we can define our notion of 
 &lt;script type="math/tex"&gt;i&lt;/script&gt;-algebra, which will be our correct notion of algebra. An 
 &lt;script type="math/tex"&gt;i&lt;/script&gt;-algebra is a 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt; algebra 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; such that&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;The canonical algebra map 
  &lt;script type="math/tex"&gt;! : In(T_0) \to m^*A&lt;/script&gt; is an isomorphism.&lt;/li&gt;
 &lt;li&gt;The canonical algebra map 
  &lt;script type="math/tex"&gt;! : In(T_1) \to A&lt;/script&gt; is surjective i.e.,  for each sort 
  &lt;script type="math/tex"&gt;s, !_s&lt;/script&gt; is surjective.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;The first condition says again that we have a conservative extension of 
 &lt;script type="math/tex"&gt;T_0&lt;/script&gt;, but the second is more interesting. It says that every denotation given by 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; is represented by some term in 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt;. In fact what it really ensures is that 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; determines a &lt;em&gt;congruence relation&lt;/em&gt; on 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt; given by 
 &lt;script type="math/tex"&gt;t1 \equiv_A t2&lt;/script&gt; if 
 &lt;script type="math/tex"&gt;A(t1) = A(t2)&lt;/script&gt;. In light of this, the first condition could be called &lt;em&gt;adequacy&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Furthermore, the surjectivity condition ensures that any morphism of 
 &lt;script type="math/tex"&gt;i&lt;/script&gt; algebras, i.e., a map as 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt;-algebras is also surjective, so a morphism 
 &lt;script type="math/tex"&gt;A \to B&lt;/script&gt; is a witness to the fact that 
 &lt;script type="math/tex"&gt;B&lt;/script&gt; determines a &lt;em&gt;stronger&lt;/em&gt; congruence relation on 
 &lt;script type="math/tex"&gt;T_1&lt;/script&gt; than 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; does: 
 &lt;script type="math/tex"&gt;t1 \equiv_B t2
\implies t1 \equiv_A t2&lt;/script&gt;. Then asking for a final algebra is asking for exactly the:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Strongest adequate congruence relation&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;which is exactly the definition of observational equivalence you will find in, say Pitt&amp;rsquo;s chapter of &lt;a href="https://www.cis.upenn.edu/~bcpierce/attapl/"&gt;Advanced TAPL&lt;/a&gt;. There is a difference in the meaning of &lt;em&gt;adequacy&lt;/em&gt;, though. Usually adequacy is defined in terms of an operational semantics, but here everything is based on an axiomatic notion of equality, but I think they play the same role in the two settings, so I think it&amp;rsquo;s reasonable to use the same word. On thing I like about this formulation is very nice though since it makes obvious that &lt;em&gt;adequacy&lt;/em&gt; is not a predetermined concept, we have to pick 
 &lt;script type="math/tex"&gt;T_0&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;i&lt;/script&gt; in order to know what adequacy means.&lt;/p&gt;

&lt;h1 id="conclusion-tying-it-back-to-final-encodings"&gt;Conclusion: Tying it back to Final Encodings&lt;/h1&gt;

&lt;p&gt;So now we&amp;rsquo;ve seen that&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Final algebras are equivalent to initial algebras modulo observational equivalence&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Of course we haven&amp;rsquo;t precisely gotten back to where we started: we were talking about denotational semantics in terms of sets and functions, but what we really want are implementations in our favorite programming languages. Fortunately, we didn&amp;rsquo;t use very many properties of sets in our definition, so it&amp;rsquo;s pretty easy to swap out the category of Sets for some category built out of the terms of our programming language. We can also swap out sets for some much cooler category of denotations like domains or metric spaces or time-varying values.&lt;/p&gt;

&lt;p&gt;Another question is how to implement this when we have a proper &lt;em&gt;type theory&lt;/em&gt; and not just some boring sorts. In particular, if we have function types, then we won&amp;rsquo;t be able to get functions from functions in our term model to functions in our denotations due to contravariance. Perhaps logical relations are the solution?&lt;/p&gt;</description></item>
  <item>
   <title>Closure Conversion as CoYoneda</title>
   <link>http://prl.ccs.neu.edu/blog/2017/08/28/closure-conversion-as-coyoneda/?utm_source=category-theory&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-08-28-closure-conversion-as-coyoneda</guid>
   <pubDate>Mon, 28 Aug 2017 10:30:00 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;The continuation-passing style transform (cps) and closure conversion (cc) are two techniques widely employed by compilers for functional languages, and have been studied extensively in the compiler correctness literature. Interestingly, &lt;em&gt;typed&lt;/em&gt; versions of each can be proven to be equivalence preserving using polymorphic types and parametric reasoning, as shown by my advisor Amal Ahmed and Matthias Blume (&lt;a href="http://www.ccs.neu.edu/home/amal/papers/epc.pdf"&gt;cps&lt;/a&gt;,&lt;a href="http://www.ccs.neu.edu/home/amal/papers/tccpoe.pdf"&gt;cc&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;In fact, there is something like a duality between the two proofs, cps uses a universal type, closure-conversion uses an existential type and the isomorphism proofs use analogous reasoning. It turns out that both are instances of general theorems in category theory: the polymorphic cps isomorphism can be proven using the Yoneda lemma, and the polymorphic closure-conversion isomorphism can be proven using a less well known theorem often called the &lt;a href="https://ncatlab.org/nlab/show/co-Yoneda+lemma"&gt;*co*Yoneda lemma&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The connection between cps and the Yoneda embedding/lemma is detailed elsewhere in the &lt;a href="http://www.cs.ox.ac.uk/people/daniel.james/iso/iso.pdf"&gt;literature&lt;/a&gt; and blogosphere (&lt;a href="https://golem.ph.utexas.edu/category/2008/01/the_continuation_passing_trans.html"&gt;ncafe&lt;/a&gt;, &lt;a href="https://bartoszmilewski.com/2015/09/01/the-Yoneda-lemma/"&gt;Bartosz&lt;/a&gt;), so I&amp;rsquo;ll focus on closure conversion here. Also, I&amp;rsquo;ll try to go into some detail in showing how the &amp;ldquo;usual&amp;rdquo; version of Yoneda/coYoneda (using the category of sets) relates to the appropriate version for compilers.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll assume some background knowledge on closure conversion and parametricity below. Fortunately, Matt Might has a &lt;a href="http://matt.might.net/articles/closure-conversion/"&gt;nice blog post explaining untyped closure conversion&lt;/a&gt;.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;
 &lt;script type="math/tex"&gt;
\newcommand{\Set}{\mathsf{Set}}
\newcommand{\Hom}{\mathsf{Hom}}&lt;/script&gt;&lt;/p&gt;

&lt;h2 id="polymorphic-closure-conversion"&gt;Polymorphic Closure Conversion&lt;/h2&gt;

&lt;p&gt;Closure conversion is a way of compiling a language with closures (i.e., basically any modern high-level language) to one that only has function pointers/labels like C or machine code. Closure conversion compiles high-level functions (aka closures) to a pair of an environment that will contain the values of all the functions&amp;rsquo; free variables and a code pointer to a block that takes as inputs all the inputs to the function and values for all of the free variables.&lt;/p&gt;

&lt;p&gt;For instance&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = 3 in λ y. x + y&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would be converted to something like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = 3 in ([x: 3], λ env, y. let x = env.x in x + y)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Can we give a type to the resulting code? The source program has type &lt;code&gt;Number -&amp;gt; Number&lt;/code&gt;, but the target has a type more like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ x: Number} × ({x : Number} × Number -&amp;gt; Number).&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition to being ugly, this type is leaking irrelevant details of the function&amp;rsquo;s implementation: all of its free variables are there in its type, so two terms with the same function type but different free variables would be translated to different types. Also high-level program equivalences like 
 &lt;script type="math/tex"&gt;\beta&lt;/script&gt;-reducing the term to just &lt;code&gt;λ y. 3 + y&lt;/code&gt; would not even preserve typing. Not only that, but some bad code could now supply a &lt;em&gt;different&lt;/em&gt;, well-typed value for &lt;code&gt;x&lt;/code&gt; than allowed which could break invariants the programmer had about the function.&lt;/p&gt;

&lt;p&gt;We could fix the type preservation issue by just using a dynamic type for our environment, but this would still leak details in the values. Fortunately, there is a nice solution to the other problems using existential types. The idea is that the type of the environment of free variables is &lt;em&gt;irrelevant&lt;/em&gt; to anyone that calls the function, only the function itself should know what the environment looks like; the type of the environment should be &lt;em&gt;abstract&lt;/em&gt; to the caller and &lt;em&gt;concrete&lt;/em&gt; to the callee. Existential types capture this.&lt;/p&gt;

&lt;p&gt;We can translate functions in the source of type &lt;code&gt;A -&amp;gt; B&lt;/code&gt; to pairs of an environment and a code pointer, but now making the environment type existentially quantified:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;∃ Γ. Γ × (Γ × A -&amp;gt; B).&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the syntax of existential types ensure that all any consumer can do with the &lt;code&gt;env : Γ&lt;/code&gt; in the pair is pass it to the code pointer with an &lt;code&gt;A&lt;/code&gt; argument.&lt;/p&gt;

&lt;p&gt;How do we prove that this is correct? And what does correct even mean? We&amp;rsquo;ll focus on a property called &lt;em&gt;full abstraction&lt;/em&gt; which says that if two programs are equal in the source language, then their translations are equal. Here, equal in the source language will just mean 
 &lt;script type="math/tex"&gt;\beta,\eta&lt;/script&gt; equivalence, so things like as above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = 3 in λ y. x + y
≡
λ y. 3 + y&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To prove this we&amp;rsquo;ll show that in a language with existential types the types &lt;code&gt;∃ Γ. Γ × (Γ × A -&amp;gt; B)&lt;/code&gt; and &lt;code&gt;A \to B&lt;/code&gt; are isomorphic. The usual proof is by parametricity, instead we&amp;rsquo;ll use a closely related category-theoretic argument: the coYoneda lemma.&lt;/p&gt;

&lt;h2 id="the-coyoneda-lemma"&gt;The CoYoneda Lemma&lt;/h2&gt;

&lt;p&gt;The coYoneda lemma is a generalization of the equivalence described above. I&amp;rsquo;ll start with the ordinary version which uses &lt;em&gt;coends&lt;/em&gt; and &lt;em&gt;presheaves&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The coYoneda lemma says that for any category 
 &lt;script type="math/tex"&gt; C&lt;/script&gt;, presheaf 
 &lt;script type="math/tex"&gt; Q : C^{op} \to \Set&lt;/script&gt;, and object 
 &lt;script type="math/tex"&gt;A \in C&lt;/script&gt;, 
 &lt;script type="math/tex"&gt;Q(A)&lt;/script&gt; is isomorphic to the coend: 
 &lt;script type="math/tex; mode=display"&gt; \exists B. (A \to B) \times Q(B)&lt;/script&gt; Let&amp;rsquo;s break that down.&lt;/p&gt;

&lt;h3 id="coends"&gt;Coends&lt;/h3&gt;

&lt;p&gt;A coend is a construction that is very similar to the parametric existential quantifier. If you&amp;rsquo;re familiar with parametricity, a good intuition is that coends have the same definition as existential types but where the only relations are functional relations.&lt;/p&gt;

&lt;p&gt;You can take the coend of a functor of type 
 &lt;script type="math/tex"&gt;M : C^{op} \times C \to
\Set&lt;/script&gt;. We can get such an 
 &lt;script type="math/tex"&gt;M&lt;/script&gt; from a type with a free type variable like 
 &lt;script type="math/tex"&gt; X \times A \to X&lt;/script&gt; by splitting the 
 &lt;script type="math/tex"&gt;X&lt;/script&gt; into positive and negative occurrences: 
 &lt;script type="math/tex"&gt;X^- \times A \to X^+&lt;/script&gt;. Then the coend 
 &lt;script type="math/tex"&gt;\exists X. M(X,X) \in \Set&lt;/script&gt; is like the union of all 
 &lt;script type="math/tex"&gt;M(X,X)&lt;/script&gt;, but where the 
 &lt;script type="math/tex"&gt;X&lt;/script&gt; is ensured to be &amp;ldquo;irrelevant&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;So for any object 
 &lt;script type="math/tex"&gt;A \in C&lt;/script&gt; there is a map 
 &lt;script type="math/tex"&gt;pack_A : M(A,A) \to
\exists X. M(X,X)&lt;/script&gt;, we can &amp;ldquo;hide the A&amp;rdquo;. To make sure the 
 &lt;script type="math/tex"&gt;X&lt;/script&gt; is treated opaquely, we add an invariance condition that says if you have an 
 &lt;script type="math/tex"&gt;mA : M(A,A)&lt;/script&gt; and an 
 &lt;script type="math/tex"&gt;mB :
M(B,B)&lt;/script&gt; such that the 
 &lt;script type="math/tex"&gt;A, B&lt;/script&gt; positions are related by some function 
 &lt;script type="math/tex"&gt;f : A \to B&lt;/script&gt;, then 
 &lt;script type="math/tex"&gt;pack_A(mA) = pack_B(mB)&lt;/script&gt;. More formally, this means that if you have a 
 &lt;script type="math/tex"&gt;m' : M(B,A)&lt;/script&gt;, then&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex; mode=display"&gt; pack_B(M(B,f)(m')) = pack_A(M(f,A)(m'))&lt;/script&gt; or in a point-free style: 
 &lt;script type="math/tex; mode=display"&gt; pack_B \circ M(B,f) = pack_A \circ M(f,A) : M(B,A) \to \exists X. M(X,X)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;A function parameterized by types like 
 &lt;script type="math/tex"&gt;pack&lt;/script&gt; that has this property is called a &lt;em&gt;co-wedge&lt;/em&gt; from 
 &lt;script type="math/tex"&gt;M&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;A coend is an object 
 &lt;script type="math/tex"&gt;\exists X. M(X,X)&lt;/script&gt; and a co-wedge 
 &lt;script type="math/tex"&gt;\forall
A. pack_A : M(A,A) \to \exists X. M(X,X)&lt;/script&gt; that are &lt;em&gt;universal&lt;/em&gt;, i.e. any other co-wedge 
 &lt;script type="math/tex"&gt;\forall A. f_A : M(A,A) \to C&lt;/script&gt; factors through 
 &lt;script type="math/tex"&gt;pack_A&lt;/script&gt;. This gives us the syntax for existential elimination.&lt;/p&gt;

&lt;p&gt;If you are familiar with parametricity, it is a good exercise to see why the usual condition for invariance wrt all &lt;em&gt;relations&lt;/em&gt; implies that a parametric 
 &lt;script type="math/tex"&gt;pack, \exists X. M(X,X)&lt;/script&gt; will form a cowedge. It seems that in general it would not be a universal co-wedge because a parametric exists is invariant under all relations and there are many relations that don&amp;rsquo;t act like functions.&lt;/p&gt;

&lt;h3 id="presheaves"&gt;Presheaves&lt;/h3&gt;

&lt;p&gt;Next, a presheaf is just a functor 
 &lt;script type="math/tex"&gt; Q : C^{op} \to
\Set&lt;/script&gt;. Think of this as a set that is parameterised by a type of &amp;ldquo;inputs&amp;rdquo;, so if you have a map in 
 &lt;script type="math/tex"&gt;C, f : A \to B&lt;/script&gt; you get a function 
 &lt;script type="math/tex"&gt;Q(f) :
Q(B) \to Q(A)&lt;/script&gt; that &amp;ldquo;preprocesses&amp;rdquo; the inputs using 
 &lt;script type="math/tex"&gt;f&lt;/script&gt;. Functoriality ensures that preprocessing with the identity is just the identity and that composition of preprocessers is the preprocessor from the composite function.&lt;/p&gt;

&lt;p&gt;So the informal explanation of the coYoneda lemma is that for any presheaf 
 &lt;script type="math/tex"&gt;Q&lt;/script&gt;, if we have an 
 &lt;script type="math/tex"&gt; \exists X. (A \to X) \times Q(X)&lt;/script&gt;, then since we can&amp;rsquo;t inspect the 
 &lt;script type="math/tex"&gt;X&lt;/script&gt; in any way, all we can really do is compose the 
 &lt;script type="math/tex"&gt;Q(X)&lt;/script&gt; with the preprocesser from the function 
 &lt;script type="math/tex"&gt;A \to X&lt;/script&gt;, giving us a 
 &lt;script type="math/tex"&gt;Q(A)&lt;/script&gt;.&lt;/p&gt;

&lt;h3 id="enriched-categories-and-enriched-coyoneda"&gt;Enriched Categories and Enriched CoYoneda&lt;/h3&gt;

&lt;p&gt;But there&amp;rsquo;s a gap from here to applying this to a programming language, the coYoneda lemma as presented says that 
 &lt;script type="math/tex"&gt;Q(A)&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;\exists B. (A \to B) \times Q(B)&lt;/script&gt; are isomorphic as &lt;em&gt;sets&lt;/em&gt;, but we wanted an isomorphism of &lt;em&gt;types&lt;/em&gt; in our programming language. We can reconcile this by considering &lt;em&gt;enriched&lt;/em&gt; category theory and the &lt;em&gt;enriched&lt;/em&gt; coYoneda lemma. Let 
 &lt;script type="math/tex"&gt;V&lt;/script&gt; be a category, then if 
 &lt;script type="math/tex"&gt; V&lt;/script&gt; is sufficiently like the category of sets, then we can do a lot of category theory by replacing the word &amp;ldquo;set&amp;rdquo; with &amp;ldquo;object of 
 &lt;script type="math/tex"&gt;V&lt;/script&gt;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Specifically, a 
 &lt;script type="math/tex"&gt;V&lt;/script&gt;-enriched category (or just 
 &lt;script type="math/tex"&gt;V&lt;/script&gt;-category) has a set of objects 
 &lt;script type="math/tex"&gt;Ob&lt;/script&gt;, but for each pair of objects 
 &lt;script type="math/tex"&gt;A,B
\in Ob&lt;/script&gt; we get a 
 &lt;script type="math/tex"&gt; V&lt;/script&gt;-object 
 &lt;script type="math/tex"&gt;\Hom(A,B)&lt;/script&gt; of morphisms from 
 &lt;script type="math/tex"&gt;A&lt;/script&gt; to 
 &lt;script type="math/tex"&gt; B&lt;/script&gt;. If 
 &lt;script type="math/tex"&gt;V&lt;/script&gt; is a closed category, we can see 
 &lt;script type="math/tex"&gt;V&lt;/script&gt; &lt;em&gt;itself&lt;/em&gt; as a 
 &lt;script type="math/tex"&gt;V&lt;/script&gt;-enriched category with the same objects and just making 
 &lt;script type="math/tex"&gt;\Hom(A,B) = A \to B&lt;/script&gt; i.e. the &lt;em&gt;internal&lt;/em&gt; hom aka exponential.&lt;/p&gt;

&lt;p&gt;Then we can reinterpret the coYoneda lemma above by saying 
 &lt;script type="math/tex"&gt;C&lt;/script&gt; is a 
 &lt;script type="math/tex"&gt;V&lt;/script&gt;-category and 
 &lt;script type="math/tex"&gt;Q&lt;/script&gt; is a 
 &lt;script type="math/tex"&gt;V&lt;/script&gt;-presheaf i.e., just a contravariant functor from 
 &lt;script type="math/tex"&gt;V&lt;/script&gt; to itself: 
 &lt;script type="math/tex"&gt;Q : V^{op} \to V&lt;/script&gt; where the preprocessing function is now a morphism in 
 &lt;script type="math/tex"&gt;C&lt;/script&gt;. Haskelletons just call this a &lt;a href="https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html"&gt;contravariant functor&lt;/a&gt;. Furthermore, since existential types provide at least as strong of a reasoning principle as coends, the proof of the coYoneda lemma goes through with existential types instead. Finally, the point-free description above for coend can be interpreted in any category.&lt;/p&gt;

&lt;p&gt;Now that we&amp;rsquo;re working all inside our language, let&amp;rsquo;s look at what the isomorphism looks like in Haskellish/Agdaish syntax. We want mutually inverse functions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;f : (Contravariant Q) =&amp;gt; (∃ Γ. (Δ -&amp;gt; Γ) × (Q Γ)) -&amp;gt; Q Δ
g : (Contravariant Q) =&amp;gt; Q Δ -&amp;gt; ∃ Γ. (Δ -&amp;gt; Γ) × (Q Γ)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you try to implement them you won&amp;rsquo;t be able to get it wrong, but here they are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;f (k, qΓ) = contramap k qΓ
g qΔ = (id, qΔ)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where we just instantiate 
 &lt;script type="math/tex"&gt;\Gamma = \Delta&lt;/script&gt; in the second case. You can prove 
 &lt;script type="math/tex"&gt; f \circ g = id&lt;/script&gt; using just 
 &lt;script type="math/tex"&gt;\beta&lt;/script&gt; and the Contravariant laws, but to prove 
 &lt;script type="math/tex"&gt;g \circ f = id&lt;/script&gt; you need to use the coend reasoning. For those of you that know about the Yoneda lemma, note the similarity to that proof in using the identity function and instantiating a type variable in a trivial way.&lt;/p&gt;

&lt;h2 id="closure-version-as-coyoneda"&gt;Closure Version as CoYoneda&lt;/h2&gt;

&lt;p&gt;Now it&amp;rsquo;s time to bring it all together. Let 
 &lt;script type="math/tex"&gt;V&lt;/script&gt; be our programming language viewed as a category in the usual way.&lt;/p&gt;

&lt;p&gt;We want to prove the closure conversion isomorphism:&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex; mode=display"&gt; A \to B \cong \exists \Gamma. \Gamma \times (\Gamma \times A \to B)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;using the 
 &lt;script type="math/tex"&gt;V&lt;/script&gt;-coYoneda lemma which says for any contravariant functor 
 &lt;script type="math/tex"&gt;Q : V^{op} \to V&lt;/script&gt;, and object 
 &lt;script type="math/tex"&gt;\Delta \in V&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex; mode=display"&gt; Q(\Delta) \cong \exists \Gamma. (\Delta \to \Gamma) \times Q(\Gamma)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Clearly based on the right hand side, 
 &lt;script type="math/tex"&gt;Q&lt;/script&gt; should be 
 &lt;script type="math/tex"&gt; - \times
A \to B&lt;/script&gt; which gives us for any 
 &lt;script type="math/tex"&gt;\Delta \in V&lt;/script&gt;:&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex; mode=display"&gt; \Delta \times A \to B \cong \exists \Gamma. (\Delta \to \Gamma) \times (\Gamma \times A \to B)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Next we pick 
 &lt;script type="math/tex"&gt;\Delta = 1&lt;/script&gt;, the unit type. Then we use some basic facts about the unit type: 
 &lt;script type="math/tex"&gt;1 \times A \cong
A&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;1 \to \Gamma \cong \Gamma&lt;/script&gt; (at least in a pure language) to get the desired result by composition:&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex; mode=display"&gt; A \to B \cong 1 \times A \to B \cong \exists \Gamma. (1 \to
\Gamma) \times (\Gamma \times A \to B) \cong \exists \Gamma. \Gamma
\times (\Gamma \times A \to B)&lt;/script&gt;&lt;/p&gt;

&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Since closure conversion is an instance of the CoYoneda lemma, this might be a nice example to give intuition for CoYoneda for programmers. While not as famous as its cousin Yoneda, CoYoneda is used in &lt;a href="https://hackage.haskell.org/package/kan-extensions-5.0.2/docs/Data-Functor-Coyoneda.html"&gt;Haskell&lt;/a&gt; and is also central to the &lt;a href="https://ncatlab.org/nlab/show/Day+convolution"&gt;Day Convolution&lt;/a&gt;, which can be used to give semantics to &lt;a href="atkey-thesis"&gt;separation logic&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Also in researching for this post, I was surprised at how little I could find on the relationship between ends/coends and relational parametricity. This seems very unfortunate as it looks like we&amp;rsquo;re reproving some of the same theorems (Yoneda, coYoneda) using very similar, but incompatible formalisms.&lt;/p&gt;

&lt;h2 id="you-might-also-like"&gt;You might also like&lt;/h2&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="http://prl.ccs.neu.edu/blog/2017/06/05/syntactic-parametricity-strikes-again/"&gt;Syntactic Parametricity Strikes Again&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="http://prl.ccs.neu.edu/blog/2017/05/01/categorical-semantics-for-dynamically-typed-programming-languages/"&gt;Categorical Semantics for Dynamically Typed Programming  Languages&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="http://prl.ccs.neu.edu/blog/2016/11/16/understanding-constructive-galois-connections/"&gt;Understanding Constructive Galois  Connections&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</description></item>
  <item>
   <title>Categorical Semantics for Dynamically Typed Programming Languages</title>
   <link>http://prl.ccs.neu.edu/blog/2017/05/01/categorical-semantics-for-dynamically-typed-programming-languages/?utm_source=category-theory&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-05-01-categorical-semantics-for-dynamically-typed-programming-languages</guid>
   <pubDate>Mon, 01 May 2017 12:25:17 UT</pubDate>
   <author>PRL</author>
   <description>&lt;!-- more--&gt;

&lt;p&gt;In 1969, Dana Scott wrote an &lt;a href="/blog/static/scott-69-93-type-theoretical-alternative.pdf"&gt;unpublished manuscript&lt;/a&gt; in which he said untyped lambda calculus had no mathematical meaning, 11 years later he wrote &lt;a href="/blog/static/scott-80-relating-theories.pdf"&gt;a paper&lt;/a&gt; that organized many of the different semantics he and others had since found using the language of category theory.&lt;/p&gt;

&lt;p&gt;This latter paper is really the first deserving of the title &amp;ldquo;categorical semantics of dynamic typing&amp;rdquo;, and so I&amp;rsquo;m going to present some of the theorems and &amp;ldquo;theorems&amp;rdquo; presented in that paper, but mingled with the history of the idea and the preceding papers that led to them.&lt;/p&gt;

&lt;p&gt;&lt;a href="/blog/static/dyn-cats.pdf"&gt;My Full Notes&lt;/a&gt; continue the story, and you might also be interested in the &lt;a href="https://github.com/nuprl/hopl-s2017/blob/master/lecture_notes/2017-04-07.md"&gt;discussion during the lecture&lt;/a&gt;.&lt;/p&gt;</description></item>
  <item>
   <title>Understanding Constructive Galois Connections</title>
   <link>http://prl.ccs.neu.edu/blog/2016/11/16/understanding-constructive-galois-connections/?utm_source=category-theory&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2016-11-16-understanding-constructive-galois-connections</guid>
   <pubDate>Wed, 16 Nov 2016 00:00:00 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;One of my favorite papers at ICFP 2016 (in lovely &lt;a href="http://conf.researchr.org/home/icfp-2016"&gt;Nara, Japan&lt;/a&gt;) was &lt;a href="https://arxiv.org/abs/1511.06965"&gt;Constructive Galois Connections: Taming the Galois Connection Framework for Mechanized Metatheory&lt;/a&gt; by &lt;a href="http://david.darais.com/"&gt;David Darais&lt;/a&gt; and &lt;a href="https://www.cs.umd.edu/~dvanhorn/"&gt;David Van Horn&lt;/a&gt;. The central technical result is quite interesting, but a little intimidating, so I&amp;rsquo;d like to share a &amp;ldquo;de-generalization&amp;rdquo; of the result that I found helpful to understand.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="history"&gt;History&lt;/h1&gt;

&lt;p&gt;I won&amp;rsquo;t go into much of the details of the paper, because I think it is quite well written, but here&amp;rsquo;s a short overview. The paper is about how to do verified static analysis while taking advantage of the calculational approach of &lt;a href="http://www.di.ens.fr/~cousot/COUSOTpapers/Marktoberdorf98.shtml"&gt;Abstract Interpretation&lt;/a&gt;. The problem is that the Galois connections people use for abstract domains are not always computable. Darais and Van Horn show however that there is a very useful class of Galois connections that is computable, and they show how they can exploit this to write verified static analyses that more closely follow the &amp;ldquo;on-paper&amp;rdquo; proofs, and offload much of the details to the proof assistant as mere calculation.&lt;/p&gt;

&lt;p&gt;David Darais told me about these results when we were at POPL 2016 (in less lovely but much more convenient &lt;a href="http://conf.researchr.org/home/POPL-2016"&gt;St. Petersburg, Florida&lt;/a&gt;) and in particular about the central theorem of the paper, which shows that two different classes of Galois connections they define, &amp;ldquo;Kleisli&amp;rdquo; and &amp;ldquo;Constructive&amp;rdquo; Galois connections, are actually constructively equivalent. I was really surprised by the result when he explained it to me, and so I hoped to find if there was a known generalization of the result for adjunctions of categories, rather than Galois connections of posets.&lt;/p&gt;

&lt;p&gt;Eventually, my usual trawling of &lt;a href="http://mathoverflow.net/"&gt;Mathoverflow&lt;/a&gt; and &lt;a href="https://ncatlab.org/nlab/show/HomePage"&gt;nlab&lt;/a&gt; led me to a &lt;a href="https://ncatlab.org/nlab/show/Cauchy+complete+category#InOrdinaryCatTheoryByProfunctors"&gt;not-quite generalization to categories&lt;/a&gt; and interestingly a &lt;a href="http://mathoverflow.net/questions/222516/duality-between-compactness-and-hausdorffness/222524#222524"&gt;&lt;em&gt;de&lt;/em&gt;-generalization to sets&lt;/a&gt; that helped me immensely to understand the theorem.&lt;/p&gt;

&lt;p&gt;Since I know that the original theorem is a bit technical, I&amp;rsquo;ll explain the de-generalization to sets here, which I hope will help to understand their theorem.&lt;/p&gt;

&lt;h1 id="functions-and-relations"&gt;Functions and Relations&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s start with the &amp;ldquo;Kleisli Arrows&amp;rdquo;, which are monotone functions 
 &lt;script type="math/tex"&gt;f : A \to P(B)&lt;/script&gt; where 
 &lt;script type="math/tex"&gt;A,B&lt;/script&gt; are posets and 
 &lt;script type="math/tex"&gt;P(B)&lt;/script&gt; represents the poset of downward-closed subsets of 
 &lt;script type="math/tex"&gt;B&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Now to &amp;ldquo;de-posetize&amp;rdquo; this, we&amp;rsquo;ll take sets 
 &lt;script type="math/tex"&gt;X,Y&lt;/script&gt; and let 
 &lt;script type="math/tex"&gt;P(Y)&lt;/script&gt; mean the powerset of 
 &lt;script type="math/tex"&gt;Y&lt;/script&gt;, that is the set of all subsets of 
 &lt;script type="math/tex"&gt;Y&lt;/script&gt;. Then a function 
 &lt;script type="math/tex"&gt;f : X \to P(Y)&lt;/script&gt; is actually exactly the same thing as a relation 
 &lt;script type="math/tex"&gt;R \subset X \times Y&lt;/script&gt;. From 
 &lt;script type="math/tex"&gt;f :
X \to P(Y)&lt;/script&gt; we can take 
 &lt;script type="math/tex"&gt;R = \{(x,y) \in X\times Y | y\in f(x)\}&lt;/script&gt; and from 
 &lt;script type="math/tex"&gt;R&lt;/script&gt; we can construct 
 &lt;script type="math/tex"&gt;f(x) = \{y \in Y | (x,y) \in R \}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Furthermore, the &amp;ldquo;Kleisli composition&amp;rdquo; is the same as composition of relations. If 
 &lt;script type="math/tex"&gt;R \subset X \times Y&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;Q \subset Y \times Z&lt;/script&gt;, then the composition is defined as 
 &lt;script type="math/tex; mode=display"&gt; (R;Q) = \{(x,z) \in X \times Z | \exists y\in Y. (x,y) \in R \land (y,z) \in Q\}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Then the next thing we need to understand is what is the de-generalization of &amp;ldquo;Kleisli Galois connection&amp;rdquo;? Well, Galois connections are an instance of what&amp;rsquo;s called an adjunction in category theory, which is usually formulated in terms of categories, functors and natural transformations. However, you can interpret the definition of adjunction in any &amp;ldquo;universe&amp;rdquo; that acts like the universe of categories, functors and natural transformations and it turns out we have such a universe. The universe I&amp;rsquo;m talking about is called 
 &lt;script type="math/tex"&gt;\texttt{Rel}&lt;/script&gt;, and it consists of sets, relations between sets and &lt;em&gt;inclusion of relations&lt;/em&gt;, i.e. that one relation is a subset of another.&lt;/p&gt;

&lt;p&gt;Then what does it mean to have an adjunction between two relations 
 &lt;script type="math/tex"&gt;R \subset X \times Y, Q \subset Y \times X&lt;/script&gt;? Taking apart the definition it just means&lt;/p&gt;

&lt;p&gt;\begin{align}\tag{1}  \Delta(X) \subset R;Q \end{align} \begin{align}\tag{2}  Q;R \subset \Delta(Y) \end{align}&lt;/p&gt;

&lt;p&gt;where 
 &lt;script type="math/tex"&gt;\Delta&lt;/script&gt; means the &lt;em&gt;diagonal&lt;/em&gt;, or equality relation on the set:&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex; mode=display"&gt;\Delta(X) = \{(x_1,x_2) \in X | x_1 = x_2 \}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;So we just need to unravel what (1) and (2) mean above. Unwinding (1), we get that for any 
 &lt;script type="math/tex"&gt;x \in X&lt;/script&gt;, there exists a 
 &lt;script type="math/tex"&gt;y \in Y&lt;/script&gt; such that 
 &lt;script type="math/tex"&gt;(x,y) \in R&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;(y,x) \in Q&lt;/script&gt;. This tells us for one that 
 &lt;script type="math/tex"&gt;R&lt;/script&gt; is a &amp;ldquo;right-total&amp;rdquo; relation and 
 &lt;script type="math/tex"&gt;Q&lt;/script&gt; is a &amp;ldquo;left-total&amp;rdquo; relation. Every 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; is related to some 
 &lt;script type="math/tex"&gt; y&lt;/script&gt; by 
 &lt;script type="math/tex"&gt; R&lt;/script&gt; and 
 &lt;script type="math/tex"&gt; Q&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;If we unwind (2), we get that for any 
 &lt;script type="math/tex"&gt;y,y' \in Y&lt;/script&gt; if there&amp;rsquo;s some 
 &lt;script type="math/tex"&gt;x \in X&lt;/script&gt; such that 
 &lt;script type="math/tex"&gt;(x,y) \in R&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;(y',x) \in Q&lt;/script&gt; then actually 
 &lt;script type="math/tex"&gt;y = y')&lt;/script&gt;. This one is a bit more mysterious, but first, let&amp;rsquo;s see what this tells us about the relationship between 
 &lt;script type="math/tex"&gt;R&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;Q&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;If 
 &lt;script type="math/tex"&gt;(x,y) \in R&lt;/script&gt;, then by (1) there&amp;rsquo;s some 
 &lt;script type="math/tex"&gt;y' \in Y&lt;/script&gt; so that 
 &lt;script type="math/tex"&gt;(x,y') \in R&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;(y',x) \in Q&lt;/script&gt;. Then, by (2) we know that 
 &lt;script type="math/tex"&gt;y = y'&lt;/script&gt;, so we&amp;rsquo;ve shown that if 
 &lt;script type="math/tex"&gt;(x,y) \in R&lt;/script&gt; then 
 &lt;script type="math/tex"&gt;(y,x)
\in Q&lt;/script&gt;. Then a completely symmetric argument shows that if 
 &lt;script type="math/tex"&gt;(y,x)
\in Q&lt;/script&gt; then 
 &lt;script type="math/tex"&gt;(x,y)\in R&lt;/script&gt;! So we&amp;rsquo;ve discovered that actually 
 &lt;script type="math/tex"&gt;Q&lt;/script&gt; is just the opposite relation of 
 &lt;script type="math/tex"&gt;R&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Then if we look at (2) again but replace the 
 &lt;script type="math/tex"&gt;Q&lt;/script&gt;&amp;rsquo;s by flipped 
 &lt;script type="math/tex"&gt;R&lt;/script&gt;&amp;rsquo;s we get that for any 
 &lt;script type="math/tex"&gt;y,y' \in Y&lt;/script&gt;, if there&amp;rsquo;s some 
 &lt;script type="math/tex"&gt;x
\in X&lt;/script&gt; such that 
 &lt;script type="math/tex"&gt;(x,y) \in R&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;(x,y')\in R&lt;/script&gt; then 
 &lt;script type="math/tex"&gt;y
= y'&lt;/script&gt;, which tells us that 
 &lt;script type="math/tex"&gt;R&lt;/script&gt; is a partial function, i.e., that every 
 &lt;script type="math/tex"&gt;x&lt;/script&gt; is related to at most one 
 &lt;script type="math/tex"&gt;y&lt;/script&gt; by 
 &lt;script type="math/tex"&gt;R&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;You may recognize it now, our 
 &lt;script type="math/tex"&gt;R \subset X \times Y&lt;/script&gt; is just a function, and saying 
 &lt;script type="math/tex"&gt;R, Q&lt;/script&gt; are adjoint is exactly the same as saying that 
 &lt;script type="math/tex"&gt;Q = R^{\text{op}}&lt;/script&gt; and 
 &lt;script type="math/tex"&gt;R&lt;/script&gt; is a function. Adjunctions are so pervasive you saw them back in pre-algebra!&lt;/p&gt;

&lt;h1 id="constructive-galois-connections"&gt;Constructive Galois Connections&lt;/h1&gt;

&lt;p&gt;Back to constructive Galois connections, I hope if you read the paper you can see that their theorem is a generalization of the above argument, where instead of relations we have &amp;ldquo;monotone relations&amp;rdquo;, i.e., downward-closed 
 &lt;script type="math/tex"&gt;R \subset A^{\text{op}} \times B&lt;/script&gt;. Then you can interpret the definition of adjunction in that universe and get that it&amp;rsquo;s the same as a Kleisli Galois connection and that a similar argument to the above shows that the &amp;ldquo;left adjoint&amp;rdquo; is represented by a monotone function 
 &lt;script type="math/tex"&gt;f : A \to B&lt;/script&gt;:&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex; mode=display"&gt;R = \{(x,y) | y \le f(x) \}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Which shows that every Kleisli Galois connection is actually a constructive Galois connection! The details are in their paper, and I hope they are easier to follow now.&lt;/p&gt;

&lt;p&gt;In fact, we get a little extra from what&amp;rsquo;s mentioned in their paper, which is that the &amp;ldquo;right adjoint&amp;rdquo; is represented by 
 &lt;script type="math/tex"&gt;f&lt;/script&gt; as well but in the opposite way:&lt;/p&gt;

&lt;p&gt;
 &lt;script type="math/tex; mode=display"&gt;Q = \{(y,x) | f(x) \le y \}&lt;/script&gt;&lt;/p&gt;

&lt;h1 id="category-theory-post-scriptum"&gt;Category Theory Post Scriptum&lt;/h1&gt;

&lt;p&gt;If you&amp;rsquo;re interested in Category theory, here&amp;rsquo;s a more technical addendum.&lt;/p&gt;

&lt;p&gt;Remembering from Category Theory class, sets are just posets where objects are only less than themselves and posets are (basically) categories where there is at most 1 arrow between objects, so we might naturally ask, does this theorem extend to categories?&lt;/p&gt;

&lt;p&gt;Well, first we need a generalization from relations to downward-closed relations to what are called &lt;a href="https://ncatlab.org/nlab/show/profunctor"&gt;distributors or profunctors&lt;/a&gt;. Then we can also generalize inclusion of relations to morphisms of distributors and ask, is every left adjoint distributor represented by a functor?&lt;/p&gt;

&lt;p&gt;The answer is, at least in full generality, no! For it to be true we need a special property on the codomain of the left adjoint 
 &lt;script type="math/tex"&gt;R : C
\not\to D&lt;/script&gt;, which is called (for mind-boggling reasons) &lt;a href="https://ncatlab.org/nlab/show/Cauchy+complete+category#InOrdinaryCatTheoryByProfunctors"&gt;Cauchy completeness&lt;/a&gt;. Viewing sets and posets as special categories, it turns out that they always have this property, and that&amp;rsquo;s why the theorem worked out for those adjunctions.&lt;/p&gt;</description></item></channel></rss>