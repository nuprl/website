<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
 <title type="text">PRL Blog: Posts tagged 'Author: Ming-Ho Yee'</title>
 <link rel="self" href="http://prl.ccs.neu.edu/blog/feeds/Author-Ming-Ho-Yee.atom.xml" />
 <link href="http://prl.ccs.neu.edu/blog/tags/Author-Ming-Ho-Yee.html" />
 <id>urn:http-prl-ccs-neu-edu:-blog-tags-Author-Ming-Ho-Yee-html</id>
 <updated>2019-09-10T11:00:00Z</updated>
 <entry>
  <title type="text">Four Kinds of Scoping in R</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2019/09/10/four-kinds-of-scoping-in-r/?utm_source=Author-Ming-Ho-Yee&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2019-09-10-four-kinds-of-scoping-in-r</id>
  <published>2019-09-10T11:00:00Z</published>
  <updated>2019-09-10T11:00:00Z</updated>
  <author>
   <name>Ming-Ho Yee</name></author>
  <content type="html">
&lt;p&gt;In the &lt;a href="/blog/2019/09/05/lexical-and-dynamic-scope/"&gt;first&lt;/a&gt; and &lt;a href="/blog/2019/09/10/scoping-in-r/"&gt;second&lt;/a&gt; parts of this blog series, I defined lexical and dynamic scope, and demonstrated interesting cases of scoping in R.&lt;/p&gt;

&lt;p&gt;In this third and final part of my blog series, I&amp;rsquo;d like to discuss a paper by the creators of R, where they motivate the need for lexical scoping in a statistical programming language.&lt;/p&gt;

&lt;p&gt;This is a &amp;ldquo;bonus&amp;rdquo; blog post, because I&amp;rsquo;m going to dive into some of the hairier R features to show how four different kinds of scoping can be simulated in R.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h2 id="lexical-scope-and-statistical-computation"&gt;Lexical scope and statistical computation&lt;/h2&gt;

&lt;p&gt;In &lt;em&gt;Lexical Scope and Statistical Computation&lt;/em&gt;,&lt;sup&gt;&lt;a href="#2019-09-10-four-kinds-of-scoping-in-r-footnote-1-definition" name="2019-09-10-four-kinds-of-scoping-in-r-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt; Robert Gentleman and Ross Ihaka, the creators of R, discuss why they designed R with lexical scoping. The paper is written for a statistics audience, and they provide motivating examples for having lexical scoping in R.&lt;/p&gt;

&lt;p&gt;For the purpose of their discussion, they define four (slightly different) kinds of scoping rules:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;em&gt;trivial&lt;/em&gt;: no free variables allowed&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;static&lt;/em&gt;: a free variable takes its value from a set of global variables&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;lexical&lt;/em&gt;: a free variable takes the value of the binding that was in  effect when the function was defined&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;dynamic&lt;/em&gt;: a free variable takes the value of the most recent assignment to  that variable&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Note that under this set of definitions, &lt;em&gt;static scoping&lt;/em&gt; is a separate scoping rule and not another name for &lt;em&gt;lexical scoping&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;It is possible to simulate each of strategies in R. For fun, we can even construct &amp;ldquo;factories&amp;rdquo; that take a function, and then modify it to use the desired scoping rule! (Jan Jeƒçmen originally provided these examples to me, and I adapted them for this blog post after some feedback from Artem Pelenitsyn.)&lt;/p&gt;

&lt;h3 id="template"&gt;Template&lt;/h3&gt;

&lt;p&gt;Our examples will follow the template given below:&lt;/p&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;factory&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="o"&gt;&amp;lt;???&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
  &lt;span class="nf"&gt;factory&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;h&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# error, 0, 1, or 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;We want to define a &lt;code&gt;factory&lt;/code&gt; that takes a function literal and returns a closure that implements the desired scoping rule.&lt;/p&gt;

&lt;p&gt;Our example consists of three definitions of &lt;code&gt;x&lt;/code&gt;. On line 5, we assign &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; at the top level. On line 7, we assign &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; inside function &lt;code&gt;h&lt;/code&gt;, where we also create the closure. On line 12, we assign &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; inside the function &lt;code&gt;f&lt;/code&gt; and right before we call &lt;code&gt;g&lt;/code&gt;, which is the closure.&lt;/p&gt;

&lt;p&gt;Finally, we call &lt;code&gt;f&lt;/code&gt; and observe the result:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Under trivial scoping, no free variables are allowed, so &lt;code&gt;f()&lt;/code&gt; should result  in an error.&lt;/li&gt;
 &lt;li&gt;Under static scoping, free variables may only refer to global variables, so  &lt;code&gt;f()&lt;/code&gt; should return &lt;code&gt;0&lt;/code&gt;.&lt;/li&gt;
 &lt;li&gt;Under lexical scoping, free variables refer to the variables in scope when  the function was defined, so &lt;code&gt;f()&lt;/code&gt; should return &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt;
 &lt;li&gt;Under dynamic scoping, free variables take the value from the most recent  assignment, so &lt;code&gt;f()&lt;/code&gt; should return &lt;code&gt;2&lt;/code&gt;.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;We will implement the body of &lt;code&gt;factory&lt;/code&gt; in only 3&amp;ndash;5 lines of code. The rest of the code snippet, from lines 7 to the end, will remain the same, other than the call to &lt;code&gt;factory&lt;/code&gt; on line 10.&lt;/p&gt;

&lt;h3 id="trivial-scoping"&gt;Trivial scoping&lt;/h3&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;makeTrivial&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substitute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="nf"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;baseenv&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;res&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
  &lt;span class="nf"&gt;makeTrivial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;h&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# Error in f(0) : object &amp;#39;x&amp;#39; not found&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code&gt;substitute&lt;/code&gt; returns the unevaluated parse tree for &lt;code&gt;fun&lt;/code&gt;. In other words, it obtains the literal argument that was passed for &lt;code&gt;fun&lt;/code&gt;. This works because of call-by-need semantics in R: function arguments are packaged up into &lt;em&gt;promises&lt;/em&gt;. As a result, the syntax tree of arguments is available for metaprogramming. A recent paper by Goel and Vitek&lt;sup&gt;&lt;a href="#2019-09-10-four-kinds-of-scoping-in-r-footnote-2-definition" name="2019-09-10-four-kinds-of-scoping-in-r-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt; discusses laziness in R in more detail.&lt;/p&gt;

&lt;p&gt;In this example, on line 8, we call &lt;code&gt;factory&lt;/code&gt; with &lt;code&gt;function(a) x+a&lt;/code&gt; as the argument for the formal parameter &lt;code&gt;fun&lt;/code&gt;. Then, we evaluate that parse tree with &lt;code&gt;eval&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;At this point, &lt;code&gt;res&lt;/code&gt; is the closure with expression &lt;code&gt;function(a) x+a&lt;/code&gt; and a reference to the environment of &lt;code&gt;makeTrivial&lt;/code&gt;. On line 3, we change that reference to &lt;code&gt;baseenv()&lt;/code&gt;, which is the environment containing library definitions. Since this environment is above the (user) top-level environment, global variables are not available.&lt;/p&gt;

&lt;p&gt;Therefore, variable lookup in the function literal will only search the base environment, so &lt;code&gt;f()&lt;/code&gt; results in an error.&lt;/p&gt;

&lt;h3 id="static-scoping"&gt;Static scoping&lt;/h3&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;makeStatic&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substitute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="nf"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;globalenv&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;res&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
  &lt;span class="nf"&gt;makeStatic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;h&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;For this example, on line 3, we update the environment of &lt;code&gt;res&lt;/code&gt; to refer to &lt;code&gt;globalenv()&lt;/code&gt;, which is the top-level environment where globals are defined.&lt;/p&gt;

&lt;p&gt;Therefore, variable lookup searches the top-level environment, so &lt;code&gt;f()&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id="lexical-scoping"&gt;Lexical scoping&lt;/h3&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;makeLexical&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substitute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="nf"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;parent.frame&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;res&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
  &lt;span class="nf"&gt;makeLexical&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;h&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Although lexical scoping is the default for R, our factory template requires some metaprogramming to work properly. We need to set the environment of &lt;code&gt;res&lt;/code&gt; to &lt;code&gt;parent.frame()&lt;/code&gt;, which is the environment of the function (&lt;code&gt;h&lt;/code&gt;) that called the current function (&lt;code&gt;makeLexical&lt;/code&gt;). This allows us to simulate lexical scoping, as if the function literal was evaluated inside &lt;code&gt;h&lt;/code&gt;, rather than &lt;code&gt;makeLexical&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Therefore, variable lookup searches the environment of &lt;code&gt;h&lt;/code&gt;, so &lt;code&gt;f()&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id="dynamic-scoping"&gt;Dynamic scoping&lt;/h3&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;makeDynamic&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substitute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="nf"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;parent.frame&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="nf"&gt;res&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
  &lt;span class="nf"&gt;makeDynamic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;h&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;For this example, we need another level of indirection. &lt;code&gt;makeDynamic&lt;/code&gt; returns an anonymous function literal. The anonymous function takes &lt;code&gt;...&lt;/code&gt;, which represents an arbitrary list of arguments, and then on line 5 we call &lt;code&gt;res&lt;/code&gt; with those exact arguments. Note that we set the environment of &lt;code&gt;res&lt;/code&gt; to be the environment of the &lt;em&gt;caller&lt;/em&gt; of the anonymous function. Because of the multiple levels of indirection, the caller is &lt;code&gt;f&lt;/code&gt;, on line 17.&lt;/p&gt;

&lt;p&gt;On line 12, &lt;code&gt;makeDynamic&lt;/code&gt; returns a closure for the anonymous function. &lt;code&gt;h&lt;/code&gt; returns that closure when it is called, and assigns it to &lt;code&gt;g&lt;/code&gt;. When &lt;code&gt;g&lt;/code&gt; is called on line 17, the function literal &lt;code&gt;function(a) x+a&lt;/code&gt; is finally evaluated, and its environment is set to the environment of &lt;code&gt;f&lt;/code&gt;, the caller of &lt;code&gt;g&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Therefore, variable lookup searches the environment of &lt;code&gt;f&lt;/code&gt;, so &lt;code&gt;f()&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Hopefully this blog post has shown another way of looking at scoping definitions. As discussed in the &lt;a href="/blog/2019/09/10/scoping-in-r/"&gt;previous post&lt;/a&gt;, it&amp;rsquo;s very easy to get confused because different definitions are used by different people. Here, Gentleman and Ihaka very clearly state what definitions they are using.&lt;/p&gt;

&lt;p&gt;And finally, while I am far from an expert on metaprogramming in R, I hope this post has given a taste of what is possible.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;I would like to thank Jan Jeƒçmen for coming up with and showing me the original versions of these code examples, and Artem Pelenitsyn for his feedback to improve and not discard these examples from an earlier blog draft.&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id="references"&gt;References&lt;/h2&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2019-09-10-four-kinds-of-scoping-in-r-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;R. Gentleman and R. Ihaka. "Lexical Scope and Statistical Computing, &lt;em&gt;Journal of Computational and Graphical Statistics&lt;/em&gt;, vol. 9, no. 3, 2000. [&lt;a href="https://doi.org/10.1080/10618600.2000.10474895"&gt;DOI&lt;/a&gt;][&lt;a href="https://www.stat.auckland.ac.nz/~ihaka/downloads/lexical.pdf"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-10-four-kinds-of-scoping-in-r-footnote-1-return"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-10-four-kinds-of-scoping-in-r-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;A. Goel and J. Vitek. &amp;ldquo;On the Design, Implementation and Use of Laziness in R,&amp;rdquo; in &lt;em&gt;Proceedings of the ACM in Programming Languages (PACMPL)&lt;/em&gt;, vol. 3, no. OOPSLA, 2019. To appear. [&lt;a href="http://janvitek.org/pubs/oopsla19a.pdf"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-10-four-kinds-of-scoping-in-r-footnote-2-return"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content></entry>
 <entry>
  <title type="text">Scoping in R</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2019/09/10/scoping-in-r/?utm_source=Author-Ming-Ho-Yee&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2019-09-10-scoping-in-r</id>
  <published>2019-09-10T10:00:00Z</published>
  <updated>2019-09-10T10:00:00Z</updated>
  <author>
   <name>Ming-Ho Yee</name></author>
  <content type="html">
&lt;p&gt;In the &lt;a href="/blog/2019/09/05/lexical-and-dynamic-scope/"&gt;previous post&lt;/a&gt; of this three-part blog series, we discussed lexical and dynamic scope. Now, in this second part, we can return to the original question: &lt;em&gt;is R lexically or dynamically scoped?&lt;/em&gt;&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;Recall the example program from before:&lt;/p&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# what does this return?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Let&amp;rsquo;s examine what happens when we run this example. First, we create a mapping for &lt;code&gt;x&lt;/code&gt; in the top-level environment. On line 2, we define a function &lt;code&gt;f&lt;/code&gt;, which returns the value of some &lt;code&gt;x&lt;/code&gt;. On line 3, we define a function &lt;code&gt;g&lt;/code&gt;, which creates a new mapping for &lt;code&gt;x&lt;/code&gt;, and then calls &lt;code&gt;f&lt;/code&gt;. Note that the assignment on line 4 does &lt;em&gt;not&lt;/em&gt; update the definition on line 1.&lt;/p&gt;

&lt;p&gt;When &lt;code&gt;f&lt;/code&gt; is called, it needs to look up the value of &lt;code&gt;x&lt;/code&gt;. In other words, does the reference of &lt;code&gt;x&lt;/code&gt; on line 2 refer to the assignment on line 1 or the assignment on line 4? If &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;, then the behaviour matches lexical scoping. If it returns &lt;code&gt;2&lt;/code&gt;, then the behaviour matches dynamic scoping.&lt;/p&gt;

&lt;p&gt;When we run this example, the result is &lt;code&gt;1&lt;/code&gt;. This implies that R is lexically scoped.&lt;/p&gt;

&lt;p&gt;But there&amp;rsquo;s more to this story. In the rest of this blog post, I&amp;rsquo;ll examine some interesting scoping examples in R, and discuss how the scoping definitions relate to R.&lt;/p&gt;

&lt;p&gt;The &lt;a href="/blog/2019/09/10/four-kinds-of-scoping-in-r/"&gt;next and final part&lt;/a&gt; of this blog series, published simultaneously with this one, is an appendix where I implement four different scoping disciplines in R.&lt;/p&gt;

&lt;h2 id="r-is-lexically-scoped-but"&gt;R is lexically scoped, but&amp;hellip;&lt;/h2&gt;

&lt;p&gt;In &lt;em&gt;Evaluating the Design of the R Language&lt;/em&gt;,&lt;sup&gt;&lt;a href="#2019-09-10-scoping-in-r-footnote-1-definition" name="2019-09-10-scoping-in-r-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt; Morandat, Hill, Osvald, and Vitek write:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;As is often the case, R is lexically scoped up to the point it is not. R is above all a dynamic language with full reflective access to the running program‚Äôs data and representation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In other words, R provides many different &amp;ldquo;escape hatches&amp;rdquo;&amp;mdash;ways to bypass lexical scoping. Additionally, even without escape hatches, some of R&amp;rsquo;s functionality can be surprising.&lt;/p&gt;

&lt;h3 id="functions-environments-and-variables-in-r"&gt;Functions, environments, and variables in R&lt;/h3&gt;

&lt;p&gt;Before we look at some examples, I think it&amp;rsquo;s useful to briefly discuss some of the core concepts in R that relate to scoping.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Functions.&lt;/strong&gt; R has first-class functions, and functions evaluate to  closures. In other words, a function value includes both the body of the  function as well as the environment that the function was evaluated in. In  R, the programmer can modify the environment of a closure. Note that R is  function scoped; there is no block scoping.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Environments.&lt;/strong&gt; An environment in R is a mapping from variables to  values. Each function has its own local environment. Furthermore, each  environment has a reference to the &amp;ldquo;enclosing&amp;rdquo; environment that it was  evaluated in. R environments are first-class, meaning the programmer can  add, modify, or removing variable mappings, and also change the reference to  the enclosing environment.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Variable lookup.&lt;/strong&gt; When R looks up a variable, it will search in the  current environment for a mapping. If no mapping is found, then it will  search in the enclosing environment. This process continues until a mapping  is found, or the topmost, empty environment is reached, in which case an  error is raised.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Variable assignment.&lt;/strong&gt; &lt;code&gt;&amp;lt;-&lt;/code&gt; is the variable assignment operator in R. The  expression &lt;code&gt;x &amp;lt;- 1&lt;/code&gt; assigns the value &lt;code&gt;1&lt;/code&gt; to the variable &lt;code&gt;x&lt;/code&gt; in the  current environment. If a mapping for &lt;code&gt;x&lt;/code&gt; already exists in the  environment, then the assignment will update and overwrite the existing  value. Otherwise, a new mapping is created in the environment. Note that  variable assignment can only update the current environment, and never  creates a scope.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;From this description, we can see that R implements lexical scoping (or at least, something that behaves a lot like lexical scoping): each function value is associated with the environment it was evaluated in, and variable lookup proceeds along the chain of enclosing environments. In fact, the creators of R have confirmed that lexical scoping was their intent.&lt;sup&gt;&lt;a href="#2019-09-10-scoping-in-r-footnote-2-definition" name="2019-09-10-scoping-in-r-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;On the other hand, variable lookup depends on the run-time state of the program&amp;mdash;names cannot be resolved statically. Furthermore, since R provides operations for environment manipulation, a programmer can easily circumvent lexical scoping.&lt;/p&gt;

&lt;p&gt;The following examples will make this clear.&lt;/p&gt;

&lt;h3 id="examples"&gt;Examples&lt;/h3&gt;

&lt;h4 id="adding-variable-mappings-at-run-time"&gt;Adding variable mappings at run time&lt;/h4&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;When &lt;code&gt;f&lt;/code&gt; is called, it creates a function &lt;code&gt;g&lt;/code&gt; that returns &lt;code&gt;x&lt;/code&gt;, assigns &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;, and then calls &lt;code&gt;g&lt;/code&gt;. When &lt;code&gt;g&lt;/code&gt; is called, it looks up &lt;code&gt;x&lt;/code&gt;. Since no mapping is found in &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s environment, it searches in the enclosing environment (&lt;code&gt;f&lt;/code&gt;&amp;rsquo;s), and finds that &lt;code&gt;x&lt;/code&gt; has value &lt;code&gt;2&lt;/code&gt;. Therefore, &lt;code&gt;g&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note that the &lt;code&gt;x&lt;/code&gt; on line 3 is resolved only when function &lt;code&gt;g&lt;/code&gt; is called, not when it is defined. However, when &lt;code&gt;g&lt;/code&gt; is defined, its environment has a reference to &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s environment. Therefore, as long as &lt;code&gt;x&lt;/code&gt; is defined &lt;em&gt;before&lt;/em&gt; &lt;code&gt;g&lt;/code&gt; is called, the lookup will always succeed.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a second example:&lt;/p&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nf"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# 2&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code&gt;f&lt;/code&gt; is a function that branches on its argument, &lt;code&gt;b&lt;/code&gt;. If &lt;code&gt;b&lt;/code&gt; evaluates to true, then the expression &lt;code&gt;x &amp;lt;- 2&lt;/code&gt; is evaluated, and a mapping for &lt;code&gt;x&lt;/code&gt; is created in &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s environment. Otherwise, no mapping is created.&lt;/p&gt;

&lt;p&gt;When we look up the value of &lt;code&gt;x&lt;/code&gt; on line 5, R will first search the function&amp;rsquo;s environment. If &lt;code&gt;b&lt;/code&gt; evaluated to true, then R will find a value for &lt;code&gt;x&lt;/code&gt;, which is &lt;code&gt;2&lt;/code&gt;. Otherwise, R will search in the enclosing environment of &lt;code&gt;f&lt;/code&gt;, and find that &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Both of these examples vaguely resemble dynamic scoping, in that &lt;code&gt;x&lt;/code&gt; takes the value of the most recent assignment. However, this is not how R is implemented, and it is not consistent with how R behaves in other examples.&lt;/p&gt;

&lt;h4 id="function-lookup"&gt;Function lookup&lt;/h4&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# not an error&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;42&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;R has slightly different lookup rules, if the variable is in function call position. Specifically, R will search the environment chain and skip non-function values.&lt;/p&gt;

&lt;p&gt;In this example, we call &lt;code&gt;g&lt;/code&gt; with the argument &lt;code&gt;42&lt;/code&gt;, which is not a function. Then, in the body of &lt;code&gt;g&lt;/code&gt;, we call &lt;code&gt;f(0)&lt;/code&gt; on line 3, which requires looking up &lt;code&gt;f&lt;/code&gt;. Although there is an &lt;code&gt;f&lt;/code&gt; in the environment of &lt;code&gt;g&lt;/code&gt;, its value is &lt;code&gt;42&lt;/code&gt;, which is not a function. R will then search the enclosing environment, where it finds the function defined on line 1. Therefore, the lookup on line 3 resolves to the function on line 1, so &lt;code&gt;f(0)&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This behaviour exists because &lt;code&gt;c&lt;/code&gt; is the built-in function that constructs vectors (in other words, one of the most commonly used functions in R), but it is also a commonly used argument name.&lt;/p&gt;

&lt;h4 id="super-assignment"&gt;Super assignment&lt;/h4&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 1&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt;   &lt;span class="c1"&gt;# 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; is the &amp;ldquo;super assignment&amp;rdquo; operator. It skips the current environment and then searches the chain of enclosing environments until it finds a variable to update. If no variable is found, then a new mapping is created at the top environment.&lt;/p&gt;

&lt;p&gt;In the above program, we define &lt;code&gt;x&lt;/code&gt; to be &lt;code&gt;0&lt;/code&gt; at the top level, and then define the function &lt;code&gt;f&lt;/code&gt;. When we call &lt;code&gt;f&lt;/code&gt; on line 7, it assigns &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; on line 3, which creates a mapping in the local environment. On line 4, the super assignment skips the mapping in the local environment and instead updates the mapping created on line 1. Next, &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;x&lt;/code&gt;, which is looked up from the local environment and has value &lt;code&gt;1&lt;/code&gt;. Finally, line 8 looks up &lt;code&gt;x&lt;/code&gt; from the top level environment, which has value &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id="evaluating-arbitrary-code"&gt;Evaluating arbitrary code&lt;/h4&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nf"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x &amp;lt;- 0"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;R has a mechanism for converting an arbitrary string to code and then executing it. On line 3, we parse and evaluate the argument &lt;code&gt;t&lt;/code&gt;, which happens to be the string &lt;code&gt;"x &amp;lt;- 0"&lt;/code&gt;. Then, when line 4 executes, the lookup of &lt;code&gt;x&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id="simulating-dynamic-scope"&gt;Simulating dynamic scope&lt;/h4&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;
&lt;span class="normal"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;envir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;parent.frame&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;On line 3, we perform an explicit variable lookup for &lt;code&gt;x&lt;/code&gt;, but we do so in the environment &lt;code&gt;parent.frame()&lt;/code&gt;, which refers to the calling function&amp;rsquo;s environment, in this case, &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s environment.. Therefore, the lookup returns &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note that R has a similarly named function, &lt;code&gt;parent.env(e)&lt;/code&gt; which returns the &lt;em&gt;enclosing environment&lt;/em&gt; of the given environment &lt;code&gt;e&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id="constructing-an-arbitrary-environment"&gt;Constructing an arbitrary environment&lt;/h4&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;new.env&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;
  &lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;envir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;When &lt;code&gt;f&lt;/code&gt; is called, it constructs a new environment, &lt;code&gt;e&lt;/code&gt;, which is initially empty. (By default, its enclosing environment is the current environment, which is &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s.) Next, on line 4, it directly adds a mapping to that environment, assigning &lt;code&gt;3&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. Then, on line 5, the lookup is explicitly done in environment &lt;code&gt;e&lt;/code&gt;, so &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id="deleting-mappings"&gt;Deleting mappings&lt;/h4&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nf"&gt;rm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;envir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;parent.env&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# Error in f() : object &amp;#39;x&amp;#39; not found&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Not only is it possible to dynamically add and modify mappings in R, but it is also possible to &lt;em&gt;delete&lt;/em&gt; mappings. This is what line 3 does: it explicitly removes the mapping for &lt;code&gt;x&lt;/code&gt; from the enclosing environment of the current environment. In other words, the definition on line 1 is deleted. Therefore, when &lt;code&gt;f&lt;/code&gt; is called, the lookup of &lt;code&gt;x&lt;/code&gt; fails and an error is raised.&lt;/p&gt;

&lt;h4 id="infinite-loop-during-variable-lookup"&gt;Infinite loop during variable lookup&lt;/h4&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;enva&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;new.env&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;envb&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;new.env&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;parent.env&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;enva&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;envb&lt;/span&gt;
&lt;span class="nf"&gt;parent.env&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;envb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;enva&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="nf"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;enva&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;In this final example, manipulation of environments allows us to create a function where variable lookup results in an infinite loop.&lt;/p&gt;

&lt;p&gt;On lines 1 and 2, we create new, empty environments. Both have the same enclosing environment, which is the top-level environment. However, on lines 3 and 4, we modify their enclosing environments to create a cycle: &lt;code&gt;enva&lt;/code&gt;&amp;rsquo;s enclosing environment is &lt;code&gt;envb&lt;/code&gt;, and &lt;code&gt;envb&lt;/code&gt;&amp;rsquo;s enclosing environment is &lt;code&gt;enva&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On line 5, we define a function with a free variable, &lt;code&gt;x&lt;/code&gt;, but on line 6, we set &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s environment to be &lt;code&gt;enva&lt;/code&gt;. Finally, we call &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When the body of &lt;code&gt;f&lt;/code&gt; is evaluated, it needs to look up &lt;code&gt;x&lt;/code&gt;. Lookup starts in &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s environment, which we set to be &lt;code&gt;enva&lt;/code&gt;. Since no mapping for &lt;code&gt;x&lt;/code&gt; is found, lookup continues in &lt;code&gt;enva&lt;/code&gt;&amp;rsquo;s enclosing environment, which is &lt;code&gt;envb&lt;/code&gt;. However, &lt;code&gt;envb&lt;/code&gt; is also empty, so lookup continues in its enclosing environment, which is &lt;code&gt;enva&lt;/code&gt;, and now lookup results in an infinite loop.&lt;/p&gt;

&lt;h3 id="an-intuition-for-scoping-in-r"&gt;An intuition for scoping in R&lt;/h3&gt;

&lt;p&gt;Some of the above examples appear to demonstrate dynamic scoping. Recall two of our examples:&lt;/p&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# example 1&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 2&lt;/span&gt;

&lt;span class="c1"&gt;# example 2&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nf"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# 2&lt;/span&gt;
&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;It seems that &lt;code&gt;x&lt;/code&gt; takes on the value of the last assignment, but we know this is not the case, from the first example. This is also not how R is implemented. What&amp;rsquo;s missing from our intuition?&lt;/p&gt;

&lt;p&gt;The key insight is that R is &lt;em&gt;function scoped&lt;/em&gt;. In R, each function has an associated environment, and that environment implements a scope. In general, only a function definition can create a scope. Therefore, the assignment operator &lt;code&gt;&amp;lt;-&lt;/code&gt; &lt;em&gt;does not create a new scope&lt;/em&gt;, and it is more useful to think of it as a mutation &lt;em&gt;on the current environment&lt;/em&gt;. (In contrast, in most languages, a variable binding or definition creates a new scope, and an assignment mutates that variable.)&lt;/p&gt;

&lt;p&gt;In a sense, it might be more accurate to say that R &lt;em&gt;environments&lt;/em&gt; are lexically scoped, variables are scoped to functions (but a reference can occur syntactically before a definition), and variable assignment is an update to the environment.&lt;/p&gt;

&lt;h2 id="discussion"&gt;Discussion&lt;/h2&gt;

&lt;p&gt;All of this might make you a little uncomfortable, and uncertain about R&amp;rsquo;s scoping rules.&lt;/p&gt;

&lt;p&gt;On one hand, R passes the first example program as a lexically scoped language, the implementation of closures and variable lookup imply &amp;ldquo;lexical-like&amp;rdquo; behaviour, and the creators have confirmed that lexical scoping was the intent.&lt;/p&gt;

&lt;p&gt;On the other hand, variable lookup depends on the run-time state of the program, and variable bindings cannot be resolved statically. Some of the examples even resemble dynamic scoping, where a free variable takes the value of the most recent assignment&amp;mdash;but this is not consistent with R&amp;rsquo;s behaviour in other examples. Furthermore, the dynamic nature of R and its reflection and metaprogramming capabilities allow programmers to completely circumvent lexical scoping.&lt;/p&gt;

&lt;p&gt;This ambiguity shows up in a paper,&lt;sup&gt;&lt;a href="#2019-09-10-scoping-in-r-footnote-3-definition" name="2019-09-10-scoping-in-r-footnote-3-return"&gt;3&lt;/a&gt;&lt;/sup&gt; where the authors write:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Furthermore, because variable scoping in R is dynamic and can be modified at the language level [&amp;hellip;] it cannot be trivially guaranteed that &lt;code&gt;x&lt;/code&gt; is going to point to the same data structure throughout the entire execution of the loop.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It is true that a variable &lt;code&gt;x&lt;/code&gt; may not point to the same data structure during the execution of a loop. It is true that scoping in R can be modified at the language level.&lt;/p&gt;

&lt;p&gt;It is true that variable &lt;em&gt;lookup&lt;/em&gt; is dynamic, as it is performed at run time and depends on the run-time program state. If that is your definition of &lt;em&gt;dynamic scope&lt;/em&gt;, then it would be fair to say that R is dynamically scoped.&lt;/p&gt;

&lt;p&gt;But if your definition of &lt;em&gt;dynamic scope&lt;/em&gt; is &amp;ldquo;a variable is bound to the most recent assignment during the program&amp;rsquo;s execution,&amp;rdquo; then it is not correct to say R is dynamically scoped.&lt;/p&gt;

&lt;p&gt;I think we have this ambiguity because &lt;em&gt;scope&lt;/em&gt; (the places in a program where a variable can be referenced) and &lt;em&gt;variable lookup&lt;/em&gt; or &lt;em&gt;name resolution&lt;/em&gt; (determining which binding or definition a name refers to) are often considered together. For most lexically scoped languages, name resolution can be done at compile time. For most dynamically scoped languages, name resolution must be done at run time. R is lexically scoped, but must perform name resolution at run time.&lt;/p&gt;

&lt;p&gt;Personally, I prefer the definition of &lt;em&gt;scope&lt;/em&gt; that treats name resolution as an orthogonal issue. I think it is more useful to keep the two issues separate. In addition, I think it is confusing and unhelpful to say that R is &lt;em&gt;both&lt;/em&gt; lexically and dynamically scoped, or that R is &lt;em&gt;neither&lt;/em&gt; lexically and dynamically scoped.&lt;/p&gt;

&lt;p&gt;I think it is more helpful to treat R as a lexically scoped language (with certain exceptions and surprises) than as a dynamically scoped language&amp;mdash;when I read and write R code, I find it more convenient to think about nested function definitions and free variables in terms of lexical scoping rules. And I think that it is more accurate, based on the design and implementation, to classify R as a lexically scoped language.&lt;/p&gt;

&lt;p&gt;Regardless, it is very easy to miscommunicate, so I think it&amp;rsquo;s important to be very clear and make sure you and your audience know what definitions of scoping you&amp;rsquo;re using!&lt;/p&gt;

&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This entire adventure started when we were working on a paper,&lt;sup&gt;&lt;a href="#2019-09-10-scoping-in-r-footnote-4-definition" name="2019-09-10-scoping-in-r-footnote-4-return"&gt;4&lt;/a&gt;&lt;/sup&gt; and asked each other, is R lexically or dynamically scoped? Eventually, it became apparent that we had different definitions of lexical and dynamic scope, so of course we were unable to agree on an answer!&lt;/p&gt;

&lt;p&gt;This got me interested in exploring definitions of scope, the history of lexical scope, and how R fits with traditional definitions of lexical scope. The result was this mini blog series.&lt;/p&gt;

&lt;p&gt;To summarize, I would say that &lt;em&gt;scope&lt;/em&gt; refers to the places in a program where a variable is visible and can be referenced. Under &lt;em&gt;lexical scoping&lt;/em&gt;, the scope of a variable is determined by the lexical (&lt;em&gt;i.e.&lt;/em&gt;, textual) structure of a program. Under &lt;em&gt;dynamic scoping&lt;/em&gt;, a variable is bound to the most recent value assigned to that variable, &lt;em&gt;i.e.&lt;/em&gt;, the most recent assignment during the program&amp;rsquo;s execution.&lt;/p&gt;

&lt;p&gt;I would say that R &lt;em&gt;aims&lt;/em&gt; to be lexically scoped&amp;mdash;it was part of the design and implementation, but certain features make the situation more complicated. In particular, variables are function scoped, definitions do not introduce new scopes, and variable lookup is performed at run time. Furthermore, the dynamic nature of R and its metaprogramming capabilities allow programmers to completely circumvent lexical scoping.&lt;/p&gt;

&lt;p&gt;Finally, there are some definitions of lexical and dynamic scope that also consider variable lookup. Under these definitions, R might be considered a dynamically scoped language, since variable lookup happens at run time. Therefore, it is important to be precise about your definitions!&lt;/p&gt;

&lt;p&gt;If you want more content about R and scoping, the &lt;a href="/blog/2019/09/10/four-kinds-of-scoping-in-r/"&gt;third and final part&lt;/a&gt; of this blog series is already published. In it, I walk through four different examples of using metaprogramming to simulate different scoping disciplines in R.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Edited 2020/02/21:&lt;/strong&gt; For another discussion on R environments and lookups, (and also packages and namespaces, which I did not cover in my post), &lt;a href="http://blog.obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/"&gt;this blog post&lt;/a&gt; has some nice examples and diagrams.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;I would like to thank Sam Caldwell, Guido Chari, Oli Fl√ºckiger, Aviral Goel, Ben Greenman, Jakob Hain, Jan Jeƒçmen, Hugo Musso Gualandi, Artem Pelenitsyn, and Jan Vitek for their comments, feedback, and discussions that have greatly improved and shaped this blog post.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;If you liked this post, you may also be interested in the following Twitter threads about R: &lt;a href="https://twitter.com/mhyee/status/1063983175163158531"&gt;one&lt;/a&gt;, &lt;a href="https://twitter.com/mhyee/status/1067818720532316166"&gt;two&lt;/a&gt; and &lt;a href="https://twitter.com/mhyee/status/1074744049951739905"&gt;three&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id="references"&gt;References&lt;/h2&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2019-09-10-scoping-in-r-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;F. Morandat, B. Hill, L. Osvald, J. Vitek. &amp;ldquo;Evaluating the Design of the R Language,&amp;rdquo; in &lt;em&gt;Proceedings of the European Conference on Object-Oriented Programming (ECOOP)&lt;/em&gt;, 2012. [&lt;a href="https://doi.org/10.1007/978-3-642-31057-7_6"&gt;DOI&lt;/a&gt;][&lt;a href="http://janvitek.org/pubs/ecoop12.pdf"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-10-scoping-in-r-footnote-1-return"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-10-scoping-in-r-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;R. Gentleman and R. Ihaka. &amp;ldquo;Lexical Scope and Statistical Computing&amp;rdquo;, &lt;em&gt;Journal of Computational and Graphical Statistics&lt;/em&gt;, vol. 9, no. 3, 2000. [&lt;a href="https://doi.org/10.1080/10618600.2000.10474895"&gt;DOI&lt;/a&gt;][&lt;a href="https://www.stat.auckland.ac.nz/~ihaka/downloads/lexical.pdf"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-10-scoping-in-r-footnote-2-return"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-10-scoping-in-r-footnote-3-definition" class="footnote-definition"&gt;
   &lt;p&gt;L. Stadler, A. Welc, C. Humer, and M. Jordan. &amp;ldquo;Optimizing R Language Execution via Aggressive Speculation,&amp;rdquo; in &lt;em&gt;Proceedings of the Symposium on Dynamic Languages (DLS)&lt;/em&gt;, 2016. [&lt;a href="https://doi.org/10.1145/2989225.2989236"&gt;DOI&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-10-scoping-in-r-footnote-3-return"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-10-scoping-in-r-footnote-4-definition" class="footnote-definition"&gt;
   &lt;p&gt;O. Fl√ºckiger, G. Chari, J. Jeƒçmen, M.-H. Yee, J. Hain, and J. Vitek. &amp;ldquo;R Melts Brains: An IR for First-Class Environments and Lazy Effectful Arguments,&amp;rdquo; in &lt;em&gt;Proceedings of the Symposium on Dynamic Languages (DLS)&lt;/em&gt;, 2019. To appear. [&lt;a href="http://janvitek.org/pubs/dls19.pdf"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-10-scoping-in-r-footnote-4-return"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content></entry>
 <entry>
  <title type="text">Lexical and Dynamic Scope</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2019/09/05/lexical-and-dynamic-scope/?utm_source=Author-Ming-Ho-Yee&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2019-09-05-lexical-and-dynamic-scope</id>
  <published>2019-09-05T10:00:00Z</published>
  <updated>2019-09-05T10:00:00Z</updated>
  <author>
   <name>Ming-Ho Yee</name></author>
  <content type="html">
&lt;p&gt;This all started with a simple question about the R programming language: &lt;em&gt;is R lexically or dynamically scoped?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;To answer that question, we need to understand what &lt;em&gt;scope&lt;/em&gt; is, along with &lt;em&gt;lexical scope&lt;/em&gt; and &lt;em&gt;dynamic scope&lt;/em&gt;.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;In this blog post, I&amp;rsquo;d like to explain the differences between lexical scope and dynamic scope, and also explore some of the history behind those ideas. In a &lt;a href="/blog/2019/09/10/scoping-in-r/"&gt;subsequent post&lt;/a&gt;, I&amp;rsquo;ll discuss scoping in R and why it can be confusing.&lt;/p&gt;

&lt;h2 id="what-is-scope"&gt;What is scope?&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Scope&lt;/em&gt; refers to the places in a program where a variable is visible and can be referenced.&lt;/p&gt;

&lt;p&gt;An interesting situation is when a function has free variables. Consider the example below:&lt;/p&gt;

&lt;div class="brush: r"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# what does this return?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;On line 1, we create a mapping for &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;1&lt;/code&gt;. On line 2, we define a function &lt;code&gt;f&lt;/code&gt; whose body uses the parameter &lt;code&gt;a&lt;/code&gt;, but also the free variable &lt;code&gt;x&lt;/code&gt;. On line 3, we define a function &lt;code&gt;g&lt;/code&gt;, whose body creates a new mapping for &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;2&lt;/code&gt;, and then calls &lt;code&gt;f(0)&lt;/code&gt;. (Note that line 4 does not update the mapping created on line 1.) Finally, on line 7, we call &lt;code&gt;g()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What value does &lt;code&gt;g&lt;/code&gt; return when it is called? What mapping does the free variable &lt;code&gt;x&lt;/code&gt; on line 2 refer to? Does it refer to the mapping on line 1 that was visible when &lt;code&gt;f&lt;/code&gt; was defined? Or does it refer to the mapping on line 4 that was created just before &lt;code&gt;f&lt;/code&gt; was called?&lt;/p&gt;

&lt;h3 id="lexical-scoping"&gt;Lexical scoping&lt;/h3&gt;

&lt;p&gt;Under &lt;em&gt;lexical scoping&lt;/em&gt; (also known as &lt;em&gt;static scoping&lt;/em&gt;), the scope of a variable is determined by the lexical (&lt;em&gt;i.e.&lt;/em&gt;, textual) structure of a program.&lt;/p&gt;

&lt;p&gt;In the example above, the definition of &lt;code&gt;x&lt;/code&gt; on line 1 creates a scope that starts after its definition and extends &lt;em&gt;into&lt;/em&gt; the bodies of &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;. However, the second definition of &lt;code&gt;x&lt;/code&gt; on line 4 creates a new scope that (1) shadows the previous definition of &lt;code&gt;x&lt;/code&gt;, and (2) does not extend into the call &lt;code&gt;f(0)&lt;/code&gt; on line 5. Looking at this from another direction, the use of &lt;code&gt;x&lt;/code&gt; on line 2 is within the scope created by the definition on line 1, and thus refers to that definition.&lt;/p&gt;

&lt;p&gt;Therefore, under lexical scoping, the example program returns &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Most programming languages we use today are lexically scoped. Intuitively, a human (or compiler) can determine the scope of a variable by just examining the source code of a program. In other words, a compiler can determine which &lt;em&gt;definition&lt;/em&gt; each variable refers to&amp;mdash;but it may not be able to determine the &lt;em&gt;values&lt;/em&gt; of each variable.&lt;/p&gt;

&lt;h3 id="dynamic-scoping"&gt;Dynamic scoping&lt;/h3&gt;

&lt;p&gt;Under &lt;em&gt;dynamic scoping&lt;/em&gt;, a variable is bound to the most recent value assigned to that variable, &lt;em&gt;i.e.&lt;/em&gt;, the most recent assignment &lt;em&gt;during the program&amp;rsquo;s execution&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In the example above, the free variable &lt;code&gt;x&lt;/code&gt; in the body of &lt;code&gt;f&lt;/code&gt; is evaluated when &lt;code&gt;f(0)&lt;/code&gt; is called on line 5. At that point (during program execution), the most recent assignment was on line 4.&lt;/p&gt;

&lt;p&gt;Therefore, under dynamic scoping, the example program returns &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Dynamically scoped programming languages include bash, LaTeX, and the original version of Lisp. Emacs Lisp is dynamically scoped, but allows the programmer to select lexical scoping. Conversely, Perl and Common Lisp are lexically scoped by default, but allow the programmer to select dynamic scoping.&lt;/p&gt;

&lt;p&gt;(&lt;strong&gt;Edited 2020/08/13:&lt;/strong&gt; As of &lt;a href="https://www.gnu.org/savannah-checkouts/gnu/emacs/news/NEWS.27.1"&gt;Emacs 27.1&lt;/a&gt;, &amp;ldquo;lexical binding is now used by default when evaluating interactive Elisp.&amp;rdquo; Thanks to Artem Pelenitsyn for bringing this to my attention.)&lt;/p&gt;

&lt;h2 id="now-for-a-digression"&gt;Now for a digression&lt;/h2&gt;

&lt;p&gt;These are the definitions I learned from my classes and textbooks, and should be similar to other definitions and explanations you might find online.&lt;/p&gt;

&lt;p&gt;However, it took me many drafts and attempts before arriving at the current version. I had difficulty writing an explanation that I was satisfied with&amp;mdash;a definition that was not circular, did not appeal to some intuition or familiarity, and did not conflate terms. Even some of the resources I consulted had these issues.&lt;sup&gt;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-1-definition" name="2019-09-05-lexical-and-dynamic-scope-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;I am much happier with my current version, but it still bothers me slightly. If lexical scope and dynamic scope are related concepts, then why are the definitions so different? Why does the definition for &lt;em&gt;dynamic scope&lt;/em&gt; not mention scope at all? If &lt;em&gt;scope&lt;/em&gt; is about &amp;ldquo;where a variable is visible,&amp;rdquo; and that definition is with respect to a &lt;em&gt;variable definition&lt;/em&gt;, then why do so many explanations and examples define lexical and dynamic scope in terms of &lt;em&gt;variable use&lt;/em&gt;?&lt;/p&gt;

&lt;h2 id="scope-and-extent"&gt;Scope and Extent&lt;/h2&gt;

&lt;p&gt;I found some answers in Guy Steele&amp;rsquo;s &lt;em&gt;Common Lisp the Language, 2nd Edition&lt;/em&gt;,&lt;sup&gt;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-2-definition" name="2019-09-05-lexical-and-dynamic-scope-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt; which Matthias Felleisen recommended to me.&lt;/p&gt;

&lt;p&gt;In chapter 3, Steele introduces the concepts of &lt;em&gt;scope&lt;/em&gt; and &lt;em&gt;extent&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;Scope&lt;/em&gt; refers to the spatial or textual region of the program within which references may occur. &lt;em&gt;Extent&lt;/em&gt; refers to the interval of time during which references may occur.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In addition, there are four interesting cases of scope and extent, with respect to Common Lisp:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;em&gt;Lexical scope&lt;/em&gt;: a reference can only occur within certain textual regions  of the program, which are determined by the establishing construct, &lt;em&gt;e.g.&lt;/em&gt;,  the body of a variable definition.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;em&gt;Indefinite scope&lt;/em&gt;: a reference can occur anywhere in the program.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;em&gt;Dynamic extent&lt;/em&gt;: a reference can occur during the time between an entity&amp;rsquo;s  creation and its explicit destruction, &lt;em&gt;e.g.&lt;/em&gt;, when a local variable is  created upon entering a function and destroyed when returning from that  function.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;em&gt;Indefinite extent&lt;/em&gt;: an entity may exist as long as it is possible to be  referenced. (Note that this is the idea behind garbage collection: an  entity can be destroyed once references to it are impossible.)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Steele points out that &lt;em&gt;dynamic scope&lt;/em&gt; is a misnomer, even though it is both a traditional and useful concept. It can be defined as &lt;em&gt;indefinite scope and dynamic extent&lt;/em&gt;. In other words, references to a variable may occur anywhere in a program, as long as that variable has been initialized and has not yet been explicitly destroyed. Furthermore, a later initialization hides an earlier one.&lt;/p&gt;

&lt;h3 id="discussion"&gt;Discussion&lt;/h3&gt;

&lt;p&gt;I found this approach very informative, because it explicitly distinguishes between space (scope) and time (extent), which further implies a separation between compile time and run time. This explains my unease with the definition of &amp;ldquo;dynamic scope&amp;rdquo;&amp;mdash;it is nominally about textual regions in a program, but also requires consideration of run-time behaviour. Dynamic scope is a misnomer!&lt;/p&gt;

&lt;p&gt;The above definitions are specifically for Common Lisp, but I believe we can learn from them and adapt them for other programming languages.&lt;/p&gt;

&lt;h2 id="a-brief-and-incomplete-history-of-lexical-scope"&gt;A brief and incomplete history of lexical scope&lt;/h2&gt;

&lt;p&gt;During my research of different definitions of lexical scope, I began to wonder if there was an &amp;ldquo;original&amp;rdquo; definition of lexical scope. I did not find one, but I was able to trace some of the connections between Lisp, Scheme, and ALGOL 60. This history is certainly incomplete, but I hope it is somewhat useful and interesting.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;1960&lt;/strong&gt;. John McCarthy publishes the original paper on Lisp.&lt;sup&gt;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-3-definition" name="2019-09-05-lexical-and-dynamic-scope-footnote-3-return"&gt;3&lt;/a&gt;&lt;/sup&gt; In  &lt;em&gt;History of Lisp&lt;/em&gt;,&lt;sup&gt;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-4-definition" name="2019-09-05-lexical-and-dynamic-scope-footnote-4-return"&gt;4&lt;/a&gt;&lt;/sup&gt; McCarthy writes that he borrowed the Œª-notation from  Alonzo Church&amp;rsquo;s lambda calculus, but none of the other ideas. He also  recounts an incident where a programmer desired lexical scoping, but Lisp  used dynamic scoping. McCarthy considered this to be a bug, which Steve  Russell later fixed by developing the &amp;ldquo;FUNARG device.&amp;rdquo;&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;1963&lt;/strong&gt;. After a few years of work, the &lt;em&gt;Revised Report on Algorithm  Language ALGOL 60&lt;/em&gt; is published.&lt;sup&gt;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-5-definition" name="2019-09-05-lexical-and-dynamic-scope-footnote-5-return"&gt;5&lt;/a&gt;&lt;/sup&gt; While &amp;ldquo;lexical scope&amp;rdquo; is not explicitly  mentioned, it is recognizable in the specification.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;1964&lt;/strong&gt;. Peter Landin shows how expressions in programming languages can  be modelled in Church&amp;rsquo;s Œª-notation.&lt;sup&gt;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-6-definition" name="2019-09-05-lexical-and-dynamic-scope-footnote-6-return"&gt;6&lt;/a&gt;&lt;/sup&gt; He also introduces the concept of a  &lt;em&gt;closure&lt;/em&gt;, which pairs a lambda expression with the environment it was  evaluated in.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;1970&lt;/strong&gt;. Joel Moses describes the problem of free variables in  functions.&lt;sup&gt;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-7-definition" name="2019-09-05-lexical-and-dynamic-scope-footnote-7-return"&gt;7&lt;/a&gt;&lt;/sup&gt; He considers both the &amp;ldquo;downward&amp;rdquo; case (where a function is  passed to another function) and the &amp;ldquo;upward&amp;rdquo; case (where a function returns  a function), and remarks on the correspondence between Lisp&amp;rsquo;s FUNARG device  and Landin&amp;rsquo;s closures.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;1975&lt;/strong&gt;. Gerald Sussman and Guy Steele publish the first Scheme paper.&lt;sup&gt;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-8-definition" name="2019-09-05-lexical-and-dynamic-scope-footnote-8-return"&gt;8&lt;/a&gt;&lt;/sup&gt;  They describe their goal of a Lisp-like language that is based on the  lambda calculus. As a consequence, they implement lexical scoping with  closures, to preserve the substitution semantics of the lambda calculus.  They compare this scoping discipline to ALGOL&amp;rsquo;s.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;1978&lt;/strong&gt;. Steele and Sussman describe various programming language design  choices, by developing an interpreter for each programming language  variation.&lt;sup&gt;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-9-definition" name="2019-09-05-lexical-and-dynamic-scope-footnote-9-return"&gt;9&lt;/a&gt;&lt;/sup&gt; In particular, they provide a detailed discussion on  lexical and dynamic scoping.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="next-stop-r"&gt;Next stop, R&lt;/h2&gt;

&lt;p&gt;Now that we have examined the definitions of lexical and dynamic scope, and also explored some history, we are ready to return to the original question. &lt;em&gt;Is R lexically or dynamically scoped?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In the &lt;a href="/blog/2019/09/10/scoping-in-r/"&gt;next blog post&lt;/a&gt;, we&amp;rsquo;ll answer that question, and also see how R can be very confusing.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;I would like to thank Sam Caldwell, Ben Greenman, and Artem Pelenitsyn for their comments and feedback on this blog post.&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2019-09-05-lexical-and-dynamic-scope-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;For example, at one point I defined lexical/dynamic scoping in terms of a &amp;ldquo;lexical environment&amp;rdquo; and a &amp;ldquo;dynamic environment.&amp;rdquo; But (1) that&amp;rsquo;s a circular definition, (2) it assumes the reader has some intuition of how a &amp;ldquo;lexical environment&amp;rdquo; is different from a &amp;ldquo;dynamic environment,&amp;rdquo; and (3) it conflates two different kinds of &amp;ldquo;environment.&amp;rdquo;&amp;nbsp;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-1-return"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-05-lexical-and-dynamic-scope-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;G. Steele. &amp;ldquo;Scope and Extent,&amp;rdquo; in &lt;em&gt;Common Lisp the Language&lt;/em&gt;, 2nd ed. 1990. [&lt;a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node43.html#SECTION00700000000000000000"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-2-return"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-05-lexical-and-dynamic-scope-footnote-3-definition" class="footnote-definition"&gt;
   &lt;p&gt;J. McCarthy. &amp;ldquo;Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I,&amp;rdquo; &lt;em&gt;Communications of the ACM&lt;/em&gt;, vol. 3, no. 4, April 1960. [&lt;a href="https://doi.org/10.1145/367177.367199"&gt;DOI&lt;/a&gt;][&lt;a href="http://jmc.stanford.edu/articles/recursive/recursive.pdf"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-3-return"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-05-lexical-and-dynamic-scope-footnote-4-definition" class="footnote-definition"&gt;
   &lt;p&gt;J. McCarthy. &amp;ldquo;History of LISP,&amp;rdquo; in &lt;em&gt;History of Programming Languages&lt;/em&gt;, 1978. [&lt;a href="https://doi.org/10.1145/800025.1198360"&gt;DOI&lt;/a&gt;][&lt;a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-4-return"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-05-lexical-and-dynamic-scope-footnote-5-definition" class="footnote-definition"&gt;
   &lt;p&gt;P. Naur (ed.). &amp;ldquo;Revised Report on Algorithmic Language ALGOL 60,&amp;rdquo; &lt;em&gt;Communications of the ACM&lt;/em&gt;, vol. 6, no. 1, January 1963. [&lt;a href="http://dx.doi.org/10.1145/366193.366201"&gt;DOI&lt;/a&gt;][&lt;a href="https://www.masswerk.at/algol60/report.htm"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-5-return"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-05-lexical-and-dynamic-scope-footnote-6-definition" class="footnote-definition"&gt;
   &lt;p&gt;P. Landin. &amp;ldquo;The mechanical evaluation of expressions,&amp;rdquo; &lt;em&gt;The Computer Journal&lt;/em&gt;, vol. 6, no. 4, January 1964. [&lt;a href="https://doi.org/10.1093/comjnl/6.4.308"&gt;DOI&lt;/a&gt;][&lt;a href="https://www.cs.cmu.edu/~crary/819-f09/Landin64.pdf"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-6-return"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-05-lexical-and-dynamic-scope-footnote-7-definition" class="footnote-definition"&gt;
   &lt;p&gt;J. Moses. &amp;ldquo;The Function of FUNCTION in LISP or Why the FUNARG Problem Should be Called the Environment Problem,&amp;rdquo; &lt;em&gt;SIGSAM Bulletin 15&lt;/em&gt;, July 1970. [&lt;a href="https://doi.org/10.1145/1093410.1093411"&gt;DOI&lt;/a&gt;][&lt;a href="https://dspace.mit.edu/handle/1721.1/5854"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-7-return"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-05-lexical-and-dynamic-scope-footnote-8-definition" class="footnote-definition"&gt;
   &lt;p&gt;G. Sussman and G. Steele. &amp;ldquo;SCHEME: An Interpreter for Extended Lambda Calculus.&amp;rdquo; 1975. [&lt;a href="https://dspace.mit.edu/handle/1721.1/5794"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-8-return"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-09-05-lexical-and-dynamic-scope-footnote-9-definition" class="footnote-definition"&gt;
   &lt;p&gt;G. Steele and G. Sussman. &amp;ldquo;The Art of the Interpreter or, The Modularity Complex (Parts Zero, One, and Two).&amp;rdquo; 1978. [&lt;a href="https://dspace.mit.edu/handle/1721.1/6094"&gt;Available online&lt;/a&gt;]&amp;nbsp;&lt;a href="#2019-09-05-lexical-and-dynamic-scope-footnote-9-return"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content></entry>
 <entry>
  <title type="text">On-Stack Replacement</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2019/01/28/on-stack-replacement/?utm_source=Author-Ming-Ho-Yee&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2019-01-28-on-stack-replacement</id>
  <published>2019-01-28T10:29:57Z</published>
  <updated>2019-01-28T10:29:57Z</updated>
  <author>
   <name>Ming-Ho Yee</name></author>
  <content type="html">
&lt;p&gt;Last semester, I took &lt;a href="https://course.ccs.neu.edu/cs7600/"&gt;a course&lt;/a&gt; where the final project was to write a survey paper on &amp;ldquo;a topic in the intersection between computer systems and your area.&amp;rdquo; So I wrote about on-stack replacement.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;&lt;strong&gt;Abstract&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;On-stack replacement (OSR) is a programming language implementation technique that allows a running program to switch to a different version of code. For example, a program could start executing optimized code, and then transfer to and start executing unoptimized code. This was the original use case for OSR, to facilitate debugging of optimized code.&lt;/p&gt;
 &lt;p&gt;After its original use was established, OSR shifted to a different use case: optimizing programs. OSR allows the run-time system to detect if a program is executing an inefficient loop, recompile and optimize the method that contains the loop, and then transfer control to the newly compiled method. Another strategy is to optimize code based on some assumptions, then, if the assumptions are invalidated at run-time, transfer control back to the original, unoptimized code.&lt;/p&gt;
 &lt;p&gt;In this survey paper, we study how OSR was first introduced as a means for debugging, how it came to be used for program optimizations, its implementation as a reusable library, and other directions of research.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If you&amp;rsquo;re interested, you can find a copy &lt;a href="/img/cs7600-mhyee-survey-paper-osr.pdf"&gt;here&lt;/a&gt; or on &lt;a href="https://www.overleaf.com/read/smcmsnksxfdk"&gt;Overleaf&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;If you liked this post, you may also be interested in &lt;a href="http://prl.ccs.neu.edu/blog/2017/03/15/tracing-jits-for-dynamic-languages/"&gt;tracing JITs for dynamic languages&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Spring 2017 PL Junior Retrospective</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2017/06/16/spring-2017-pl-junior-retrospective/?utm_source=Author-Ming-Ho-Yee&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2017-06-16-spring-2017-pl-junior-retrospective</id>
  <published>2017-06-16T11:38:25Z</published>
  <updated>2017-06-16T11:38:25Z</updated>
  <author>Ben Chung</author>
  <author>Milo Davis</author>
  <author>Ming-Ho Yee</author>
  <author>Matt Kolosick</author>
  <author>Dustin Jamner</author>
  <author>Artem Pelenitsyn</author>
  <author>Julia Belyakova</author>
  <author>Sam Caldwell</author>
  <author>
   <name>Ben Chung, Milo Davis, Ming-Ho Yee, Matt Kolosick, Dustin Jamner, Artem Pelenitsyn, Julia Belyakova, Sam Caldwell</name></author>
  <content type="html">
&lt;p&gt;The &lt;a href="http://prl.ccs.neu.edu/seminars.html"&gt;PL Junior Seminar&lt;/a&gt; is for beginning PhD and interested undergrad and masters students to understand the foundations of programming languages research. It serves to fill in background knowledge and get up to speed with different areas of PL research.&lt;/p&gt;

&lt;p&gt;For the spring 2017 instance of PL Junior we chose program synthesis, the sequent calculus, and logic programming as topics we wanted to learn more about. We also did two group paper readings for Luca Cardelli&amp;rsquo;s &lt;a href="http://www.lucacardelli.name/Papers/TypefulProg.pdf"&gt;Typeful Programming&lt;/a&gt; and Alan Kay&amp;rsquo;s &lt;a href="http://worrydream.com/EarlyHistoryOfSmalltalk/"&gt;Early History of Smalltalk&lt;/a&gt;. At the same time, we changed up the format from the previous semester.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h2 id="format"&gt;Format&lt;/h2&gt;

&lt;p&gt;As discussed in &lt;a href="http://prl.ccs.neu.edu/blog/2017/01/02/fall-2016-pl-junior-retrospective/"&gt;last fall&amp;rsquo;s retrospective&lt;/a&gt;, we wanted to move from group reading and discussion towards weekly presentations. Reading a paper to prepare a presentation is quite a different experience compared to the effort that goes in when it is just for a group discussion (in our experience). With any luck, the presentation will convey some of this deeper knowledge to the rest of the group, with the result being a deep understanding on the part of the presenter and an informed, if somewhat shallower, understanding in the rest of the group. Ideally, the end result should compare favorably to simply reading the paper individually.&lt;/p&gt;

&lt;p&gt;One idea from last semester that we decided to keep is to spend a length of time (possibly an entire semester) on a topic rather than having a new topic each week. Staying on the same theme helps with retention as well as allowing for deeper investigation.&lt;/p&gt;

&lt;p&gt;In that spirit, we chose three themes for the semester: program synthesis, the sequent calculus, and logic programming. Mostly by chance, these topics have interesting connections to each other, and we even had several PL Grown-Up Seminars this semester on program synthesis!&lt;/p&gt;

&lt;h2 id="synthesis"&gt;Synthesis&lt;/h2&gt;

&lt;p&gt;The first paper on program synthesis that we looked at was &lt;a href="https://www.sri.com/sites/default/files/uploads/publications/pdf/725.pdf"&gt;A Deductive Approach to Program Synthesis&lt;/a&gt; by Manna and Waldinger. We chose this paper because it&amp;rsquo;s old and has a lot of citations so it&amp;rsquo;s probably Important. It was interesting and provided an OK introduction to proof search but the method presented seems far removed from modern synthesis techniques.&lt;/p&gt;

&lt;p&gt;The next paper was &lt;a href="https://arxiv.org/abs/1507.02988"&gt;Programmatic and Direct Manipulation, Together&lt;/a&gt; by Chugh, Hempel,  Spradlin, and Alders, which presents the &lt;a href="https://ravichugh.github.io/sketch-n-sketch/index.html"&gt;Sketch-n-Sketch&lt;/a&gt; system. Sketch-n-Sketch is a cool system. It demonstrates that a narrow application of synthesis - trying to fill in the constant values in a program (sketching) - can be used for great effect. We were left wondering, however, if it was too narrow an application of synthesis to give much of an indication of what the entire field is like.&lt;/p&gt;

&lt;p&gt;We concluded our program synthesis segment with &lt;a href="http://www.cis.upenn.edu/~stevez/papers/OZ15.pdf"&gt;Type-and-Example-Directed Program Synthesis&lt;/a&gt; by Osera and Zdancewic, another relatively recent paper. This seems like a relevant paper because we are under the impression that using examples to do synthesis is a big thing right now. Using types to constrain the search is another interesting perspective on techniques for synthesis.&lt;/p&gt;

&lt;p&gt;While each of theses papers had merits, none was so comprehensive as to be a necessary inclusion in any future look at program synthesis for pl junior&lt;/p&gt;

&lt;h2 id="sequent-calculus"&gt;Sequent Calculus&lt;/h2&gt;

&lt;p&gt;We followed up the program synthesis unit with a week on the sequent calculus. The seminar presentation was based on a paper by &lt;a href="https://hal.inria.fr/inria-00381525/document"&gt;Herbelin&lt;/a&gt;. &lt;a href="http://www.ccs.neu.edu/home/gasche/phd_thesis/scherer-thesis.pdf"&gt;Gabriel‚Äôs thesis&lt;/a&gt; (chapter 4) includes maybe a more suitable modern introduction to the sequent calculus.&lt;/p&gt;

&lt;p&gt;It might have been better to do sequent calculus first because there is a modern branch of proof search based on the sequent calculus. Presenting this first would have allowed us to look into proof search for program synthesis.&lt;/p&gt;

&lt;p&gt;An additional problem is that it was insufficiently motivated. Either skipping the topic or spending more time on it would be preferable, since one week was just enough to describe the sequent calculus but not enough to apply it. For this topic to be worthwhile, it would best be used as the basis for subsequent readings that directly reference it.&lt;/p&gt;

&lt;h2 id="logic-programming"&gt;Logic Programming&lt;/h2&gt;

&lt;p&gt;The topic was presented over two weeks. The first session presented/demoed Prolog as a language, and we got a sense of what logic programming could do. But it was a whirlwind tour, and we were left wondering about specific details (how proof search runs, what &lt;code&gt;cut&lt;/code&gt; does).&lt;/p&gt;

&lt;p&gt;The second session presented the paper &lt;a href="http://www.doc.ic.ac.uk/~rak/papers/kowalski-van_emden.pdf"&gt;The Semantics of Predicate Logic as a Programming Language&lt;/a&gt;. It was interesting and insightful but left wondering how it relates to the implementation of real logic programming languages.&lt;/p&gt;

&lt;p&gt;In hindsight this was about as far as we could have gotten in just two weeks. However, complications such as the cut rule seem prevalent enough in practice that more time would be required to build up a useful understanding of logic programming&lt;/p&gt;

&lt;h2 id="bonus-rounds"&gt;Bonus Rounds&lt;/h2&gt;

&lt;p&gt;We also used a few weeks to read and discuss specific papers as a group.&lt;/p&gt;

&lt;p&gt;The first paper we read was Cardelli&amp;rsquo;s &lt;a href="http://www.lucacardelli.name/Papers/TypefulProg.pdf"&gt;Typeful Programming&lt;/a&gt;. We picked typeful programming because Matthias has mentioned on occasion how important he thinks it is.&lt;/p&gt;

&lt;p&gt;It was an interesting read; more of an essay than a paper. It really stood out as different from the other academic publications that we have looked at. It‚Äôs a walk through of a language design motivating each design decision in practical terms, as in things that actually help the programmer.&lt;/p&gt;

&lt;p&gt;Cardelli places great importance on polymorphism (subtyping in addition to parametric), as well as features for programming in the large such as modules and interfaces. Several features are interesting in their omission, like type inference and macros.&lt;/p&gt;

&lt;p&gt;After reading it it‚Äôs not clear why Matthias thinks it‚Äôs so important. From the perspective of modern researchers, many of the features in Cardelli&amp;rsquo;s language seem rather mundane. However, it&amp;rsquo;s likely that at the time he published it, these ideas were significantly newer and much less widespread.&lt;/p&gt;

&lt;p&gt;The other paper we read as a group was Alan Kay&amp;rsquo;s &lt;a href="http://worrydream.com/EarlyHistoryOfSmalltalk/"&gt;The Early History of Smalltalk&lt;/a&gt;. It seems like the Smalltalk project investigated a plethora of interesting ideas about designing programming languages and environments. This article seems to confirm that but does not delve into many particulars.&lt;/p&gt;

&lt;h2 id="final-thoughts"&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Overall this semester of pl junior went well enough that we think it makes a reasonable template for future semesters. The topics were interesting and relevant, and we mostly picked appropriate material for presentations. One downside is that we didn‚Äôt quite ‚Äòfill out‚Äô the semester with presentations due to scheduling and not wanting to make some people present twice. Here‚Äôs a lesson: recruit more people to the phd program (or get more undergrads) so you don‚Äôt have this problem!&lt;/p&gt;

&lt;p&gt;Having papers in a theme helped a lot over previous paper-presentation iterations of pl junior. It helped each week being able to build on what we learned last week, as opposed to having a whirlwind of unrelated topics.&lt;/p&gt;

&lt;p&gt;Writing this retrospective has also proven to be a beneficial exercise. Especially with our sequences of connected topics, looking back has allowed us to put the earlier papers into perspective and better assess both their relevance and presentation.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Report: PLISS 2017</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2017/06/05/report-pliss-2017/?utm_source=Author-Ming-Ho-Yee&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2017-06-05-report-pliss-2017</id>
  <published>2017-06-05T15:47:59Z</published>
  <updated>2017-06-05T15:47:59Z</updated>
  <author>
   <name>Ming-Ho Yee</name></author>
  <content type="html">
&lt;p&gt;Two weeks ago, I attended the first &lt;a href="https://pliss2017.github.io/"&gt;Programming Language Implementation Summer School&lt;/a&gt;, held in beautiful Bertinoro, Italy.&lt;/p&gt;

&lt;p&gt;The goal of PLISS was &amp;ldquo;to prepare early graduate students and advanced undergraduates for research in the field,&amp;rdquo; and I think it successfully accomplished that. There were many talks in a variety of areas, such as just-in-time compilers, garbage collection, static analysis, and distributed systems. But PLISS was more than just a series of talks: PLISS provided an environment for interacting with other students as well as senior researchers.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h2 id="the-talks"&gt;The Talks&lt;/h2&gt;

&lt;p&gt;With the amount of technical content at PLISS, there was easily something for everyone. &lt;a href="http://janvitek.org/"&gt;Jan Vitek&lt;/a&gt; and &lt;a href="http://tratt.net/laurie/"&gt;Laurence Tratt&lt;/a&gt; gave lectures that included hands-on exercises where we worked on JITs. &lt;a href="https://www.cs.purdue.edu/homes/suresh/"&gt;Suresh Jagannathan&lt;/a&gt; dived into the operational semantics of a distributed system, so we could reason about different weak consistency models. Francesco Logozzo gave us a whirlwind tour of abstract interpretation.&lt;/p&gt;

&lt;p&gt;Most of my favorite talks included some form of extra content, such as exercises, live-coding presentations, or demos. I found it really helpful to write actual code and apply what I had just learned, or to look at some concrete examples. The examples and exercises also helped with the pacing, as actively listening to four 90-minute talks every day is exhausting!&lt;/p&gt;

&lt;p&gt;Off the top of my head, these were some of my favorite talks:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Dynamic Programming Language Implementation with LLVM&lt;/strong&gt;, by Petr Maj, Oli  Fl√ºckiger, and &lt;a href="http://janvitek.org/"&gt;Jan Vitek&lt;/a&gt;. As the first talk of the summer school, this  was a gentle introduction for the rest of the week. We had &lt;a href="https://github.com/PRL-PRG/pliss-rift/"&gt;exercises&lt;/a&gt;  (with intentional bugs to make us think!), and also brief overviews of  intermediate languages, static analysis, and garbage collection. These three  topics would later show up in more detail.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Micro Virtual Machines&lt;/strong&gt;, by &lt;a href="http://users.cecs.anu.edu.au/~steveb/"&gt;Steve Blackburn&lt;/a&gt;. This talk covered  background information on virtual machines, and also the &lt;a href="http://microvm.github.io/"&gt;Micro VM&lt;/a&gt;  project that Steve&amp;rsquo;s group has been working on. A lot of the material was  already familiar to me, but I still enjoyed the talk, and even got a few  ideas for the project I&amp;rsquo;m working on!&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Static Analysis&lt;/strong&gt;, by &lt;a href="http://matt.might.net/"&gt;Matt Might&lt;/a&gt;. Matt&amp;rsquo;s talk was based on one of  his &lt;a href="http://matt.might.net/articles/intro-static-analysis/"&gt;articles&lt;/a&gt; and an older talk he&amp;rsquo;s given. Impressively, the entire  example was live-coded, with only a single mistake!&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Testing Language Implementations&lt;/strong&gt;, by &lt;a href="http://multicore.doc.ic.ac.uk/"&gt;Alastair Donaldson&lt;/a&gt;. This was  an entertaining talk, since Ally showed multiple examples of crashing  compilers, and causing other kinds of mischief by triggering compiler bugs.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;If you&amp;rsquo;re disappointed that you couldn&amp;rsquo;t see these talks, don&amp;rsquo;t worry! The talks were recorded and will be posted very shortly.&lt;/p&gt;

&lt;h2 id="the-people"&gt;The People&lt;/h2&gt;

&lt;p&gt;But there&amp;rsquo;s more to PLISS than the talks. I&amp;rsquo;m referring to &lt;em&gt;networking&lt;/em&gt;, or the opportunity to get out and talk to other people about research.&lt;/p&gt;

&lt;p&gt;As an early graduate student, I&amp;rsquo;ve been given a lot of advice about talking to people at conferences and the importance of the &amp;ldquo;hallway track.&amp;rdquo; I still have difficulty doing this at an actual conference, like &lt;a href="http://pldi17.sigplan.org/home"&gt;PLDI&lt;/a&gt; or &lt;a href="http://2017.ecoop.org/"&gt;ECOOP&lt;/a&gt;. When there are hundreds of attendees, or when people already know each other and are in conversation groups, I find it difficult to approach them.&lt;/p&gt;

&lt;p&gt;This was not the case at PLISS. There were fewer attendees: about fifty students and a dozen speakers. There was a good mix of undergraduate, master&amp;rsquo;s, first-year PhD, and more senior PhD students. All our breakfasts, lunches, and breaks were together, so we would see the same people again and again, and inevitably start to learn each other&amp;rsquo;s names. The speakers would also be among us, and there was a good ratio of speakers to students for discussions and mealtime mentoring.&lt;/p&gt;

&lt;p&gt;I had many opportunities to practice my &amp;ldquo;research pitch.&amp;rdquo; I talked to senior students and got advice. I talked to junior students and gave advice. Two different people I talked to about my research pointed me to the same paper to read. I found another student who was working with &lt;a href="http://research.cs.wisc.edu/wpis/papers/popl95.pdf"&gt;IFDS&lt;/a&gt;, an algorithm I have spent much time trying to understand. And, one day at lunch, my table discovered that we were all working on static analysis!&lt;/p&gt;

&lt;p&gt;As much as I enjoyed the talks, I think the best part of PLISS was meeting and talking to other people. You can replace talks with videos (but you lose the speaker-audience interaction), and you can replace conversations with other forms of communication. But there isn&amp;rsquo;t really anything that can replace the serendipity of bumping into someone with a shared interest.&lt;/p&gt;

&lt;h2 id="the-location"&gt;The Location&lt;/h2&gt;

&lt;p&gt;Actually, the &lt;em&gt;other&lt;/em&gt; best part of PLISS was the location. Italy is a beautiful country with delicious food. And Bertinoro is a small town on the top of a hill, with a breathtaking view of the surrounding area. The lectures were held in a &lt;a href="https://pliss2017.github.io/images/pics/7.jpg"&gt;castle at the top of the hill&lt;/a&gt; (photo credit: Steve Blackburn). The speakers lived in the castle for the week, while the students lived in the former monastery (seems fitting), which has been renovated into a university residence.&lt;/p&gt;

&lt;p&gt;Here are my two favorite pictures I took (click for full size):&lt;/p&gt;

&lt;p&gt;&lt;a href="/img/pliss2017-1.jpg"&gt;&lt;img src="/img/pliss2017-1-thumb.jpg" alt="View from the castle" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="/img/pliss2017-2.jpg"&gt;&lt;img src="/img/pliss2017-2-thumb.jpg" alt="Panorama" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Steve Blackburn has more pictures posted on the &lt;a href="https://pliss2017.github.io/"&gt;PLISS website&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="final-thoughts"&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;PLISS was a wonderful event. Many thanks need to be given to the speakers, organizers, and sponsors, for making this possible!&lt;/p&gt;

&lt;p&gt;If and when there is a second PLISS, I highly encourage students to apply! You will learn a lot from the lectures, from talking to the speakers, and meeting other students. And if it&amp;rsquo;s in Bertinoro again, you can enjoy the weather and nice view!&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Tracing JITs for Dynamic Languages</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2017/03/15/tracing-jits-for-dynamic-languages/?utm_source=Author-Ming-Ho-Yee&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2017-03-15-tracing-jits-for-dynamic-languages</id>
  <published>2017-03-15T10:54:39Z</published>
  <updated>2017-03-15T10:54:39Z</updated>
  <author>
   <name>Ming-Ho Yee</name></author>
  <content type="html">&lt;!-- more--&gt;

&lt;p&gt;Traditional JIT (just-in-time) compilers are method-based: they compile &amp;ldquo;hot&amp;rdquo; (i.e. frequently executed) methods to native code. An alternative is trace-based or tracing JITs, where the compilation unit is a (hot) sequence of instructions. Typically, such sequences of instructions correspond to loops, where programs spend most of their execution time.&lt;/p&gt;

&lt;p&gt;Where did the idea of tracing come from? What was appealing about it? How was tracing adapted for JITs and dynamic languages? What happened to Mozilla&amp;rsquo;s TraceMonkey, which used to be part of Firefox? Do any JITs today use tracing?&lt;/p&gt;

&lt;p&gt;In this talk, I trace tracing JITs from their origins to some of their recent developments. I cover five papers: the original tracing paper, an implementation of a tracing JIT for Java, the TraceMonkey JIT for JavaScript, PyPy&amp;rsquo;s &amp;ldquo;meta-level&amp;rdquo; tracing, and a specific class of optimizations for tracing JITs.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(The idea of using the phrase &amp;ldquo;trace tracing JITs&amp;rdquo; is from Matthias Felleisen.)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;All materials can be found in the &lt;a href="https://github.com/nuprl/hopl-s2017/tree/master/tracing-jit"&gt;course repository&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/hopl-s2017/blob/master/tracing-jit/notes.pdf"&gt;Full notes&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/hopl-s2017/blob/master/tracing-jit/annotated.txt"&gt;Annotated bibliography&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;If you liked this post, you may also be interested in &lt;a href="http://prl.ccs.neu.edu/blog/2019/01/28/on-stack-replacement/"&gt;on-stack replacement&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Fall 2016 PL Junior Retrospective</title>
  <link rel="alternate" href="http://prl.ccs.neu.edu/blog/2017/01/02/fall-2016-pl-junior-retrospective/?utm_source=Author-Ming-Ho-Yee&amp;utm_medium=Atom" />
  <id>urn:http-prl-ccs-neu-edu:-blog-2017-01-02-fall-2016-pl-junior-retrospective</id>
  <published>2017-01-02T16:39:37Z</published>
  <updated>2017-01-02T16:39:37Z</updated>
  <author>Ben Chung</author>
  <author>Milo Davis</author>
  <author>Ming-Ho Yee</author>
  <author>Sam Caldwell</author>
  <author>
   <name>Ben Chung, Milo Davis, Ming-Ho Yee, Sam Caldwell</name></author>
  <content type="html">
&lt;p&gt;The &lt;a href="http://prl.ccs.neu.edu/seminars.html"&gt;Programming Language Seminar, Junior&lt;/a&gt; (or ‚ÄúPL Junior‚Äù), is a seminar for junior students to learn and discuss topics at a pace more suitable to our background. This semester, we decided to study dependent types. We chose this topic because&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;working from the &lt;a href="https://mitpress.mit.edu/books/types-and-programming-languages"&gt;TAPL&lt;/a&gt; presentation of type systems, dependent types are a step up in difficulty (excepting F-omega-sub), and&lt;/li&gt;
 &lt;li&gt;they represent a significant increase in the reasoning power of types over programs.&lt;/li&gt;&lt;/ol&gt;
&lt;!-- more--&gt;

&lt;p&gt;There was a preference for learning how to implement a dependent type system, instead of spending a significant amount of time reading papers, especially dense type-theoretic papers suggested by &lt;a href="http://purelytheoretical.com/sywtltt.html"&gt;posts&lt;/a&gt; like &lt;a href="http://jozefg.bitbucket.org/posts/2015-08-14-learn-tt.html"&gt;these&lt;/a&gt;. So we followed the &lt;a href="https://github.com/sweirich/pi-forall"&gt;pi-for-all&lt;/a&gt; lecture series given by Stephanie Weirich at &lt;a href="https://www.cis.upenn.edu/~bcpierce/attapl/"&gt;OPLSS&lt;/a&gt;, which focuses on implementing a simple dependently-typed programming language.&lt;/p&gt;

&lt;p&gt;After the pi-for-all lectures, we read chapter two of Edwin Brady‚Äôs &lt;a href="https://eb.host.cs.st-andrews.ac.uk/writings/thesis.pdf"&gt;dissertation on implementing dependently typed languages&lt;/a&gt;. The thesis includes a relatively approachable introduction to TT, the core dependent type theory of Epigram.&lt;/p&gt;

&lt;p&gt;Along the way, we became sidetracked by &lt;a href="https://en.wikipedia.org/wiki/System_U#Girard.27s_paradox"&gt;Girard‚Äôs paradox&lt;/a&gt;. In the first pi-for-all lecture, we came across the Type-in-Type rule. (In a dependent type system the term and the type languages are the same. However, we still need to distinguish what is a ‚Äúprogram‚Äù and what is a ‚Äútype,‚Äù for instance, so that we can determine that the annotation of a function‚Äôs argument is valid. So a construct in the term language is Type, which is meant to describe those things that are valid in programs where we expect to find a type). In the lecture, this prompted the comment that this (‚Äúof course‚Äù) makes our system inconsistent as a logic, but there was no further elaboration, and we could not figure out how to use this fact to show inconsistency.&lt;/p&gt;

&lt;p&gt;It turns out the reason Type-in-Type is inconsistent is quite complicated. It is explained in a &lt;a href="https://www.cs.cmu.edu/~kw/scans/hurkens95tlca.pdf"&gt;paper&lt;/a&gt; that we had difficulty understanding. So we turned to the students in our lab that have expertise in the area. The answer we received is that, intuitively, it is inconsistent for the same reason as Russell‚Äôs paradox (or the Burali-Forti paradox), but the actual proof is actually quite involved. The lesson we drew is that despite being ‚Äúobvious,‚Äù Type-in-Type being inconsistent is not easy to prove. The way people seem to throw around this conclusion is confusing from a beginner‚Äôs point of view.&lt;/p&gt;

&lt;p&gt;The best thing about the pi-for-all series is that it demystified dependent types for us. We gained confidence in being able to whiteboard a dependent type system with the ease of System-F or STLC. If we had one complaint, the presentation of the material relied heavily on Haskell details. The unbound library to handle variables in the implementation results in a somewhat ‚Äúmagicy‚Äù representation of binding; it‚Äôs not clear that the benefits are so great as to outweigh the cost of just implementing alpha-equivalence and capture-avoiding-substitution. Overall they were high-quality lectures. As hinted above, we didn‚Äôt particularly care for the second lecture that was mostly a code walk-through. One advantage of watching videos was that we could speed through parts we were already comfortable with.&lt;/p&gt;

&lt;p&gt;With Edwin Brady‚Äôs dissertation, we got a glimpse of how quickly the details of a dependently typed language get hairy. Looking at you, inductive data definitions and eliminations. There were some extremely large type signatures. While this exercise boosted our confidence that we could read Serious Dependent Types‚Ñ¢ papers, it also gave evidence that our fears of incomprehensibility were not completely unfounded.&lt;/p&gt;

&lt;p&gt;This issue appeared before in our discussion of Girard‚Äôs Paradox. In the discussion of the paradox, we got stuck when we tried to understand the very complex term that inhabited the bottom type. Dependent typing, and discussions thereof, allow very rich, meaningful, and complex types that are as complex as the code that they abstract over. While we are used to understanding these structures in code, parsing a complex type and its fundamental meaning gave us considerable difficulty.&lt;/p&gt;

&lt;h2 id="thoughts-on-the-format"&gt;Thoughts on the format&lt;/h2&gt;

&lt;p&gt;Our meetings this semester were all of the form ‚Äúwe‚Äôll watch this lecture or read this chapter, and then discuss it next week.‚Äù Next semester we would like to go back to presenting each week. We feel doing presentations forces the presenter to reach a deeper understanding of the material. This semester we got a relatively shallow understanding of a broad area. A deeper understanding with a narrower focus may be more beneficial (or complementary).&lt;/p&gt;

&lt;p&gt;[[Sam‚Äôs defense as Grand Convener of PL Junior: Once we picked dependent types as a topic, doing presentations was not an option. We didn‚Äôt have the expertise in the area to pick out different sub-topics and papers suitable for presentations. And, since we were short-handed (4 people each week), we would be presenting once a month!]]&lt;/p&gt;

&lt;p&gt;If we continue learning more about dependent types it would be by: 1) Doing more reading, such as the &lt;a href="https://www.cis.upenn.edu/~bcpierce/attapl/"&gt;ATTAPL&lt;/a&gt; chapter or the programming in Martin-L√∂f‚Äôs type theory material. 2) Actually trying to implement some of the things we‚Äôve learned this semester 3) Playing around with more of the various dependent type systems and theorem provers out there&lt;/p&gt;

&lt;p&gt;For future pl junior cohorts or anyone else in learning about dependent types: Pi-for-all is useful material, but could be condensed into two weeks (for example, by watching the lectures at 1.5x speed) instead of four. Don‚Äôt worry about Type-in-Type. The Epigram material is OK but you might be better served looking at ATTAPL first. At some point, you will have to read the dense papers, but pi-for-all is a good introduction.&lt;/p&gt;</content></entry></feed>